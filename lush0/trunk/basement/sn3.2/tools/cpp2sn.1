.TH CPP2SN 1 "AT&T Laboratories"
.SH NAME
cpp2sn \- SN interface builder for C++ classes
.SH SYNOPSIS
.B cpp2sn 
[\| \-cpp 
tfile.cpp \|] [\| \-h 
tfile.h \|] 
[\| \-sn 
tfile.sn \|]
sfile1.h
[\| sfile2.h ... \|]
.SH DESCRIPTION
.B cpp2sn
take a list of C++ header files sfile1.h, sfile2.h... and
generates an SN interface to the public method of the classes defined
in those file.  Three file are produced in the process.  The SN file
contains all the LISP definition of the classes and their methods, 
together with their documentation.  The C++ file contains functions
visible from C, which make calls the C++ methods.  The header file
in included in both the C++ file, and the C file generated by compiling
the SN file.  It is the glue between them.
.PP
Once the three files has been generated, the SN file can be loaded 
from sn3.1, and all the classes, the methods and their documentation
should be visible.
.PP
.SH OPTIONS
.IP \-cpp tfile.cpp
target C++ file.  If this option is omitted, SNsfile1.cpp is used.
The object file created by compiling the C++ file is dynamically linked
to SN when the SN file is loaded.  It provides calls visible from C 
(extern C) to the public methods defined in the source files
(sfile1.h, sfile2.h...).
.IP \-h tfile.h
target header file.  If this option is omitted, SNsfile1.cpp is used.
The header file is included in both the C++ file and the C file 
generated by compiling the SN file.  It serves as an interface between
C and C++.
.IP \-sn tfile.sn
target SN file.  If this option is omitted, sfile1.sn is used.
The SN files, contains all the LISP interface to the C++ methods,
and their on-line documentation.
.SH TYPES
The following C++ argument and return types are recognized by 
.B cpp2sn
and will be interfaced in a predefined manner with SN.  Note that
argument are passed by either value or reference.  If they are
passed by reference, a special case is made for SmartPointer
(for more information on SmartPointers, look in
/home/patrice/Cybrary/libDejaVu/SmartPointer.h.).  When SmartPointer
are used, memory management is done automatically, otherwise
the user has to worry about proper memory management.  All classes
are stored with a slot gptr in LISP, which means that they should not be
passed by value (if they are, the LISP interface will pass pointers
anyway).  The following list summarise the C++ types and how
they are translated into LISP:
.PP
.B all integer types:
Can appear in C++ arguments or be returned.  One of the following
LISP type will be used: int, short, byte, ubyte.
.PP
.B floats and doubles:
Can appear in C++ arguments or be returned.  One of the following
LISP type will be used: float or double
.PP
.B SmartPointers:
Can appear in C++ arguments or be returned.  The corresponding class
must have been interfaced with cpp2sn (either in the same file
or in another file, which will need to be loaded).  The SmartPointer
is the best choice for interfacing objects, because the Garbage
collecting is done automatically.
.PP
.B pointers to all integer or float types:
For example, int * or float **.  Can appear in C++ arguments or 
be returned.  An IDX1 is used in all cases (even **) and one of
the following LISP type will be used: int, short, byte, ubyte,
float, double.
.PP
.B pointers to any structures (but not SmartPointers):
For examle, Bitmap *.  Can appear in C++ arguments or 
be returned.  A gptr will be used.
.PP
.B pointers to pointers to any structures (but not SmartPointers):
For examle, Bitmap **.  Can appear in C++ arguments or 
be returned.  An IDX1 of gptr will be used.
.PP
.B a class passed by value:
For examle, GRect r.  Can appear in C++ arguments or 
be returned.  A gptr will be used.
.PP
.B a type passed by reference:
For examle, GRect &r.  Can appear in C++ arguments or 
be returned.  A gptr will be used.
.SH DIRECTIVES
There are two directives which can be used to give extra information
about the class.
.PP
If the directive
.B cpp2sn:object
appears in a comment along with a super class, 
.B cpp2sn
will define the LISP class as an object.  This is useful if the 
superclass is not treated with cpp2sn.  Example:
.PP
class MemoryByteStream : ByteStream /* cpp2sn:object */ {
.P
 ...
.P
}
.PP
If the directive
.B cpp2sn:GPEnabled
appear in a comment along with a super class, it tells
.B cpp2sn
that the superclass is a GPEnabled.  Example:
.PP
class MyBitmap : Bitmap /* cpp2sn:GPEnabled */ {
.P
 ...
.P
}
.PP
There are two other important directives: 
.B //cpp2sn perl
and 
.B //cpp2sn pre perl
which must be comments at the beginning of a line and which instruct
.B cpp2sn
to execute some code (on the same line).
.  This is illustrated by the next 2 examples:
.PP
//cpp2sn perl $snfile =~ s/(\\(g\\+\\+-load[^\\n]*\\n)/(mload "clustering")\\n$1/;
.P
//cpp2sn pre perl $hbuffer =~ s/FUNCTION_BLOCK_AUTOMATIC_CAST\\(.*?\\);\\n//;
.PP
The first line instruct
.B cpp2sn
to execute a line of perl, which will insert cause the insertion of
a line (a mload command is inserted before a g++-load command) in
the SN file, while the second line is a preprocessing command executed
on the source file.  It is good to know that $snfile, $cppfile, $hfile
and $hbuffer are respectively the generated SN file, the generated C++
file, the generated h file, and the source file.  The 
.B //cpp2sn perl ...
command is executed after the buffer have been generated, while the 
.B //cpp2sn pre perl ...
command is executed before.
.SH BUGS
Probably plenty. Report any you find to patrice@research.att.com.
.SH AUTHOR
The program was written by Patrice Simard at AT&T Laboratories.
.SH FILES
.nf
/home/patrice/Cybrary/libDejaVu/libDejaVu.a      DejaVu library.
/home/snwiz/sn3.1/util/djvu/security_bypass.cpp  To bypass SmartPointers.
/usr/common/gcc-irix63.2.8a/lib/gcc-lib/mips-sgi-irix5.3/2.8.0/libgcc.a
.fi
