#! /usr/common/bin/perl

$libdejavu_dir = "/home/patrice/Cybrary/libDejaVu";
$security_bypass_h = "/home/snwiz/sn3.1/tools/security_bypass.h";
$security_bypass_cpp = "/home/snwiz/sn3.1/tools/security_bypass.cpp";
$libstdcpp = "/usr/common/gcc-irix63.2.8a/lib/libstdc++.a";
$libgcc = "/usr/common/gcc-irix63.2.8a/lib/gcc-lib/mips-sgi-irix5.3/2.8.0/libgcc.a";
$warning = "/*\n" .
    " * WARNING: \n" .
    " * This code has been automatically generated by cpp2sn.\n" .
    " * Exercise care while modifying it.\n" .
    " */\n";

%operator_conversion = ( 'new', 'new', 'delete', 'delete', '+', 'plus', '-',
'minus', '*', 'times', '/', 'div', '%', 'percent', '^', 'bit_xor', '&',
'bit_and', '|', 'bit_or', '~', 'not', '!', 'neg', '=', 'equal', '<', 'lower',
'>', 'greater', '+=', 'plus_eq', '-=', 'minus_eq', '*=', 'times_eq', '/=',
'div_eq', '%=', 'percent_eq', '^=', 'xor_eq', '&=', 'and_eq', '|=', 'or_eq',
'!=', 'neg_eq', '==', 'equal_eq', '<=', 'lower_eq', '>=', 'greater_eq', '<<',
'shift_left', '>>', 'shift_right', '<<=', 'shift_left_eq', '>>=',
'shift_right_eq', '&&', 'and', '||', 'or', '++', 'incr', '--', 'decr', ',',
'comma', '->*', 'no_idea', '->', 'deref', '()', 'cast', '[]', 'index');

##############################################################################
#
# Adds parenthese and brace level numbering followed by \~ after all 
# parentheses and braces.  Also adds the current paren level numbering
# after each comma (again followed by \~) (commas that are not within any
# paren are left unchanged).  This later allows to match the correct 
# closing in regexps.  First level is 0.
#
##############################################################################
sub addGroupLevels ($)
{
  my $result = "";
  my $parlevel = 0;
  my $bracelevel = 0;
  my $star_comment = 0;
  my $slash_comment = 0;

  foreach $token (split(/([{(,)}]|\/\*|\/\/|\*\/|\n)/,$_[0]))
    {
      $parlevel<=9 or die "More than nine levels of parentheses !!";
      $bracelevel<=9 or die "More than nine levels of braces !!";

      if($token eq "/*") {
          if(!$slash_comment) {
              $star_comment = 1;
          }
      } elsif($token eq "*/") {
          if($star_comment) {
              $star_comment = 0;
          }
      } elsif($token eq "//") {
          if(!$star_comment) {
              $slash_comment = 1;
          }
      } elsif($token eq "\n") {
          if($slash_comment) {
              $slash_comment = 0;
          }
      }

      if($star_comment || $slash_comment) {
          $result .= $token;
      } elsif($token eq ",")
        {
          if($parlevel > 0)
            { $result .= ",".(${parlevel}-1)."\~"; }
          else 
            { $result .= ","; }
        }
      elsif($token eq "(")
        { 
          $result .= "(".$parlevel."\~"; 
          $parlevel++;
        }
      elsif($token eq ")")
        { 
          $parlevel--;
          $result .= ")".$parlevel."\~"; 
        }
      elsif($token eq "{")
        { 
          $result .= "{".$bracelevel."\~"; 
          $bracelevel++;
        }
      elsif($token eq "}")
        { 
          $bracelevel--;
          $result .= "}".$bracelevel."\~"; 
        }
      else
        { $result .= $token; }
    }
  $_[0] = $result;
}

##############################################################################
#
# Find
# parentheses and braces.  Also adds the current paren level numbering
#
##############################################################################
sub Findpublic ($)
{
  my $result = "";
  my $public = 0;
  my $token;

  foreach $token (split(/(public\:|protected\:|private\:)/,$_[0]))
    {
      if($token eq "public\:")
        {
            $public = 1;
        }
      elsif($token eq "private\:")
        { 
            $public = 0;
        }
      elsif($token eq "protected\:")
        { 
            $public = 0;
        }
      else
        { 
            if($public eq 1) {
                $result .= $token; 
            }
        }
  }
  return $result;
}

##############################################################################
#
# parse_type($type);
#
# Parse Type (using regex grammar)
# Side effect: $arg_type, $arg_special, $arg_pointer, $arg_name, $arg_brack,
#      $arg_exp.
#
##############################################################################
sub parse_argument($)
{
    my $simple_type_name =
        "(?:char|short|int|long|signed|unsigned|float|double|void)";
    my $storage_class_specifier = "(?:auto|register|static|extern)";
    my $type_specifier = "(?:$simple_type_name|const|volatile)(?!\\w)";
    my $type_specifier_list = "(?:$type_specifier(?:\\s+$type_specifier)*)";
    my $fct_specifier = "(?:inline|virtual)(?!\\w)";
    my $decl_specifier = 
        "(?:$storage_class_specifier|$type_specifier|
         $fct_specifier|friend|typedef)";
    my $decl_specifiers = "(?:(?:$decl_specifier\\s+)*$decl_specifier)";
    my $decl_specifiers_c = "($decl_specifiers|(?:(?:$decl_specifiers\\s+)?
        ((?:\\w+)|(?:GP\\s*<[^>]+>))))";
    
    my $operator = "(?:new|delete|[+-/%&|~!=<>]|\\*|\\^|[+-/%\&\|<>=!]=|
        \\*=|\\^=|<<|>>|>>=|<<=|&&|\\|\\||\\+\\+|--|,|->\\*|->|
        \\(\\)|\\[\\])";
    my $name = "(?:\\w+|(?:operator\\s*$operator))";
    my $dname = "(?:$name|(?:~\\s*$name))";
    my $cv_qualifier = "(?:const|volatile)";
    my $cv_qualifier_list = "(?:$cv_qualifier(?:\\s+$cv_qualifier)*)";
    my $ptr_operator = "(?:[*&](?:\\s*$cv_qualifier_list)?)";
    my $pre_declarator = 
        "((?:\\(|$ptr_operator)(?:\\s*(?:\\(|$ptr_operator))*)";
    my $post_declarator = "(?:\\)(?:\\s*\\))*)";
    # declarator has 3 parenthesis: $pre_declarator, ($dname), brackets
    my $declarator = "(?:(?:(?:$pre_declarator\\s*)?|\\s)
        ($dname)(?:\\s*$post_declarator)?(?:\\s*(\\[.*\\]))?)";
    # abstract declarator has 2 parenthesis: $pre_declarator, brackets
    my $abstract_declarator = "(?:(?:(?:$pre_declarator\\s*)?|\\s)
        (?:\\s*$post_declarator)?(?:\\s*(\\[.*\\]))?)";

    my $expr = "(.+)";
    # type is compulsory, but name isn't
    my $argument_declaration =
        "\\s*(?:$decl_specifiers_c\\s*(?:$declarator|($abstract_declarator))
        (?:\\s*=$expr)?\\s*)";
    # type is not compulsory, but function name is
    my $function_type_declaration =
        "\\s*(?:$decl_specifiers_c\\s*$declarator(?:\\s*=$expr)?\\s*)";

    my $decl_no_comments = remove_comments($_[0]);
    $arg_comments = extract_comments($_[0]);

    if($decl_no_comments =~ m[^$argument_declaration$]x) {
        $arg_type = $1;
        $arg_special = $2; # class name
        $arg_pointer = $3;
        $arg_name = $4;
        $arg_brack = $5;
        # If abstract declarator is used:
        if("$6" ne "") {
            $arg_pointer = $7;
            $arg_name = "";
            $arg_brack = $8;
        }
        $arg_exp = $9;
        return 1;
    } else {
        return 0;
    }
}

sub parse_function_type($)
{
    my $simple_type_name =
        "(?:char|short|int|long|signed|unsigned|float|double|void)";
    my $storage_class_specifier = "(?:auto|register|static|extern)";
    my $type_specifier = "(?:$simple_type_name|const|volatile)(?!\\w)";
    my $type_specifier_list = "(?:$type_specifier(?:\\s+$type_specifier)*)";
    my $fct_specifier = "(?:inline|virtual)(?!\\w)";
    my $decl_specifier = 
        "(?:$storage_class_specifier|$type_specifier|
         $fct_specifier|friend|typedef)";
    my $decl_specifiers = "(?:(?:$decl_specifier\\s+)*$decl_specifier)";
    my $decl_specifiers_c = "($decl_specifiers|(?:(?:$decl_specifiers\\s+)?
        ((?:\\w+)|(?:GP\\s*<[^>]+>))))";
    
    my $operator = "(?:new|delete|[+-/%&|~!=<>]|\\*|\\^|[+-/%\&\|<>=!]=|
        \\*=|\\^=|<<|>>|>>=|<<=|&&|\\|\\||\\+\\+|--|,|->\\*|->|
        \\(\\)|\\[\\])";
    my $name = "(?:\\w+|(?:operator\\s*$operator))";
    my $dname = "(?:$name|(?:~\\s*$name))";
    my $cv_qualifier = "(?:const|volatile)";
    my $cv_qualifier_list = "(?:$cv_qualifier(?:\\s+$cv_qualifier)*)";
    my $ptr_operator = "(?:[*&](?:\\s*$cv_qualifier_list)?)";
    my $pre_declarator = 
        "((?:\\(|$ptr_operator)(?:\\s*(?:\\(|$ptr_operator))*)";
    my $post_declarator = "(?:\\)(?:\\s*\\))*)";
    my $declarator = "(?:(?:(?:$pre_declarator\\s*)?|\\s)
        ($dname)(?:\\s*$post_declarator)?(?:\\s*(\\[.*\\]))?)";
    my $abstract_declarator = "(?:(?:(?:$pre_declarator\\s*)?|\\s)
        (?:\\s*$post_declarator)?(?:\\s*(\\[.*\\]))?)";

    my $expr = "(.+)";

    # type is compulsory, but name isn't
    my $argument_declaration =
        "\\s*(?:$decl_specifiers_c\\s*(?:$declarator|$abstract_declarator)
        (?:\\s*=$expr)?\\s*)";
    # type is not compulsory, but function name is
    my $function_type_declaration =
        "\\s*(?:(?:$decl_specifiers_c)?\\s*$declarator(?:\\s*=$expr)?\\s*)";

    if($_[0] =~ m[^$function_type_declaration$]x) {
        $arg_type = $1;
        $arg_special = $2; # class name
        $arg_pointer = $3;
        $arg_name = $4;
        $arg_brack = $5;
        $arg_exp = $6;
        return 1;
    } else {
        return 0;
    }
}

##############################################################################
#
# parse_argument($arg_list);
#
# Parse all the arguments in $arg_list.
# Side effect: $cppargs1, $cppargs2
# Return true if parsed succeeded.
#
##############################################################################
sub parse_arguments($)
{
    my $args = $_[0];
    my $type, $expression, $token;
    my $success_flag = 1;
    my $seed = 1;

    if($args =~ /^\s*void\s*$/) {
        return $success_flag;
    }

    foreach $token (split(/,0~/,$_[0])) {
        if(parse_argument($token)) {
            my $arg1, $arg2;
            my $arg = find_unique_name("arg$seed");

            if(!$arg_name) {
                $arg_name = "$arg";
            }

            $sn_arg_name = $arg_name;
            if($arg_name eq "p") {
                # The lisp name of the argument would interfere with
                # the name of the slot which holds C object
                $sn_arg_name = find_unique_name("p1");
            } 

            $sn_arg_com1 .= " <$arg_name>";
            $sn_arg_func .= " $sn_arg_name";
            $sn_arg_com2 .= ";; <$arg_name> \t: ";
            
            if($arg_special =~ m[GP\s*<([^>]+)>]sgx) {
                # SmartPointers
                $cppbody .= "        GP <$1> $arg = $arg_name;\n";
                $arg1 = "$1 *$arg_name";
                $arg2 = "$arg";
                $sn_arg_type .= "  ((-obj- ($1)) $sn_arg_name)\n";
                $sn_arg_com2 .= "((-obj- ($1))";
                $sn_arg_call .= ", \$(scope $sn_arg_name p)";
            } elsif($arg_pointer =~ m[\*]) {
                # pointer to simple types
                if($arg_type =~ /(long|int)/) {
                    $sn_arg_type .= "  ((-idx1- (-int-)) $sn_arg_name)\n";
                    $sn_arg_com2 .= "(-idx1- (-int-))";
                    $sn_arg_call .= ", IDX_PTR(\$$sn_arg_name, int)";
                } elsif($arg_type =~ /short/) {
                    $sn_arg_type .= "  ((-idx1- (-short-)) $sn_arg_name)\n";
                    $sn_arg_com2 .= "(-idx1- (-short-))";
                    $sn_arg_call .= ", IDX_PTR(\$$sn_arg_name, short)";
                } elsif($arg_type =~ /char/ && $arg_type =~ /unsigned/) {
                    $sn_arg_type .= "  ((-idx1- (-ubyte-)) $sn_arg_name)\n";
                    $sn_arg_com2 .= "(-idx1- (-ubyte-))";
                    $sn_arg_call .= ", IDX_PTR(\$$sn_arg_name, unsigned char)";
                } elsif($arg_type =~ /char/) {
                    $sn_arg_type .= "  ((-idx1- (-byte-)) $sn_arg_name)\n";
                    $sn_arg_com2 .= "(-idx1- (-byte-))";
                    $sn_arg_call .= ", IDX_PTR(\$$sn_arg_name, char)";
                } elsif($arg_type =~ /float/) {
                    $sn_arg_type .= "  ((-idx1- (-float-)) $sn_arg_name)\n";
                    $sn_arg_com2 .= "((-idx1- (-float-))";
                    $sn_arg_call .= ", IDX_PTR(\$$sn_arg_name, float)";
                } elsif($arg_type =~ /double/) {
                    $sn_arg_type .= "  ((-idx1- (-double-)) $sn_arg_name)\n";
                    $sn_arg_com2 .= "(-idx1- (-double-))";
                    $sn_arg_call .= ", IDX_PTR(\$$sn_arg_name, double)";
                } elsif($arg_pointer =~ /\*\s*\*/) {
                    # double array of non simple type (probably a gptr).
                    $sn_arg_type .= "  ((-idx1- (-gptr-)) $sn_arg_name)\n";
                    $sn_arg_com2 .= "(-idx1- (-gptr-))";
                    $sn_arg_call .= ", IDX_PTR(\$$sn_arg_name, $arg_type *)";
                } else {
                    # A pointer to a class?
                    $sn_arg_type .= "  ((-gptr-) $sn_arg_name)\n";
                    $sn_arg_com2 .= "(-gptr-)";
                    $sn_arg_call .= ", \$$sn_arg_name";
                }
                $arg1 = "$arg_type $arg_pointer$arg_name";
                $arg2 = "$arg_name";

            } else {
                # A non pointer argument: SN
                if($arg_pointer =~ /&/) {
                    if($arg_special ne "") {
                        # It's a known class
                        $sn_arg_type .= "  ((-obj- ($arg_special))".
                            " $sn_arg_name)\n";
                        $sn_arg_com2 .= "(-obj- ($arg_special))";
                        $sn_arg_call .= ", \$(scope $sn_arg_name p)";
                    } else {
                        $sn_arg_type .= "  ((-gptr-) $sn_arg_name)\n";
                        $sn_arg_com2 .= "(-gptr-)";
                        $sn_arg_call .= ", \$$sn_arg_name";
                    }
                } elsif($arg_type =~ /(long|int|short|char)/) {
                    $sn_arg_type .= "  ((-int-) $sn_arg_name)\n";
                    $sn_arg_com2 .= "(-int-)";
                    $sn_arg_call .= ", \$$sn_arg_name";
                } elsif($arg_type =~ /float/) {
                    $sn_arg_type .= "  ((-float-) $sn_arg_name)\n";
                    $sn_arg_com2 .= "(-float-)";
                    $sn_arg_call .= ", \$$sn_arg_name";
                } elsif($arg_type =~ /double/) {
                    $sn_arg_type .= "  ((-double-) $sn_arg_name)\n";
                    $sn_arg_com2 .= "(-double-)";
                    $sn_arg_call .= ", \$$sn_arg_name";
                } else {
                    if($arg_special ne "") {
                        # It's a known class
                        $sn_arg_type .= "  ((-obj- ($arg_special))".
                            " $sn_arg_name)\n";
                        $sn_arg_com2 .= "(-obj- ($arg_special))";
                        $sn_arg_call .= ", \$(scope $sn_arg_name p)";
                    } else {
                        $sn_arg_type .= "  ((-gptr-) $sn_arg_name)\n";
                        $sn_arg_com2 .= "(-gptr-)";
                        $sn_arg_call .= ", \$$sn_arg_name";
                    }
                }

                # A non pointer argument: C++
                if($arg_pointer =~ /&/) {
                    # Value Argument passed by address
                    my $temp_arg_pointer = $arg_pointer;
                    $temp_arg_pointer =~ s/&//;
                    $arg1 = "$arg_type $temp_arg_pointer *$arg_name";
                    $arg2 = "*$arg_name";
                } elsif($arg_special ne "" && $arg_pointer eq "") {
                    # This case covers true value argument ex: (truc a)
                    $arg1 = "$arg_type $temp_arg_pointer *$arg_name";
                    $arg2 = "*$arg_name";
                } else {
                    # If every thing else fail:
                    $arg1 = "$arg_type $arg_name";
                    $arg2 = "$arg_name";
                }
            }
            $sn_arg_com2 .= " (from '$arg_type$arg_pointer' in C++))\n";

            $cppargs1 .= ", $arg1";
            $cppargs2 .= ", $arg2";
            $seed++;

        } else {
            $success_flag = 0;
        }
    }
    $cppargs2 = substr($cppargs2, 2);

    return $success_flag
}

##############################################################################
#
# fine_unique_name($name, $possible_name_string)
# Return $name, if $name is not in string $possible_name_string.  Otherwise
# tries $name1, $name2,... until it finds one not in $possible_string.
#
##############################################################################
sub find_unique_name ($) {
    my $seed = 1;
    my $this = $_[0];

    while(($forbidden_names{$this}) == 1) {
        $this = $_[0] . $seed++;
    }

    return $this;
}

##############################################################################
#
# fine_forbidden($arg_list)
# Return an associative array with a non empty entry for all the forbidden
# names for arguments (to avoid duplicates);
#
##############################################################################
sub find_forbidden ($) {
    my %forbidden, $token;

    foreach $token (split(/,0~|\(0~|\)0~/,$_[0])) {
        parse_argument($token);
        if($arg_name ne "") {
            $forbidden{$arg_name} = 1;
        }
        if($arg_special ne "") {
            $forbidden{$arg_special} = 1;
        }
    }
    return %forbidden;
}

##############################################################################
#
# dup_string($n, $str);
# return $n concatenated copies of $str.
#
##############################################################################
sub dup_string($$) {
    my $s = "", $i;
    for($i=1; $i< $_[0]; $i++) {
        $s .= $_[1];
    }
    return $s;
}

##############################################################################
#
#  clean_comments($comments)
#  remove the /*, */, and //, associated with comments.
#  
##############################################################################
sub clean_comments ($)
{
    my $s = $_[0]."\n";
    $s =~ s/\/\*((?:[^*]|\*(?!\/))*)\*\//$1/g;
    $s =~ s/\/\/([^\n]*(?=\n))/$1/g;
    chop($s);
    return $s;
}

##############################################################################
#
#  remove_comments($buffer)
#  remove all the comments from $buffer
#  
##############################################################################
sub remove_comments($)
{
    my $s = $_[0]."\n";
    $s =~ s/\/\*((?:[^*]|\*(?!\/))*)\*\///g;
    $s =~ s/\/\/([^\n]*(?=\n))//g;
    chop($s);
    return $s;
}

##############################################################################
#
#  extract_comments($buffer)
#  return only the comments
#  
##############################################################################
sub extract_comments($)
{
    my $s = $_[0]."\n";
    my $res = "";
    while($s =~ m[((?:\s*(?:\/\*(?:[^*]|\*(?!\/))*\*\/|
                          \/\/[^\n]*(?=\n)))+)]sgx) {
        $res .= $1;
    }
    chop($res);
    return $res;
}

##############################################################################
#
#  add_to_body_from_return($class_name, $method_name, $return_type, $args);
#  
#  Side effect: set $cppreturn, append to $cppbody, modify $cppargs1.
#
##############################################################################
sub add_to_body_from_return ($$$$)
{
    my $class_name = $_[0];
    my $method_name = $_[1];
    my $func_name = $class_name . "_" . $method_name;
    my $return_type = $_[2];
    my $arguments = $_[3];
    my $s7 = "       ";
    my $this = find_unique_name("p");

    $cppargs1 = $class_name . " *$this" . $cppargs1;
    if(parse_function_type(remove_comments("$return_type $true_method_name"))) {
        $sn_arg_com2 .= ";; return \t: ";
        if($arg_special =~ m[GP\s*<([^>]+)>]sgx) {
            # return a GP (smart pointer)
            my $gp = find_unique_name("gp");
            $cppreturn = $1 . " *";
            $cppbody .= "$s7 GP <$1> $gp = $this->$true_method_name$arguments;\n";
            $cppbody .= "$s7 gpenabled_ref($gp);\n";
            $cppbody .= "$s7 return $gp;\n";
            $sn_arg_com2 .= "((-obj- ($1))";
            $sn_return = "  (new $1 (gptr #{ $func_name($sn_arg_call) #}))\n";
        } elsif ($arg_type =~ m[void] && ($arg_pointer eq "")) {
            # void function: no return
            $cppreturn = "void ";
            $cppbody .= "$s7 $this->$true_method_name$arguments;\n";
            $sn_arg_com2 .= "()";
            $sn_return = "  #{ $func_name($sn_arg_call); #}\n  ()";
        } else {
            # return a simple type
            $arg_type =~ s/(virtual|inline)//g; # remove virtual and inline
            if($arg_pointer =~ /&/) { # if return is passed by reference ...
                $cppreturn = "$arg_type *";
                $cppbody .= "$s7 return &($this->$true_method_name".
                    "$arguments);\n";
            } elsif($arg_special ne "" && $arg_pointer eq "") {
                $cppreturn = "$arg_type *";
                $cppbody .= "$s7 return &($this->$true_method_name".
                    "$arguments);\n";
            } else {
                $cppreturn = "$arg_type $arg_pointer";
                $cppbody .= "$s7 return $this->$true_method_name$arguments;\n";
            }

            # Generate interface for SN file.
            if($arg_pointer =~ /\*/) {
                my $sn_matrix_type = "";
                my $ret = find_unique_name("ret");
                if($arg_type =~ /(long|int)/) {
                    $sn_matrix_type = "int";
                } elsif($arg_type =~ /short/) {
                    $sn_matrix_type = "short";
                } elsif($arg_type =~ /char/ && $arg_type =~ /unsigned/) {
                    $sn_matrix_type = "ubyte";
                } elsif($arg_type =~ /char/) {
                    $sn_matrix_type = "byte";
                } elsif($arg_type =~ /float/) {
                    $sn_matrix_type = "float";
                } elsif($arg_type =~ /double/) {
                    $sn_matrix_type = "double";
                } elsif($arg_pointer =~ /\*\s*\*/) {
                    # double pointer
                    $sn_matrix_type = "gptr";
                }
                if($sn_matrix_type ne "") {
                    $sn_arg_com2 .= "(-idx1- (-$sn_matrix_type-))";
                    $sn_return = "  (let (($ret ($sn_matrix_type-matrix-nc ".
                        "0)))\n";
                    $sn_return .= "    #{\n";
                    $sn_return .= "    if(\$$ret->srg->data != 0)\n";
                    $sn_return .= "        free(\$$ret->srg->data);\n";
                    $sn_return .= "    \$$ret->srg->data = ".
                        "(void*)($func_name($sn_arg_call));\n";
                    $sn_return .= "    \$$ret->srg->flags &= ~STS_MALLOC;\n";
                    $sn_return .= "    #}\n";
                    $sn_return .= "    $ret)\n";
                } else {
                    if($arg_special ne "") {
                        # Type may be something like: GRect *
                        # Warning: No free when lisp object is destroyed
                        $sn_arg_com2 .= "(-obj- ($arg_special))";
                        $sn_return = "  (let ((temp (new $arg_special (gptr ".
                            "#{ $func_name($sn_arg_call) #}))))\n". 
                                "    (setq :temp:destructed t)\n".
                                    "    temp)\n";
                    } else {
                        $sn_arg_com2 .= "(-gptr-)";
                        $sn_return = "  (gptr #{ $func_name($sn_arg_call)".
                            "#})\n";
                    }
                }
            } elsif($arg_type =~ /(long|int|short|char)/) {
                $sn_arg_com2 .= "(-int-)";
                $sn_return = "  (int #{ $func_name($sn_arg_call) #})\n";
            } elsif($arg_type =~ /float/) {
                $sn_arg_com2 .= "(-float-)";
                $sn_return = "  (flt #{ $func_name($sn_arg_call) #})\n";
            } elsif($arg_type =~ /double/) {
                $sn_arg_com2 .= "(-double-)";
                $sn_return = "  (double #{ $func_name($sn_arg_call) #})\n";
            } else {
                $sn_arg_com2 .= "(-gptr-)";
                $sn_return = "  (gptr #{ $func_name($sn_arg_call) #})\n";
            }

        }
        $sn_arg_com2 .= " (from '$arg_type$arg_pointer' in C++))\n";
        return 1;
    } else {
        my $operator = "(?:new|delete|[+-/%&|~!=<>]|\\*|\\^|[+-/%\&\|<>=!]=|
            \\*=|\\^=|<<|>>|>>=|<<=|&&|\\|\\||\\+\\+|--|,|->\\*|->|
                \\(\\)|\\[\\])";

        if($return_type =~ /(operator\s*$operator)/) {
            print "**** Error: Class: $class_name, Method: $method_name\n";
            print "     Could not process operator: $1\n";
            print "$return_type\n";
            return 0;
        } else {
            print "**** Error: Class: $class_name, Method: $method_name\n";
            print "     Could not parse return type: $return_type ".
                "$true_method_name\n";
            return 0;
        }
    }
}

##############################################################################
#
#  generate_code($return, $func_name, $args, $body$)
#  
#  Side effect: append to $cppfile and to $hfile.
#
##############################################################################
sub generate_method_code($$$$)
{
    my $ret = $_[0];
    my $fname = $_[1];
    my $args = $_[2];
    my $body = $_[3];
    my $s7 = "       ";

    $hfile .= "$ret$fname($args);\n";
    $cppfile .= "$ret$fname($args) {\n";
    $cppfile .= "    TRY {\n";
    $cppfile .= "$body";
    $cppfile .= "    }\n";
    $cppfile .= "    CATCH(ex) {\n";
    $cppfile .= "$s7 ex.perror(\"$fname\");\n";
    $cppfile .= "$s7 run_time_error(\"Could not perform $fname\");\n";
    $cppfile .= "    }\n";
    $cppfile .= "    ENDCATCH;\n";
    $cppfile .= "}\n\n";
}

##############################################################################
#
#  generate_h_prelude($orig_file, $filename_h)
#  Return prelude to .h file
#  
##############################################################################
sub generate_h_prelude($$)
{
    my $includes = $_[0];
    my $filename_h = $_[1];
    my $hf = "";

    $hf .= "\n";
    $hf .= "#ifdef __cplusplus /* if this is compiled in C++ */\n";
    $hf .= "\n";
    $hf .= "#define USE_EXCEPTION_EMULATION\n";
    $hf .= "#include \"GSmartPointer.h\"\n";
    $hf .= $includes;
    $hf .= "#include \"$security_bypass_h\"\n";
    $hf .= "extern \"C\" void run_time_error(char *);\n";
    $hf .= "\n";
    $hf .= "#else\n";
    $hf .= "#endif /* __cplusplus */\n";
    $hf .= "\n";
    $hf .= "#ifdef __cplusplus /* If the file is included in C++ code */\n";
    $hf .= "extern \"C\" {\n";
    $hf .= "#else              /* If the file is included in C code */\n";
    $hf .= "/* Classes are not defined.  Use through (struct) pointers only */\n";
    $hf .= "\n";

    return $hf;
}

##############################################################################
#
#  generate_sn_prelude($file);
#
#  Return prelude to SN file (ex: $file = djvu/SNDejaVuImage.cpp)
#
##############################################################################
sub generate_sn_prelude($$)
{
    my $file = $_[0];
    my $preload = $_[1];
    my $sn = ";;$warning";
    
    $sn =~ s/\n/\n\;\;/g;
    $sn .= "\n";
    $sn .= "(mload \"dh-compile\")\n";
    $sn .= "(mload \"cmacro\")\n";
    $sn .= $preload;
    $sn .= "(g++-load \"$file\" \"-I$libdejavu_dir\")\n";
    $sn .= "(g++-load \"$security_bypass_cpp\" "
        ."\"-I$libdejavu_dir\")\n";
    $sn .= "(mod-load \"" . $libdejavu_dir . "/libDejaVu.a\")\n";
    $sn .= "(mod-load \"$libstdcpp\")\n";
    $sn .= "(mod-load \"$libgcc\")\n";

    return $sn;
}

##############################################################################
#
#  add_cpp_method($comment, $class_name, $return_type, $method_name, $args,
#                 $body);
#  Generate code for a method.
#  Side effect: $cppfile
#
##############################################################################
sub add_cpp_method($$$$$$)
{
    $cppargs1 = "";
    $cppargs2 = "";
    $cppbody = "";
    $cppreturn = "";

    my $method_comment = $_[0];
    my $class_name = $_[1];
    my $return_type = $_[2];
    my $method_name = $_[3];
    my $arguments = $_[4];
    my $body = $_[5];
    my $success_flag = 1;
    my $ok_flag = 1;
    my $func_name = $class_name . "_" . $method_name;
    my $s7 = "       ";
    local ($sn_arg_com1 = "", $sn_arg_com2 = "", $sn_arg_func = "",
    $sn_arg_type = "", $sn_return = "", $sn_arg_call = "\$p");

    $arguments =~ s/\(0\~(.*?)\)0\~/$1/sgx;
    if(!($ok_flag &= parse_arguments($arguments))) {
        print "**** Error: Class: $class_name, Method: $method_name\n";
        $arguments =~ s/([,)(])[0-9]~/$1/g;
        print "     Could not parse arguments: ($arguments)\n";
    }

    if($constructor_flag) {
        # Processing constructor
        if($ok_flag &= !($return_type =~ m/~/)) {
            my $gp = find_unique_name("p");
            $cppreturn = $class_name . " *";
            $cppargs1 = substr($cppargs1, 2);
            if($super_class_name =~ /GPEnabled/) {
                $cppbody .= "$s7 GP <$class_name> $gp = ".
                    "new $class_name($cppargs2);\n";
                $cppbody .= "$s7 gpenabled_ref($gp);\n";
            } else {
                $cppbody .= "$s7 $class_name *$gp = ".
                    "new $class_name($cppargs2);\n";
            }                
            $cppbody .= "$s7 return $gp;\n";
            generate_method_code($cppreturn, $func_name,
                                 $cppargs1, $cppbody);
            $sn_arg_call = substr($sn_arg_call, 4); # cancel $p
            $sn_return = "  (new $class_name (gptr ".
                "#{ $func_name($sn_arg_call) #}))\n";
        }
    } else {
        # Processing a standard method
        $return_type =~ s/virtual//;
        if($ok_flag &= !($return_type =~ m/friend/)) {
            add_to_body_from_return($class_name, $method_name, 
                                    $return_type, "(".$cppargs2.")");
            if($body) {
                $cppbody = $body;
            }
            generate_method_code($cppreturn, $func_name,
                                 $cppargs1, $cppbody);
        }
    }

    if($ok_flag) {
        if($method_comment) {
            $method_comment = ";;" . $method_comment;
            $method_comment =~ s/\n/\n\;\;/g;
            $method_comment .= "\n";
        }
        $sn_arg_func = substr($sn_arg_func, 1);
        if($constructor_flag) {
            $sn_comment = "($method_name-$sn_arg_com1)\n";
            $sn_class_comment .= ";;.SEE $sn_comment";
            $sn_comment = ";;" . dup_string(77,"-") . "\n#? " . $sn_comment;
            $sn_comment .= ";;.VP\n$sn_arg_com2;;.PP\n$method_comment";
            $sn_comment .= ";;.SEE $class_name.\n;;\n";
            $sn_body .= $sn_comment;
            $sn_arg_com1 = substr($sn_arg_com1, 1);
            $sn_body .= "(de $method_name- ($sn_arg_func)\n";
            $sn_body .= "$sn_arg_type$sn_include$sn_return)\n";
            $sn_constructors .= " $method_name-";
        } else {
            $snepilog .= " $method_name";
            $sn_comment = "(==> <$class_name> $method_name$sn_arg_com1)\n";
            $sn_class_comment .= ";;.SEE $sn_comment";
            $sn_comment = ";;" . dup_string(77,"-") . "\n#? " . $sn_comment;
            $sn_comment .= ";;.VP\n$sn_arg_com2;;.PP\n$method_comment";
            $sn_comment .= ";;.SEE $class_name.\n;;\n";
            $sn_body .= $sn_comment;
            $sn_arg_com1 = substr($sn_arg_com1, 1);
            $sn_body .= "(defmethod $class_name $method_name ($sn_arg_func)\n";
            $sn_body .= "$sn_arg_type$sn_include$sn_return)\n";
        }
        $sn_body .= "\n";
    }
    return $ok_flag;
}

##############################################################################
#
# parse_header($buffer);
# Side effects: $cppfile, $hfile, $snfile.
#
##############################################################################
sub parse_header ($)
{
    my $comment_regex =
        '(?:\s*(?:\/\*(?:[^*]|\*(?!\/))*\*\/|\/\/[^\n]*(?=\n)))+';
    my $hf = "";
    my $access_specifier = "(?:private|protected|public|virtual)";
    my $operator = "(?:new|delete|[+-/%\&\|<>=!]=|
        \\*=|\\^=|<<|>>|>>=|<<=|&&|\\|\\||\\+\\+|--|,|->\\*|->|
        \\(\\)|\\[\\]|[+-/%&|~!=<>]|\\*|\\^)";
    my $name = "(?:\\w+|(?:operator\\s*$operator))";
    my $dname = "(?:$name|(?:~\\s*$name))";

    while($_[0] =~ m[\s*($comment_regex)?\s*   # Extract comments
                     (?:class\s+(\w+)           # Extract class
                      (?:\s* \: \s*(?:$access_specifier)?
                       (?:\s+$access_specifier)?\s+([^{]+))?\s*
                      \{0\~(.*?)\}0\~)]sgx) {

        #printf ("%d %d %d %d\n", length($_[0]), length($`), length($&), length($'));

        my $class_comment = $1;
        my $class_name = $2;
        local $super_class_name = $3;
        my $methods = $4;
        my $sn_class = "";
        my $constructor_seen = 0;
        my $equal_seen = 0;
        my $sn_methods = "";
        my %method_list = ();
        local $sn_class_comment = "";
        local $sn_body = "";
        local $sn_constructors = "   ";
        my $destructor_flag = 0;

        $snepilog .= "\n    ($class_name";
        $sn_class_comment = ";;" . clean_comments($class_comment);
        $sn_class_comment =~ s/\n/\n;;/g;
        $sn_class_comment = ";;" . dup_string(77,"-") . "\n#? " .
            $class_name . ".\n" . $sn_class_comment . "\n;;\n";

        if($super_class_name =~ /GPEnabled/) {
            if(extract_comments($super_class_name) =~ /GPEnabled/) {
                # It's a comment (an indication), we want superclass
                $sn_class .= "(defclass $class_name ". 
                    remove_comments($super_class_name) . ")\n";
            } else {
                $sn_class .= "(defclass $class_name object\n";
                $sn_class .= "  ((-bool-) destructed)\n";
                $sn_class .= "  ((-gptr-) p))\n";
            }
        } elsif($super_class_name &&
                !(extract_comments($super_class_name) =~ /cpp2sn:object/)) {
            $sn_class .= "(defclass $class_name $super_class_name)\n";
        } else {
            $sn_class .= "(defclass $class_name object\n";
            $sn_class .= "  ((-bool-) destructed)\n";
            $sn_class .= "  ((-gptr-) p))\n";
        }
        $sn_class .= "(defmethod $class_name $class_name (pp)\n";
        $sn_class .= "  ((-gptr-) pp)\n";
        $sn_class .= "  (setq destructed ())\n";
        $sn_class .= "  (setq p pp))\n";
        $snepilog .= " $class_name";

        $hf .= "typedef struct tag_$class_name $class_name;\n";
        
        # remove any methods and slot that are not public.
        $methods = Findpublic($methods);
        # remove CPP directives
        $methods =~ s/#(.*?)\n//g;
        my $pure_specifier = 0;
        
        # Loops through the methods
        while($methods =~ m[\s* (?:($comment_regex)?)(?:\s|;)* # comments
                            (?:
                             (operator(?:[^(]*?)[^;]*;) |      #cast
                              (?:
                               ([^{;]*?)                       # type
                               \s*($dname)\s*                  # id
                                (?:;|(?:(\(0\~(?:.*?)\)0\~)    # args
                                      (.*?)                    # prebody
                                      (?:;|(?:\{1\~(.*?)\}1\~) # body
                                       |(\s*=\s*0\s*;))\s*)))) # pure specifier
                              ]sgx) {
                                
            my $method_comment = clean_comments($1);
            my $cast = $2;
            my $return_type = $3;
            my $method_name = $4;
            my $arguments = $5;
            my $pre_body = $6; # for example method(argument) const {}
            my $body = $7;
            $pure_specifier |= ($8 ne "");
            local $true_method_name = $method_name;

            if($class_name eq $method_name) {
                $constructor_flag = 1;
                $constructor_seen = 1;
            } else {
                $constructor_flag = 0;
            }


            if($method_name =~ /operator\s*(.*)/) {
                $method_name = "operator_".$operator_conversion{$1};
            }
            if(!$method_list{$method_name}) {
                $method_list{$method_name} = 2;
            } else {
                if($method_name =~ /operator\s*($operator)/) {
                    $method_name = operator.$method_list{$method_name}++.$1;
                } else {
                    $method_name .= $method_list{$method_name}++;
                }
            }
            if($method_name =~ /operator_equal/) {
                $equal_seen = 1;
            }

            %forbidden_names = find_forbidden($arguments);
            my $p = find_unique_name("p");

            if($arguments eq "") {
                if($cast) {
                    $cast =~ s/([,)(])[0-9]~/$1/g;
                    print "**** Error: Class: $class_name: ".
                        "(cast not supported)\n";
                    print "     $cast\n";
                } else {
                    my $s7 = "       ";
                    my $ret_get = "$s7 return $p->$true_method_name;\n";
                    my $ret_set = "$s7 $p->$true_method_name = value;\n";

                    if($return_type =~ m[GP\s*<([^>]+)>]sgx) {
                        $ret_get = "$s7 GP <$1> gp = $p->$true_method_name;\n";
                        $ret_get .= "$s7 gpenabled_ref(gp);\n";
                        $ret_get .= "$s7 return gp;\n";
                        $ret_set = "$s7 $p->$true_method_name = (GP <$1>) value;\n";
                    }
                    add_cpp_method("", $class_name, $return_type,
                                   "get_".$method_name, "(0~)0~", $ret_get);
                    add_cpp_method("", $class_name, "void",
                                   "set_".$method_name, 
                                   "(0~$return_type value)0~", $ret_set);
                }
            } else {
                if($method_name =~ /~\s*$class_name/) {
                    # if the method is a destructor
                    $destructor_flag = 1;
                    my $ret = "        delete(p);\n";
                    if($super_class_name =~ /GPEnabled/) {
                        $ret = "        gpenabled_unref(p);\n";
                    }
                    add_cpp_method($method_comment, $class_name, 
                                   "void", "delete",
                                   $arguments, $ret);
                }  elsif($method_name =~ /operator_index/) {
                    # if the method is operator[] 
                    $arguments =~ s/\(0\~(.*?)\)0\~/$1/sgx;
                    $cppargs2 = "";
                    parse_arguments($arguments);
                    my $s7 = "       ";

                    if($pre_body =~ /const/) {
                        # get for [] operator
                        $method_name =~ s/operator_index/get_index/;
                        my $ret_get = "$s7 return $p->$true_method_name".
                            "($cppargs2);\n";
                        if($return_type =~ m[GP\s*<([^>]+)>]sgx) {
                            $ret_get = "$s7 GP <$1> gp = $p->$true_method_name".
                                "($cppargs2);\n";
                            $ret_get .= "$s7 gpenabled_ref(gp);\n";
                            $ret_get .= "$s7 return gp;\n";
                        }
                        add_cpp_method("", $class_name, $return_type,
                                       $method_name, "(0~$arguments)0~",
                                       $ret_get);
                    } else {
                        # set for [] operator 
                        $method_name =~ s/operator_index/set_index/;
                        my $value = find_unique_name("value");
                        my $ret_set = "$s7 $p->$true_method_name($cppargs2) = ".
                            " $value;\n";
                        if($return_type =~ m[GP\s*<([^>]+)>]sgx) {
                            $ret_set = "$s7 $p->$true_method_name($cppargs2) = ".
                                "(GP <$1>) $value;\n";
                        }
                        add_cpp_method("", $class_name, "void", $method_name,
                                       "(0~$arguments,0~$return_type $value)0~",
                                       $ret_set);
                    }
                } else {
                    # otherwise
                    add_cpp_method($method_comment, $class_name, 
                                   $return_type, $method_name,
                                   $arguments, "");
                }
            }
        }
        %forbidden_names = ();
        if(!$constructor_seen && !$pure_specifier) {
            $constructor_flag = 1;
            add_cpp_method("", $class_name, "", $class_name, "(0~)0~", "");
        }
        $constructor_flag = 0;

        # A this point, we don't want to automatically add an equal operator
        $equal_seen = "seen";  # uncomment to get always equal operator
        if(!$equal_seen && !$pure_specifier) {
            $true_method_name = "operator=";
            if($super_class_name =~ /GPEnabled/) {
                add_cpp_method("/* Assignement operator */", $class_name, 
                               "void", "operator_equal",
                               "(0~$class_name *value)0~", 
                               "        (GP <$class_name>) p = ".
                               "(GP <$class_name>) value;\n");
            } else {
                add_cpp_method("/* Assignement operator */", $class_name, 
                               "void", "operator_equal",
                               "(0~$class_name *value)0~", 
                               "        *p = *value;\n");
            }
        }

        if(!$destructor_flag) {
            if($super_class_name =~ /GPEnabled/) {
                $true_method_name = "delete";
                add_cpp_method("", $class_name, "void", $true_method_name,
                               "(0~)0~", "        gpenabled_unref(p);\n");
            } else {
                $true_method_name = "delete";
                add_cpp_method("", $class_name, "void", $true_method_name,
                               "(0~)0~", "        delete(p);\n");
            }
        }
        $sn_body .= "(defmethod $class_name -destructor ()\n";
        $sn_body .= "  (when ~destructed\n";
        $sn_body .= "    (==> this ($class_name . delete))\n";
        $sn_body .= "    (setq destructed t)))\n\n";
        $snfile .= "$sn_class_comment;;\n$sn_class\n$sn_body";
        $snepilog .= ")\n$sn_constructors";
    }

    $hfile = $hf . "\n#endif\n\n" . $hfile;

    #print $snfile;
    #print "$cppfile";
}

##############################################################################
#
#  LoadBuffer ($filename, $buffer);
#  WriteBuffer ($filename, $buffer);
#
#  Load (file to buffer) and Write (buffer to file) buffers to files.
#
##############################################################################
sub LoadBuffer ($)
{
    local *FILE;
    my $buffer;
    open(FILE, $_[0]) or die "Could not open file $_[0] for reading";
    read(FILE, $buffer, 1000000);
    close(FILE);
    return $buffer;
}

sub WriteBuffer($$)
{
    local *FILE;
    open(FILE, ">".$_[0]) or die "Could not open file $_[0] for writing";
    print FILE "$_[1]";
    close(FILE);
}

##############################################################################
#
#  extract_directives (return directives only)
#  
##############################################################################
sub extract_directive($)
{
    my $directive = "";
    while($_[0] =~ m[((?:\/\/cpp2sn[^\n]*begin(?:.*?)
                       \/\/cpp2sn[^\n]*end[^\n]*\n) | 
                      (?:\/\/cpp2sn(?:[^\n]*)\n))]sgx) {
        $directive .= $1;
    }
    return $directive;
}

##############################################################################
#
#  extract_pre_directives (return directives which have pre only)
#  
##############################################################################
sub extract_pre_directive($)
{
    my $directive = "";
    my $temp;

    while($_[0] =~ m[((?:\/\/cpp2sn\ pre[^\n]*begin(?:.*?)
                       \/\/cpp2sn\ pre[^\n]*end[^\n]*\n) | 
                      (?:\/\/cpp2sn\ pre(?:[^\n]*)\n))]sgx) {
        $directive .= $1;
    }
    $directive =~ s/cpp2sn pre/cpp2sn/g;

    return $directive;
}

##############################################################################
#
#  remove pre directive (return buffer without the pre directives).
#  
##############################################################################
sub remove_pre_directive($)
{
    $_[0] =~ s/((?:\/\/cpp2sn pre[^\n]*begin(?:.*?)
                 \/\/cpp2sn pre[^\n]*end[^\n]*\n) | 
                (?:\/\/cpp2sn pre(?:[^\n]*)\n))//sgx;

    return $_[0];
}

##############################################################################
#
#  remove directive (return buffer without directives).
#  
##############################################################################
sub remove_directive($)
{
    $_[0] =~ s/((?:\/\/cpp2sn[^\n]*begin(?:.*?)
                 \/\/cpp2sn[^\n]*end[^\n]*\n) | 
                (?:\/\/cpp2sn(?:[^\n]*)\n))//sgx;

    return $_[0];
}

##############################################################################
#
#  directive_delete($buffer, $line, $length)
#  remove line $line to line $line+$length in $buffer (first line is line 1).
#
##############################################################################
sub directive_delete($$$)
{
    my $buffer = $_[0];
    my $line = $_[1]-1;
    my $len = $_[2];
    $buffer =~ m/([^\n]*\n){$line}/;
    my $prebuffer = $&;
    my $postbuffer = $';
    $postbuffer =~ m/([^\n]*\n){$len}/;
    return $prebuffer . $';
}

##############################################################################
#
#  directive_insert($buffer, $line, insert)
#
##############################################################################
sub directive_insert($$$)
{
    my $buffer = $_[0];
    my $line = $_[1]-1;
    my $insert = $_[2];

    $buffer =~ m/([^\n]*\n){$line}/;
    return $& . $insert . $';
}

##############################################################################
#
#  Apply the directives
#
##############################################################################
sub apply_directive($)
{
    while($_[0] =~ m[(\/\/cpp2sn[^\n]*(h|sn|cpp)[ \t]*
                      insert[ \t]*(\d+)[ \t]*begin[ \t]*\n(.*?)
                       \/\/cpp2sn[^\n]*end[^\n]*\n) | 
                     (\/\/cpp2sn[^\n]*(h|sn|cpp)[ \t]*delete
                      [ \t]*(\d+)[ \t]*(?:(\d+))?[^\n]*\n) |
                     (\/\/cpp2sn[ \t]*perl\s*([^\n]*)\n)]sgx) {
        my $begin_end = $1;
        my $extension1 = $2;
        my $line = $3;
        my $insert = $4;

        my $dele = $5;
        my $extension2 = $6;
        my $line2 = $7;
        my $len = $8;

        my $perl = $9;
        my $prog = $10;

        if($begin_end ne "") {
            $insert = clean_comments($insert);
            if($extension1 eq h) {
                $hfile = directive_insert($hfile, $line, $insert);
            } elsif ($extension1 eq sn) {
                $snfile = directive_insert($snfile, $line, $insert);
            } elsif ($extension1 eq cpp) {
                $cppfile = directive_insert($cppfile, $line, $insert);
            }
        } elsif($dele ne "") {
            if($len eq "") {
                $len = 1;
            }
            if($extension2 eq h) {
                $hfile = directive_delete($hfile, $line2, $len);
            } elsif ($extension2 eq sn) {
                $snfile = directive_delete($snfile, $line2, $len);
            } elsif ($extension2 eq cpp) {
                $cppfile = directive_delete($cppfile, $line2, $len);
            }
        } else {
            eval $prog;
        }
    }
}

sub usage ()
{
    my $name = $0;
    $name =~ s/.*\///;
    printf("Usage: %s [options] file1.h [file2.h ...]\n\n", $name);
    print "Options:\n";
    print "    -cpp filename1.cpp -- target C++ file (default: SNfile1.cpp)\n";
    print "    -h filename2.h     -- target h file (default: SNfile1.h)\n";
    print "    -sn filename3.sn   -- target sn file (default: file1.sn)\n";
    print "\n";
    print "file1.h [file2.h ...] are the source C++ files used to generate\n";
    print "the target files.\n\n";
    print "***Warning***: Be carefull in chosing file names.  The target \n";
    print "files can overwrite existing filenames (obviously if file1 and\n";
    print "filename2 were the same, it would be a disaster).  After \n";
    print "compilation, a filename1.o and a filename3.o will be created.\n";  
    print "They can override each other, or any of the file1.o, file2.o ...\n";
    print "in the same directory.  It is better to keep the C++ and SN file\n";
    print "in different directories.\n\n";
    exit;
}

##############################################################################
#
#  main($cpp_prototype, $SNfilename.cpp, $SNfilename.h, $filename.sn);
#
##############################################################################
sub main
{
    $snfile = "";
    $hfile = "";
    $cppfile = "$warning\n";
    my $directives;
    my $pre_directives;
    my $filename = "";
    my $filename_cpp = "";
    my $filename_h = "";
    my $filename_sn = "";
    my $includes = "";
    my $targetname = "";
    my $preload = "";
    local $snepilog = ";;".dup_string(77,"#")."\n\n(dhc-make () ";
    local $hbuffer = "";
    local $sn_include = "";

    for($i=0;$i<=$#ARGV;$i++) {
        if(substr($ARGV[$i], 0, 1) eq "-") {
            if($i == $#ARGV) {
                usage();
            }
            if($ARGV[$i] eq "-cpp") {
                $filename_cpp = $ARGV[$i+1];
            } elsif ($ARGV[$i] eq "-h") {
                $filename_h = $ARGV[$i+1];
            } elsif ($ARGV[$i] eq "-sn") {
                $filename_sn = $ARGV[$i+1];
            } else {
                usage();
            }
            $i++;
        } else {
            $filename = $ARGV[$i];
            if($targetname eq "") {
                $targetname = $filename;
            }
            $hbuffer .= LoadBuffer("$filename");
            $includes .= "\#include \"$filename\"\n";
            my $cpp = $filename;
            $cpp =~ s/\.h/\.cpp/;
            if(-e $cpp) {
                $preload .= "(g++-load \"" . $cpp . 
                    "\" \"-I$libdejavu_dir\")\n";
            }
            if($filename eq $filename_h) {
                printf("Error: $filename is both target".
                       " and source file.  Aborting.\n");
            }
        }
    }
    if($targetname eq "") {
        usage();
    }
    $targetname =~ s/(.*\/)?([^.]*).*/$2/;

    if($filename_cpp eq "") {
        $filename_cpp = "SN" . $targetname . ".cpp";
    }
    if($filename_h eq "") {
        $filename_h = "SN" . $targetname . ".h";
    }
    if($filename_sn eq "") {
        $filename_sn = $targetname . ".sn";
    }
    
    my $finclude = $filename_h . "_INCLUDE";
    $finclude =~ s/\./_/;
    $finclude =~ s/.*\///;
    $cppfile .= "#include \"$filename_h\"\n\n";
    $sn_include = "  (c-include \"$filename_h\")\n";

    $directives = extract_directive($hbuffer);
    $pre_directives = extract_pre_directive($directives);
    $hbuffer = remove_directive($hbuffer);
    apply_directive($pre_directives);

    addGroupLevels($hbuffer);
    
    parse_header($hbuffer);

    $hfile = "$warning\n#ifndef $finclude\n#define $finclude\n" .
        generate_h_prelude($includes, $filename_h) . $hfile . 
            "\n#ifdef __cplusplus\n}\n#else\n#endif /* __cplusplus */\n\n" .
                "#endif /* $finclude */\n";
    $snfile = generate_sn_prelude("$filename_cpp", $preload)
        . $snfile . $snepilog . "\n)\n";

#    my $i;
#    for($i=0;$i<length($hfile)-1100;$i++) {
#        printf("%s %d %d\n", substr($hfile, $i, 1), substr($hfile, $i, 1), $i);
#    }

    apply_directive($directives);
    
    WriteBuffer($filename_cpp, $cppfile);
    WriteBuffer($filename_h, $hfile);
#    printf("Length is %d\n",  length($hfile));
    WriteBuffer($filename_sn, $snfile);
}

main();










