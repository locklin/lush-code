$Id: matrix.hlp,v 0.1.1.1 2001-10-31 17:38:47 profshadoko Exp $
#? *** Arrays and Matrices

Array and matrices are objects able to contain a collection of values
addressed using a couple of subscripts.

.IP
An array manages arbitrary Lush objects.
.IP
A single precision matrix manages numbers stored under the single
precision floating point format (type <float> in C).
.IP
A double precision matrix manages numbers stored under the double
precision floating point format (type <double> in C).
.IP
An integer matrix manages numbers stored as 32 bit integers (type
<int> in C).
.IP
A short matrix manages numbers stored as 16 bit integers (type
<short> in C).
.IP
A byte matrix manages numbers stored as 8 bit unsigned integers (type
<unsigned char> in C) and thus limited to the <0>...<255> range.
.IP
A packed matrix ,manages numbes stored under a special compact format.
This format can deal with values ranging from <-8.0> to <+7 15/16> by
<1/16> increments.

Packed matrices are useful when dealing with big databases containing
binary data or non-binary data with a small dynamic range. Packed
matrix operations are totally transparent, except that rounding
operations are performed when converting a floating point value to a
compacted fixed point value (when setting a element of a compacted
array for example).
.PP

Once an array or a matrix has been created and stored into some symbol
<symb>, any of its elements can be accessed by evaluating the following lists:
.IP
<(symb i1...[in])> for returning the element 
indexed by subscripts <i1> to <in>.
.IP
<(symb i1...[in] val)> for storing the Lush object <val> at the
location indexed by subscripts <i1> to <in> and returning the array
itself.  This function physically modifies the array in a way
comparable to <rplaca> and <rplacd> in the case of lists.
This change will be reflected through all pointers referring to 
this same array.
.SEE (== <n1> <n2>)
.PP
Each subscript <i1> to <in> in fact may be a number or a list.
.IP
Numbers are used to address a particular element of an array. The
lower bound of a subscript is always <0>. The upper bound is the
dimension of the array minus one.
.IP
A list <(begin end)> addresses all the elements 
addressed by the numeric subscripts in the range <begin> to <end>.
The evaluation of <(symb i1...[in])> then returns a list of values.
.IP
An empty list addresses all the elements addressed by any legal
numeric subscript. The evaluation of <(symb i1...[in])> then returns a
list of values.
.PP
These powerful addressing methods provide a handy way to
access entire subarrays as a whole.

In addition, a set of functions is provided for copying matrices and
arrays, extracting submatrices, printing matrices and typing matrices.
There is also a set of matrix calculus functions operating on
1-dimensional or 2-dimensional single precision matrices.



#? ** General Matrix Allocation

#? (any-matrix <c> [<d1>...[<dn>]])
.TYPE DE
.FILE miscenv.lsh
The function <any-matrix> allocates a matrix with dimensions <d1>...<dn>.
Argument <c> specifies the matrix class;
it may be a class, another array or matrix, a symbol or a string.

When dimensions are not provided, <c> is assumed to be
an array or a matrix and dimensions are taken from it.


#? (array  <d1>...[<dn>])

Returns an array of dimensions <d1> to <dn>. 

Once an array is created, its elements may be accessed using the
construct described in the introduction of section ``Arrays and
Matrices''. An array is an instance of class <|ARRAY|>.
 

Example:
.VP
? (setq ar (array 3 4))         ; Create an array
= ::ARRAY:3x4
? (ar 2 3 'hand)                ; Set element (2,3)
= ::ARRAY:3x4
? (ar 2 3)                      ; Get this element
= hand
? (ar 0 1)                     	; Get another element
= ()
? (ar () 2 '(4 e 3))            ; Set the 3 elements of a line
= ::ARRAY:3x4
? (ar () 1 'f)                  ; Set another line to a constant
= ::ARRAY:3x4
? (ar 0 ())                    	; Get a column
= (() f 4 ())
? (setq h (ar () ()))  	        ; Get everything
= ((() f 4 ()) (() f e ()) (() f 3 hand))
? (ar () () 'e)                 ; Set everything
= ::ARRAY:3x4
? (ar () ())                    ; Get everything again
= ((e e e e) (e e e e) (e e e e))
                                ; Create an initialized array
? (setq ra ((array 3 4) () () h))
= ::ARRAY:3x4
? (ra () '(1 3))                ; Get the last 3 columns
= ((f 4 ()) (f e ()) (f 3 hand))
.PP

#? (matrix  <d1>...[<dn>])
.SEE (fmatrix  <d1>...[<dn>])

Function <matrix> is a convenient name for function <fmatrix>.

#? (fmatrix  <d1>...[<dn>])

Creates and returns a single precision matrix with dimensions <d1> to <dn>.  
Once a single precision matrix is created, its elements may be
accessed using the construct described in the introduction of section
``Arrays and Matrices''.  A matrix is an instance of class <|MAT|>.

#? (dim  symb <d1>...[<dn>])
.FILE sysenv.lsh
This function is exactly equivalent to:
.VP
  (setq symb (matrix d1...dn))
.PP


#? (dmatrix  <d1>...[<dn>])
Creates and returns a double precision matrix with dimensions <d1> to <dn>. 

Once a double precision matrix is created, its elements may be
accessed using the construct described in the introduction of section
``Arrays and Matrices''.  A matrix is an instance of the class
<|DMAT|>.

#? (ddim  symb <d1>...[<dn>])
.FILE sysenv.lsh
This function is exactly equivalent to:
.VP
  (setq symb (dmatrix d1...dn))
.PP


#? (imatrix  <d1>...[<dn>])
Creates and returns an integer matrix with dimensions <d1> to <dn>. 

Once an integer matrix is created, its elements may be accessed using
the construct described in the introduction of section ``Arrays and
Matrices''.  A matrix is an instance of class <|IMAT|>.


#? (idim  symb <d1>...[<dn>])
.FILE sysenv.lsh
This function is exactly equivalent to:
.VP
  (setq symb (imatrix d1...dn))
.PP


#? (smatrix  <d1>...[<dn>])
Creates and returns a short integer matrix with dimensions <d1> to <dn>. 

Once a short integer matrix is created, its elements may be
accessed using the construct described in the introduction of section
``Arrays and Matrices''.  A matrix is an instance of the class
<|SMAT|>.


#? (sdim  symb <d1>...[<dn>])
.FILE sysenv.lsh
This function is exactly equivalent to:
.VP
  (setq symb (smatrix d1...dn))
.PP


#? (bmatrix  <d1>...[<dn>])

Creates and returns a byte matrix with dimensions <d1> to <dn>. 

Once a byte matrix is created, its elements may be accessed using the
construct described in the introduction of section ``Arrays and
Matrices''.  A matrix is an instance of class <|BMAT|>.


#? (bdim  symb <d1>...[<dn>])
.FILE sysenv.lsh
This function is exactly equivalent to:
.VP
  (setq symb (bmatrix d1...dn))
.PP


#? (pmatrix  <d1>...[<dn>])

Creates and returns a packed matrix with dimensions <d1> to <dn>. 

Once a packed matrix is created, its elements may be accessed using
the construct described in the introduction of section ``Arrays and
Matrices''.  A packed matrix is an instance of class <|PMAT|>.


#? (pdim  symb <d1>...[<dn>])
.FILE sysenv.lsh
This function is exactly equivalent to:
.VP
  (setq symb (pmatrix d1...dn))
.PP


#? [ ... ]
.FILE sysenv.lsh
Single precision matrices may be directly typed with the ``[''
macro-character.
.VP
? [ 3 6 2 5.6 ]                 ;is a  1D matrix
= [ 3.00  6.00  2.00  5.60 ]

? [[1 2 3] [4 5 6] [7 8 9]]     ;is a  2D 3x3 matrix.
= [[ 1.00  2.00  3.00 ]
   [ 4.00  5.00  6.00 ]
   [ 7.00  8.00  9.00 ]]
.PP


#? ** General Matrix Utilities


#? (arrayp  <l>)
Returns <t> if object <l> is an array of pointers.

Example:
.EX (arrayp (array 10))


#? (matrixp  <l>)
Returns <t> if argument <l> is a matrix.


#? (bound  <mat> [<dim>])
Function <bound> returns the size of an array or a matrix <mat>.
.IP
If argument <dim> is omitted, the function <bound> returns the list of
the dimensions of the array <arr>.
.IP
If argument <dim> is <0>, the function <bound> returns the number of
dimensions of array <arr>.
.IP
If <dim> is a positive number, the function <bound> returns the
maximum subscript value for this dimension.

.VP
? (setq ar (array 4 6))
= ::ARRAY:4x6
? (bound ar) 
= (4 6)
? (bound ar 0)
= 2
? (bound ar 2)
= 5
? (for (i 0 (bound ar 1))
    (for (j 0 (bound ar 2))
      (prin (ar i j)) )
    (print) )
() () () () () ()
() () () () () ()
() () () () () ()
() () () () () ()
= ()
.PP


#? (matrix-print-mode  <mat> [<mode>])
Matrices are usually printed in a compact fashion (e.g.<::MAT:10x10>)
It is nevertheless possible to print them extensively by setting the
matrix-print-mode flag using this function.

If argument <mode> is (), matrix <mat> will be printed in a compact
format suitable for a large matrix. Otherwise, it will be printed
extensively. If argument <mode> is not provided, the current
matrix-print-mode flag of matrix <mat> is returned.


#? (matrix-print  <mat>)
.FILE sysenv.lsh
Prints the matrix <mat> extensively. This function is called when Lush
prints a matrix whose matrix-print-mode flag is set.

.EX (matrix-print (matrix 3 4))

#? (array-print <a> [<rs>])
.TYPE DE
.FILE miscenv.lsh
The function <array-print> prints the content of a 1D or 2D array <a>.
The optional argument <rs> defines a row separator, for which default
value is a tabulation character.


#? (list-to-array <l>)
.TYPE DE
.FILE miscenv.lsh
The function <list-to-array> converts a list into an array.
Multidimensional lists are supported.


#? (copy-matrix  <mat1> [<mat2>])
This functions copies matrix <mat1> into matrix <mat2>. If argument
<mat2> is not provided, a new matrix is allocated. Function
<copy-matrix> always returns the destination matrix. Matrices <mat1>
and <mat2> must have the same geometry.

Matrices <mat1> and <mat2> may be any kind of matrices, submatrices or
even arrays containing only numbers. The transfer rate is slightly
slower if a conversion is needed.


#? (copy-any-matrix  <mat1> [<mat2>])
This function behaves like <copy-matrix>. Matrices <mat1> and <mat2>
however can have different geometries, provided they have the same
number of elements. This function is useful, for instance, for
converting 3D matrices to 2D matrices.

.VP
? (setq a (matrix 10 16 16))
= ::MAT:10x16x16
? (for (i 0 9) (a i () () (sqrt i)))
= ::MAT:10x16x16
? (setq b (copy-any-matrix a (matrix 10 256)))
= ::MAT:10x256
? (b () (rand 0 255))
= (0 1 1.4142 1.7321 2 2.2361 2.4495 2.6458 2.8284 3)
.PP


#? (matrix-concat <m1>...<mn>)
.TYPE DE
.FILE miscenv.lsh

The function <matrix-concat> concats matrices and arrays <m1>...<mn>
adding their first dimension.

Conventionaly arguments <m1>...<mn> may be numbers
standing for the number of void lines to be inserted.
At least one matrice or array should be provided as argument.

The first matrix or array of the argument list will be taken
as reference to specify the matrix dimensions and matrix class.


#? (matrix-lines <m> <s> [<res>] <neg>] <rev>]]])
.TYPE DE
.FILE miscenv.lsh

The function <matrix-liness> copies (resp. replaces) parts of matrix <m>
into (resp. by data from) matrix <res>.

List <s> contains subscripts taken in the first dimension of <m>.
This list is not necessarily ordered and may be redundant.
However, it must contain only valid subscrits, otherwise
its result is undefined.

When boolean <neg> is <nil> or not defined (resp. not nil),
these subscripts define the data to copy (resp. not to copy).

When boolean <rev> is <nil> or not defined (resp. not nil),
data is copied into (from) the result matrix.

Optional argument <res> is the result matrix.
If argument <res> is not provided, a well sized matrix is allocated.

This function returns the result matrix when the selection is not void.
It returns <nil> otherwise.


#? (matrix-columns <m> <s> [<res> [<neg> [<rev>]]])
.TYPE DE
.FILE miscenv.lsh

The function <matrix-columns> copies (resp. replaces) parts of matrix <m>
into (resp. by) matrix <res>.

List <s> contains subscripts taken in the second dimension of <m>.
Otherwise this functions behaves exactly as <matrix-lines>.

.SEE (matrix-lines <m> <s> [<res> [<neg> [<rev>]]])


#? (matrix-group-columns <m> <s> [<id> [<res>]])
.TYPE DE
.FILE miscenv.lsh

The function <matrix-group-columns> reorganizes matrix <m>
by selecting columns and by converting columns groups
into single columns while multiplying the number of lines.

List <s> is made of numbers, lists of numbers and empty lists.
Simple numbers stand for the subscript of simple selected columns.
List of numbers stand for the subscript of grouped columns.
An empty list stands for an identifier column.

All lists of numbers in <s> must have the same length.
All numbers in <s> or sublists of <s> must be valid subscripts of <m>.

The result matrix has one line per line of <m> and per
column in any columns group defined by <s>. Its column number
is equal to the length of <s>. The result matrix may be either
given as argument <res> or allocated.

Identifier columns are filled with values of list <id>.
The default value for <id> is list of numbers representing the
range between 0 and the number of grouped columns in any group, less 1.

This function is especially usefull to convert non-relational tables
into relational tables.
In the following example, a table with one line per year,
one year identifier column and 12 columns (one per month)
is converted into a table having three columns: one year
identifier, one month identifier and one value.
.VP
? (progn (setq a (array 3 13)) (a () 0 '(1995 1996 1997)) (for (i 0 (bound a 1)) (a i (list 1 12) '(31 28 31 30 31 30 31 31 30 31 30 31)) (when (0= (mod (a i 0) 4)) (a i 2 29))))
= ()
(array-print a " ")
1995 31 28 31 30 31 30 31 31 30 31 30 31 
1996 31 29 31 30 31 30 31 31 30 31 30 31 
1997 31 28 31 30 31 30 31 31 30 31 30 31 
= ()
? (array-print (matrix-group-columns a (list 0 () (range 1 12)) (range 1 12)))
= ()
1995    1       31
1995    2       28
1995    3       31
1995    4       30
1995    5       31
1995    6       30
1995    7       31
1995    8       31
1995    9       30
1995    10      31
1995    11      30
1995    12      31
1996    1       31
1996    2       29
1996    3       31
1996    4       30
1996    5       31
1996    6       30
1996    7       31
1996    8       31
1996    9       30
1996    10      31
1996    11      30
1996    12      31
1997    1       31
1997    2       28
1997    3       31
1997    4       30
1997    5       31
1997    6       30
1997    7       31
1997    8       31
1997    9       30
1997    10      31
1997    11      30
1997    12      31
= ()
.PP


#? (mreplace <m> <x> <y>)

This function searches matrix or array <m> and replaces
occurences of <x> with <y>.

Unlike <moccur> which is written in C, <mreplace> is written in Lush.
Therefore:
.IP
it supports any kind of matrix and array,
.IP
it is much slower,
.IP
occurences are checked with the Lush equality
which is IEEE-compliant for NaNs,
i.e. NaN values are not equal.
.PP


#? ** General Matrix addressing Schemes

Matrices are a convenient way to address data into a storage space.
Once a matrix is allocated, it is often usefull to address
the same storage space by a different way
i.e. pointing the same elements with an alternate addressing scheme.

Lush provides several functions for this purpose.


#? (submatrix  <mat> <s1>...[<sn>])

This is a submatrix extraction function. It returns a matrix
descriptor corresponding to the portion of matrix <mat> addressed by
subscripts <s1> to <sn>.  Subscripts <s1> to <sn> may be numbers or
lists using the same rules than subscripts used for accessing the
individual matrix elements.

Submatrices are not copies of a part of a matrix. They are only a
different way to access the same elements. Any write operation on a
matrix or submatrix thus affects all matrices or submatrices which
have the same ancestor matrix.

.VP
? (setq a [[1 2 3][4 5 6][7 8 9]])
= [[ 1.00  2.00  3.00 ]
   [ 4.00  5.00  6.00 ]
   [ 7.00  8.00  9.00 ]]

? (setq b (submatrix a 1 ()) )
= [ 4.00  5.00  6.00 ]

? (b 1 -1)
= [ 4.00  -1.00  6.00 ]

? a
= [[ 1.00  2.00  3.00 ]
   [ 4.00 -1.00  6.00 ]
   [ 7.00  8.00  9.00 ]]

? (submatrix a () '(0 1))
= [[ 1.00  2.00 ]
   [ 4.00 -1.00 ]
   [ 7.00  8.00 ]]
.PP


#? (transpose <m>)
.SEE (mtranspose <m> <n1> <n2>)

Function <transpose> returns a transposed matrix descriptor for matrix <m>.
Matrix <m> has two dimensions at most.

Like function <submatrix>, this function returns a matrix descriptor
pointing the same elements with a different addressing scheme:
subscripts have been transposed.
.VP
? (transpose [[1 2 3][4 5 6]])
= [[ 1.00  4.00 ]
   [ 2.00  5.00 ]
   [ 3.00  6.00 ]]

? (transpose result)
= [[ 1.00  2.00  3.00 ]
   [ 4.00  5.00  6.00 ]]

? (transpose [1 2 3])         ;warning: 1d matrix = Nx1 matrix
= [[ 1.00  2.00  3.00 ]]      ;and `transpose` gives a 1xN matrix
.PP


#? (mtranspose <m> <n1> <n2>)
.SEE (transpose <m>)

Function <mtranspose> returns a new matrix descriptor for matrix <m>,
in which dimensions <n1> and <n2> have been switched.
Dimensions <n1> and <n2> are counted from <0> to <(1- (bound m 0))>.

Function <mtranspose> is a generalized version of function <transpose>.
It can be used on multi-dimension matrices.

Like function <submatrix>, this function returns a matrix descriptor
pointing the same elements with a different addressing scheme:
subscripts have been transposed.
.VP
? (setq a (matrix 120)))
= ::MAT:120
? (setq aa (msplit-dim a 0 '(() 3))))
= ::MAT:40x3
? (setq aaa (msplit-dim aa 0 '(() 2)))
= ::MAT:20x2x3
? (setq aaaa (msplit-dim aaa 0 '(() 5)))
= ::MAT:4x5x2x3
? 
? (a () (range 0 119))
= ::MAT:120
? (aaaa 1 3 0 1)
= 49
? 
? (setq bbbb (mtranspose aaaa 1 2)))
= ::MAT:4x2x5x3
? (bbbb 1 0 3 1)
= 49
.PP


#? (diagonal <m>)

Function diagonal returns a unidimensional matrix descriptor which
addresses the diagonal elements of the square matrix <m>.
.VP
? (diagonal [[1 2 3][4 5 6][7 8 9]])
= [ 1.00  5.00  9.00 ]
.PP


#? (rotate  <m> [<n>])

Function <rotate> returns a new rotated matrix descriptor for matrix <m>.
Integer <n> specifies the clockwise rotation (basically 0 1 2 or 3).
The default rotation is a clockwise quarter of a turn.

Like function <submatrix>, this function returns a matrix descriptor
pointing the same elements with a different addressing scheme:
subscripts have been rotated.
.VP
? (rotate [[1 2 3][4 5 6]])
= [[ 4.00  1.00 ]
   [ 5.00  2.00 ]
   [ 6.00  3.00 ]]

? (rotate result 2)
= [[ 3.00  6.00 ]
   [ 2.00  5.00 ]
   [ 1.00  4.00 ]]

? (rotate [1 2 3])            ;warning: 1d matrix = Nx1 matrix
= [[ 1.00  2.00  3.00 ]]      ;and `rotate` gives a 1xN matrix
.PP


#? (msplit-dim <m> <targetdim> <newdims>)
.SEE (mmerge-dim <m> <firstdim> <ndim>)

Function <msplit-dim> returns a new matrix descriptor for matrix <m>
in which dimension <targetdim> has been splitted into several smaller
dimensions of wich sizes are given in list <newdims>.

Argument consistency requires the product of items in <newdims>
is equal to the size of dimension <targetdim>.

In addition two conventions are provided.
.IP
List <newdims> may contain a unique null or zero-valued
item, meaning it will be deduced. Then argument consistency just requires
that the product of non-null or zero-valued items in <newdims>
is an integer divider of the size of dimension <targetdim>.
.IP
Integer <targetdim> may be negative,
meaning the splitted dimension is counted backward
from the last dimension of matrix <m>.
.PP

Like function <submatrix>, this function returns a matrix descriptor
pointing the same elements with a different addressing scheme:
one subscript has been splitted,
i.e. matrix has gained <(1- (length newdims))> dimensions.
.PP

.VP
? (msplit-dim [1 2 3 4 5 6 7 8 9 10 11 12] 0 '(2 3 2))
= ::MAT:2x3x2

? (msplit-dim (matrix 5 7 12) -1 '(() 2)))
= ::MAT:5x7x6x2
.PP


#? (mmerge-dim <m> <firstdim> <ndim>)
.SEE (msplit-dim <m> <targetdim> <newdims>)

Function <mmerge-dim> returns a new matrix descriptor for matrix <m>
in which dimensions from <firstdim> to <firstdim + ndim> have been
merged into one large dimension.

Conventionaly, integer <targetdim> may be negative, meaning the splitted
dimension is counted backward from the last dimension of matrix <m>.

Warning: The implementation of matrix descriptors rely on homogeneity
of elements localisation into memory for any given dimension.
As a consequence, it happens that <mmerge-dim> fails.
Failure causes <mmerge-dim> returns nil.
Failure does not append for original matrices
or for merging dimensions just splitted by <msplit-dim>.

Like function <submatrix>, this function returns a matrix descriptor
pointing the same elements with a different addressing scheme:
some subscripts have been merged,
i.e. matrix has lost <ndim - 1> dimensions.
.VP
? (mmerge-dim [[1 2 3][4 5 6]] 0 2)               
= [ 1.00  2.00  3.00  4.00  5.00  6.00 ]

? (mmerge-dim (matrix 2 3 5 7 11) 1 3)))
= ::MAT:2x105x11
.PP


#? (mrep-dim <m> <targetdim> <n>)
Function <mrep-dim> returns a new matrix descriptor for matrix <m>
in which dimension <targetdim> has been replaced by two new dimensions.
The size of the first new dimension is <n>.
The size of the second new dimension is the size of dimension <targetdim>.

The returned matrix addresses <n> times the same data.

Conventionaly, integer <targetdim> may be negative, meaning the splitted
dimension is counted backward from the last dimension of matrix <m>.

.VP
? (mrep-dim [1 2] 0 3)
= [[1.00 2.00]
   [1.00 2.00]
   [1.00 2.00]]
.PP


#? (munfold-dim <m> <targetdim> <newdim2> <offset>)

Function <munfold-dim> returns a new matrix descriptor for matrix <m>
in which dimension <targetdim> has been unfolded
and replaced by two dimensions.
Argument <newdim2> is the size of the second new dimension.

Actually this function may be defined by the following property.
.VP
(ans () ... () i j () ... ())
  =
(m () ... () (+ (* offset i) j) () ... ())
.PP
Argument consistency requires that the size of dimension <targetdim>
minus <newdim2> is a multiple of <offset>.

Conventionaly, integer <targetdim> may be negative, meaning the splitted
dimension is counted backward from the last dimension of matrix <m>.

Like function <submatrix>, this function returns a matrix descriptor
pointing the same elements with a different addressing scheme.
However, depending on <offset> and the size of dimension <targetdim>,
the new addressing scheme points several time the same elements or
points only some of them.
.IP
When <offset> is smaller than <newdim2>, the returned matrix addresses
at least once each element of <m>, and addresses several times some of them.
.IP
When <offset> is greater than <newdim2>, the returned matrix addresses
at most once each element of <m>, and does not address all of them.
.IP
When <offset> is equal to <newdim2>, the returned matrix addresses
once each element of <m>. <(munfold-dim m targetdim newdim2 offset)>
is then equivalent to <(msplit-dim m targetdim (list () newdim2))>
.PP
.VP
? (munfold-dim [1 2 3 4 5 6 7 8  9 10 11 12] 0 8 2)
= [[ 1.00  2.00  3.00  4.00  5.00  6.00  7.00  8.00 ]
   [ 3.00  4.00  5.00  6.00  7.00  8.00  9.00 10.00 ]
   [ 5.00  6.00  7.00  8.00  9.00 10.00 11.00 12.00 ]]

? (munfold-dim [1 2 3 4 5 6 7 8  9 10 11 12] 0 8 4)
= [[ 1.00  2.00  3.00  4.00  5.00  6.00  7.00  8.00 ]
   [ 5.00  6.00  7.00  8.00  9.00 10.00 11.00 12.00 ]]

? (munfold-dim [1 2 3 4 5 6 7 8  9 10 11 12] 0 4 8)
= [[ 1.00  2.00  3.00  4.00 ]
   [ 9.00 10.00 11.00 12.00 ]]

? (munfold-dim [1 2 3 4 5 6 7 8 9 10 11 12] 0 2 10)
= [[ 1.00  2.00 ]
   [11.00 12.00 ]]
.PP


#? ** Matrix Sorting and Searching.

Several functions are provided for searching and sorting matrices.

Functions <moccur> and <mset> work on occurences of values in matrices.

Functions <msort>, <mindex-compute>, <mindex-apply>, <mindex-combine>,
<mindex-inv>, <mseek>, <mseek-up>, <mseek-down> define a comprehensive,
consistent set for working with indexes.


#? (moccur <mat> <x> [<y> [<tgt>]])

Returns the number of occurences of the number <x> inside matrix <mat>.

When optional argument <y> is defined, all occurences of <x>
are replaced by <y>.

Optional argument <tgt> is a matrix in which are written
a <y> value for each occurence of <x> in <mat>,
while other subscripts keep their old value.

This function also yields the correct result when <x> is NaN.

.VP
? v
= [ 0.00  1.00  1.00  0.00   NaN  0.00   NaN  1.00  1.00 ]
? w
= [ 0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00 ]
? (moccur v 1)
= 4
? v
= [ 0.00  1.00  1.00  0.00   NaN  0.00   NaN  1.00  1.00 ]
? (moccur v 1 2 w)
? w
= [ 0.00  2.00  2.00  0.00  0.00  0.00  0.00  2.00  2.00 ]
? (moccur v 1 3)
= 4
? v
= [ 0.00  3.00  3.00  0.00   NaN  0.00   NaN  3.00  3.00 ]
? (moccur v (nan))
= 2
.PP

#? (mset <msel> <m1> [<ans>])

This function returns a matrix formed by copying the
elements of matrix <m1> whenever the corresponding element
of matrix <msel> is non zero.
.IP
When argument <ans> is not specified, the returned matrix
is a newly allocated matrix. Uninitialized elements are
therefore zero.
.IP
When argument <ans> is a number, the returned matrix
is a newly allocated matrix. Uninitialized elements are
set to the vakue <ans>.
.IP
When argument <ans> is a matrix (with same dimensions as <msel>
and <m1>), this matrix is used to form the answer. The value
of the uninitialized elements is unchanged.
.VP
? v
= [ 5.00  3.00  3.00  5.00   NaN  5.00   NaN  3.00  3.00  5.00 ]
? w
= [ 1.00  0.00  0.00  1.00  1.00  1.00  1.00  0.00  0.00  1.00 ]
? (setq q (mset w v pi))
= ::MAT:10
? (matrix-print-mode q t)
= t
? q
= [ 5.00  3.14  3.14  5.00   NaN  5.00   NaN  3.14  3.14  5.00 ]
.PP

#? (msort <m0> [<m1> ... <mn>] )

This function sorts the one-dimensional matrix <m0> in place
in ascending order. It returns a one-dimensional integer matrix 
representing the permutation applied to the member of <m0>.

The same permutation is applied to the optional one-dimensional
matrices <m1>....<mn>. These matrices must have the same size
than matrix <m0>.

.SEE (mindex-compute <m0> [<indx>])
.SEE (mindex-apply <indx> <m0> [<ans>])


#? (mindex-compute <m0> [<indx>])

This function returns a one dimensional integer matrix
representing the permutation that would arrange
the elements of the one-dimensional matrix <m0> in
ascending order.

When the optional integer matrix <indx> is provided, the permutation
is stored into this matrix instead of being stored in a new
integer matrix.


#? (mindex-apply <indx> <m0> [<ans>])

This function returns a one-dimensional matrix with the same
size than matrix <m0>. This matrix is filled with the
elements of <m0> permuted according to the permutation
represented by the integer matrix <indx>.

When the optional integer matrix <ans> is provided, the result
is stored into this matrix instead of being stored in a new
matrix.

This function still works correctly when matrices <m0>
and <ans> address the same memory space
(by being overlapping matrices from the same mother matrix).


#? (mindex-compose <indx1> ... <indxn>)

This function takes a series of one-dimensional integer
matrices <indx1> ... <indxn> representing permutations
and returns a new integer matrix representing the combination
of these permutations.

Example: The following expression:
.VP
(mindex-apply (mindex-compose indx1 indx2 indx3) m0)
.PP
is equivalent to 
.VP
(mindex-apply indx3 (mindex-apply indx2 (mindex-apply indx1 m0)))
.PP

The permutation matrix may have decreasing size. This feature
allows for managing permutations computed on subsets of the
initial matrix.


#? (mindex-inv <indx> [<ians>])

This function computes the inverse of the permutation represented
by the integer matrix <indx>. Applying the combination of a permutation
and of its inverse returns the original matrix:
.VP
? (let* ((indx (mindex-compute m0)))
    (= m0 (mapply-index m0 (mindex-compose indx (mindex-inv indx)))) )
= t
.PP
When the optional integer matrix <ians> is provided, the permutation
is stored into this matrix instead of being stored in a new
integer matrix.

#? (mseek <m0> <x> [<indx>])

This function searches the one-dimensional matrix <m0> for value <x>.
It returns the first subscript with value <x>.
When value <x> is not found, it returns <()>.
.IP
When argument <indx> is ommitted, 
this function assumes that matrix <m0> is sorted in ascending order.
.IP
When argument <indx> is specified,
it must contain a permutation that would sort matrix <m0> in 
ascending order.
.SEE (mindex-compute <m0> [<indx>])


#? (mseek-down <m0> <x> [indx])

This function searches the one-dimensional matrix <m0> for value <x>.
It returns the first subscript corresponding to value <x>.
If value <x> is not found, it returns the last subscript corresponding
to a value lower than <x>. When all values are larger than <x>, this
function returns <()>.
.IP
When argument <indx> is ommitted, 
this function assumes that matrix <m0> is sorted in ascending order.
.IP
When argument <indx> is specified,
it must contain a permutation that would sort matrix <m0> in 
ascending order.
.SEE (mindex-compute <m0> [<indx>])


#? (mseek-up <m0> <x> [<indx>])

This function searches the one-dimensional matrix <m0> for value <x>.
It returns the first subscript corresponding to value <x>.
If value <x> is not found, it returns the last subscript corresponding
to a value larger than <x>. When all values are smaller than <x>, this
function returns <()>.
.IP
When argument <indx> is ommitted, 
this function assumes that matrix <m0> is sorted in ascending order.
.IP
When argument <indx> is specified,
it must contain a permutation that would sort matrix <m0> in 
ascending order.

#? ** Matrix Calculus Functions.

Matrix calculus functions work only with 1-dimensional (vectors) or
2-dimensional (matrices) single precision matrices. You must use
function <copy-matrix> to convert matrices under any other format.
Moreover, the following functions consider vectors and single column
matrices as equivalent.


#? (m+m  <mat1> <mat2> [<res>])
Adds matrices <mat1> and <mat2> term by term. The result is stored
into the matrix <res>. If argument <res> is not provided, a well sized
matrix is allocated. This function returns the result matrix <res>.

Example:
.VP
? (m+m [1 2] [3 4])
= [ 4.00  6.00 ]
.PP


#? (m-m <mat1> <mat2> [<res>])
Subtracts matrices <mat1> and <mat2> term by term. The result is stored
into the matrix <res>. If argument <res> is not provided, a well sized
matrix is allocated. This function returns the result matrix <res>.

Example:
.VP
? (m-m [[1 2][3 4]] [[1 1][1 1]])
= [[ 0.00  1.00 ]
   [ 2.00  3.00 ]]
.PP


#? (mxm <mat1> <mat2> [<res>])
Multiplies matrices <mat1> and <mat2> term by term. The result is stored
into the matrix <res>. If argument <res> is not provided, a well sized
matrix is allocated. This function returns the result matrix <res>.

Example:
.VP
?  (mxm [[1 2][3 4]] [[5 6][7 8]])
= [[ 5.00 12.00 ]
   [21.00 32.00 ]]
.PP


#? (m/m <mat1> <mat2> [<res> [db0]])
Divides matrices <mat1> and <mat2> term by term. The result is stored
into the matrix <res>. If argument <res> is not provided, a well sized
matrix is allocated. This function returns the result matrix <res>.

When optional argument <db0> is not set or is nil, division by zero leads to an error.
When <db0> is a number, its value appears in <res> where division by 0 occurs.

For backward-compatibility reason, when <db0> is neither nil nor a number,
the it behaves as if it was <0>.

Example:
.VP
? (m/m [[1 2][3 4]] [[5 6][7 8]])
= [[ 0.20  0.33 ]
   [ 0.43  0.50 ]]
? (m/m [[1 2][3 4]] [[5 6][7 0]] () 213)
= [[ 0.20  0.33 ]
   [ 0.43  213 ]]
.PP


#? (m**m <mat1> <mat2> [<res>])
.TYPE DE
.FILE miscenv.lsh
Computes the term-by-term power elevation of <mat1> and <mat2>.
The result is stored into the matrix <res>. If argument <res> is not provided,
a well sized matrix is allocated. This function returns the result matrix <res>.


#? (m*m <mat1> <mat2> [<res>])
Computes the outer product of matrices <mat1> and <mat2>. The result is
stored into the matrix <res>. If argument <res> is not provided, a new
matrix is allocated. This function returns the result matrix <res>.

Example:
.VP
? (setq a [[1 2 3][4 5 6][7 8 9]])
= [[ 1.00  2.00  3.00 ]
   [ 4.00  5.00  6.00 ]
   [ 7.00  8.00  9.00 ]]

? (m*m a a)
= [[30.00 36.00 42.00 ]
   [66.00 81.00 96.00 ]
   [102.00 126.00 150.00 ]]
.PP


#? (m*d <mat1> <vec2> [<res>])
Returns the product of matrix <mat1> by the diagonal square matrix
whose diagonal elements are stored in <vec2>.  The result is stored in
matrix <res>. If no matrix <res> is specified, a new matrix is
allocated. This function returns the result matrix <res>.

Example:
.VP
? (m*d [[1 2][3 4]] [2 2])
= [[ 2.00  4.00 ]
   [ 6.00  8.00 ]]
.PP

#? (m+c <mat> <c> [<res>])
Adds the scalar <c> to the elements of matrix <mat> and stores the
result in matrix <res>.  If no matrix <res> is specified, a new matrix
is allocated. This function returns the result matrix <res>.

Example:
.VP
? (m+c [1 2] 3)
= [ 4.00  5.00 ]
.PP


#? (m*c <mat> <c> [<res>])
Multiplies the elements of matrix <mat> by the scalar <c> and stores
the result in matrix <res>.  If no matrix <res> is specified, a new
matrix is allocated. This function returns the result matrix <res>.

Example:
.VP
?  (m*c [1 2] 3)
= [ 3.00  6.00 ]
.PP

#? (dot-product <x> <y>)
Returns the dot product of vectors <x> and <y>. 

Example:
.VP
? (dot-product [1 2 3][4 5 6])
= 32
.PP


#? (trace <mat>)
Computes the trace of matrix <mat>.
The trace is defined as the sum of the diagonal coefficients of <mat>.
It is equivalently defined as the sum of the eigen values of <mat>.


#? (m/ <mat> [<res> [<db0>]])
Computes the term-by-term inverse of matrix <mat> and stores
the result in matrix <res>.  If no matrix <res> is specified, a new
matrix is allocated. This function returns the result matrix <res>.

When optional argument <db0> is not set or is nil, division by zero leads to an error.
When <db0> is a number, its value appears in <res> where division by 0 occurs.


#? (msqrt <mat> [<res>])
Computes the term-by-term square root of matrix <mat>
and stores the result in matrix <res>.
If no matrix <res> is specified, a new matrix is allocated.
This function returns the result matrix <res>.


#? (mexp  <mat> [<res>])
Computes the term-by-term exponential of matrix <mat>
and stores the result in matrix <res>.
If no matrix <res> is specified, a new matrix is allocated.
This function returns the result matrix <res>.


#? (mlog  <mat> [<res>])
Computes the term-by-term logarithm of matrix <mat>
and stores the result in matrix <res>.
If no matrix <res> is specified, a new matrix is allocated.
This function returns the result matrix <res>.


#? (mcos  <mat> [<res>])
Computes the term-by-term cosinus of matrix <mat>
and stores the result in matrix <res>.
If no matrix <res> is specified, a new matrix is allocated.
This function returns the result matrix <res>.


#? (msin  <mat> [<res>])
Computes the term-by-term sinus of matrix <mat>
and stores the result in matrix <res>.
If no matrix <res> is specified, a new matrix is allocated.
This function returns the result matrix <res>.


#? (mtan  <mat> [<res>])
Computes the term-by-term tangent of matrix <mat>
and stores the result in matrix <res>.
If no matrix <res> is specified, a new matrix is allocated.
This function returns the result matrix <res>.


#? (masin <mat> [<res>])
Computes the term-by-term arc-sinus of matrix <mat>
and stores the result in matrix <res>.
If no matrix <res> is specified, a new matrix is allocated.
This function returns the result matrix <res>.


#? (macos <mat> [<res>])
Computes the term-by-term arc-cosinus of matrix <mat>
and stores the result in matrix <res>.
If no matrix <res> is specified, a new matrix is allocated.
This function returns the result matrix <res>.


#? (matan <mat> [<res>])
Computes the term-by-term arc-tangent of matrix <mat>
and stores the result in matrix <res>.
If no matrix <res> is specified, a new matrix is allocated.
This function returns the result matrix <res>.


#? (msinh <mat> [<res>])
Computes the term-by-term hyperbolic sinus of matrix <mat>
and stores the result in matrix <res>.
If no matrix <res> is specified, a new matrix is allocated.
This function returns the result matrix <res>.


#? (mcosh <mat> [<res>])
Computes the term-by-term hyperbolic cosinus of matrix <mat>
and stores the result in matrix <res>.
If no matrix <res> is specified, a new matrix is allocated.
This function returns the result matrix <res>.


#? (mtanh <mat> [<res>])
Computes the term-by-term hyperbolic tangent of matrix <mat>
and stores the result in matrix <res>.
If no matrix <res> is specified, a new matrix is allocated.
This function returns the result matrix <res>.


#? (inf-mat <mat>)
Finds the smallest element of matrix <mat>.
The computation skips NaN values.

Example:
.VP
? (inf-mat [[2 1][4 3]])
= 1
.PP
.SEE NaN.


#? (sup-mat <mat>)
Finds the largest element of matrix <mat>.
The computation skips NaN values.

Example:
.VP
? (sup-mat [[2 1][4 3]])
= 4
.PP

.SEE NaN.


#? (am+bm a mata b matb [matc])

Computes a term by term linear combination
of the elements of matrices <mata> and <matb>
and stores them in matrix <matc>.
.VP
matc = a * mata + b * matb
.PP
Matrix <matc> is returned. It is allocated on demand.


#? (mbary a mata b matb [matc])

Computes a term by term weighted mean
of the elements of matrices <mata> and <matb>
and stores them in matrix <matc>.
The computation skips NaN values.
.VP
matc = a/(a+b) * mata + b/(a+b) * matb
.PP
Matrix <matc> is returned. It is allocated on demand.
.VP
? v1
= [ 0.00   NaN  2.00  3.00  4.00   NaN  6.00  7.00  8.00  9.00 ]
? v2
= [10.00 10.00 10.00   NaN 10.00   NaN 10.00 10.00 10.00 10.00 ]
? (mbary 1 v1 2 v2)
= ::MAT:10
? (matrix-print (mbary 1 v1 2 v2))
[ 6.67 10.00  7.33  3.00  8.00   NaN  8.67  9.00  9.33  9.67 ]= ()
.PP


#? (mean-mat <mat>)
Returns the mean of the elements of matrix <mat>.
The computation skips NaN values. When all values are
NaN, the function returns NaN.

Example:
.VP
? (mean-mat [[2 1][4 3]])
= 2.5
.PP

.SEE NaN.


#? (sdev-mat <mat>)
Returns the standard deviation of the elements of matrix <mat>.
The computation skips NaN values. When all values are
NaN, the function returns NaN.
.VP
;; Normalize matrix <mat>
(de normalize(mat)
	(let ((m (mean-mat mat))
	      (s (sdev-mat mat)) )
  	  (m+c mat (- m) mat)
   	  (m*c mat (/ s) mat) ) )
.PP

.SEE NaN.


#? (convolve <mat> <sx> <sy> <kernel> [<res>])

Convolves matrix <mat> whith matrix <kernel>, stepping by <sx>
elements on the first dimension and <sy> elements on the second
dimension. The result is stored into matrix <res> and returned.

If <kernel> is a <km>x<kn> matrix and <mat> a <n*sy+k-sy>x<m*sx+km-sx>
matrix, the result is a <m>x<n> matrix.

Example:
.VP
? (setq image (matrix 64 64))
= ::MAT:64x64
? (setq edgeextractor [[-1 -2 -1][-2  8  2][-1 -2 -1]])
= [[-1.00 -2.00 -1.00 ]
   [-2.00  8.00  2.00 ]
   [-1.00 -2.00 -1.00 ]]
? (convolve image 1 1 edgeextractor)
= ::MAT:62x62
.PP

#? ** Matrix Numerical Analysis.

Matrices are endowed many mathematical properties such as inversibility
or eigen vectors. The related operators are implemented by non-trivial
algorithms.

Actually the implementation of these operators may be tricky,
due to numerical stability and singular properties failures...
Choice has often to be made between several algorithms among which none
is superior in all apsects.
The following procedures have been selected by putting the main
emphasis on their robustness and a secondary emphasis on their speed.

Most matrix numerical analysis functions work on contiguous matrices
and return <()> when non contiguous matrices are given as argument.


#? (minvdet <mat>)

Function <minvdet> overwrites a matrix by its inverse and returns its
determinant. When <mat> is a singular matrix, it returns 0 and <mat>
is overwritten by undefined values.

It works only with contiguous arrays and returns <()> for non contiguous
matrices, in which case you have to copy it first.

The current implementation of function <minvdet> rely on the 
Gauss pivoting method.

.VP
? (setq m [[1 2 3] [4 5 5] [8 3 2]])
= [[ 1.00  2.00  3.00 ]
   [ 4.00  5.00  5.00 ]
   [ 8.00  3.00  2.00 ]]
? (minvdet (setq n (copy-matrix m)))
= -25
? n
= [[ 0.20 -0.20  0.20 ]
   [-1.28  0.88 -0.28 ]
   [ 1.12 -0.52  0.12 ]]
? (m*m m n)
= [[ 1.00  0.00  0.00 ]
   [ 0.00  1.00  0.00 ]
   [ 0.00 -0.00  1.00 ]]
? 
.PP


#? (mseigvv <m>)

Function <mseigvv> overwrites a symetric matrix <m> with
its eigen vectors and returns a vector containing its eigen
values.

It works only with contiguous arrays and returns <()> for non contiguous
matrices, in which case you have to copy it first.

The current implementation of function <mseigvv> is an Householder tridiagonal
reduction followed by a QL algorithm with implicit shifts.

.VP
? (setq m [[ 1.00  3.00  5.00 ] [ 3.00  5.00  6.50 ] [ 5.00  6.50  7.00 ]])
= [[ 1.00  3.00  5.00 ]
   [ 3.00  5.00  6.50 ]
   [ 5.00  6.50  7.00 ]]
? (setq p (copy-matrix m)))
= [[ 1.00  3.00  5.00 ]
   [ 3.00  5.00  6.50 ]
   [ 5.00  6.50  7.00 ]]
?
? ;; operation
? (setq v (mseigvv p)))
= ::MAT:3
? (matrix-print-mode v t)
= t
? v
= [ 0.01 -1.96 14.95 ]
?
? ;; key property
? (m*m m p)
= [[ 0.00 -1.53 -5.72 ]
   [-0.01 -0.42 -8.72 ]
   [ 0.00  1.16 -10.72 ]]
? (mxm p (mrep-dim v 0 3)) 
= [[ 0.00 -1.53 -5.72 ]
   [-0.01 -0.42 -8.72 ]
   [ 0.00  1.16 -10.72 ]]
.PP


#? ** Matrix Files.

When an application needs to use a large data base of training
examples (like speech data...) it is better to format the data into a
format directly readable by Lush. Reading large ASCII files with
Lush programs often is slow. The most efficient way to load large
chunks of data in memory is to read them from a matrix file. There are
basically two types of matrix files: ascii files and binary files, as
described below.


#? (save-matrix  <mat> <file>)
.SEE Binary Matrix File Format.

Stores the matrix <mat> into the binary file <file>.  Argument <file>
may be a filename string or a file descriptor created with
<open-write> or <open-append>. When <file> is a file name, a suffix
<".mat"> is added when needed.


#? (save-ascii-matrix  <mat> <file>)
.SEE Ascii Matrix File Format.

Stores the matrix <mat> into the text file <file>.  Argument <file>
may be a filename string or a file descriptor created with
<open-write> or <open-append>. When <file> is a file name, a suffix
<".mat"> is added when needed.


#? (load-matrix  [<mat>] <file>)
.SEE Binary Matrix File Format.
.SEE Ascii Matrix File Format.
Loads a matrix from file <file> and returns it. This function senses
the file format and performs the adequate actions. If a symbol <mat>
is specified, it stores the new matrix in symbol <mat>.

Argument <file> may be a filename string or a file descriptor created
with <open-read>.  When <file> is a file name, a suffix <".mat"> is
added when needed.


#? (map-matrix [<mat>] <filename>)

This function is available on certain systems only.  It loads a binary
matrix file by mapping the file to certain memory addresses using the
virtual memory facilities provided by the operating system.  This
function is especially handy for handling very large matrices.
Mapped matrices however are always read-only.


#? * Ascii Matrix File Format.

ASCII matrix files are generated with function <save-ascii-matrix>.
These machine independent files are handy for transferring data
between different computers. They tend however to eat a lot of disk
space.

The first line of the file is a matrix header. It is composed of the
letters ``.MAT'', the number of dimensions and the size of each
dimension. The array elements are written then, separated by spaces
and newlines characters.

The following lines display the content of a
valid ascii matrix file.
.VP
        .MAT 2 3 4
         1 -1  1  2  -1  1 -3
         1 -1
         4  0  0
.PP
The same matrix could have been written
in the following, more natural way.
.VP
        .MAT 2 3 4
         1 -1  1
         2 -1  1
        -3  1 -1
         4  0  0
.PP

#? * Binary Matrix File Format.

Binary matrix files are generated with function <save-matrix>. Binary
matrix files begin with a header which describes the type and the size
of the matrix. Then comes a binary image of the matrix.

The core header is a C structure defined as follows :
.VP
struct header {
	int magic;
	int ndim;
	int dim[3];
};
.PP
It can be followed by further <int> when the matrix has more
than 3 dimensions.

The first member, <magic>, of this structure is a ``magic'' number,
which encodes the type of the matrix. This number must be:
.IP
<0x1E3D4C51> for a single precision matrix
.IP
<0x1E3D4C53> for a double precision matrix
.IP
<0x1E3D4C54> for an integer matrix
.IP
<0x1E3D4C56> for a short matrix
.IP
<0x1E3D4C55> for a byte matrix
.IP
<0x1E3D4C52> for a packed matrix
.PP

The second member of this structure, <ndim>, is the number of
dimensions of the matrix. Then come the dimensions themselves in the
array <dim>. If there are more than three dimensions, the array <dim>
is extended to accomodate the extra dimensions.

When the number of dimensions (specified in <ndim>) is greater than 3,
the header is completed by <ndim - 3> further integers.

This header is followed by a binary image of the matrix. Elements are
stored with the last index changing faster, i.e.
.VP
(0,0,0) (0,0,1) (0,0,2) ...  (0,1,0) (0,1,2) etc...
.PP
.IP
as float numbers for single precision matrix
.IP
as double numbers for double precision matrix
.IP
as int numbers for integer matrix
.IP
as short numbers for short matrix
.IP
as unsigned char numbers for byte matrix
.IP
and as char for packed matrix.
.PP

In this latter case, each byte represents a fixed point number between
-8 and +8 (+8 not included), the first 4 bits (most significant
nybble) contain the integral part and the remaining 4 bits contain the
fractional part. It uses a two's complement format. Here are two C
functions which convert a ``compacted fixed point'' number into a
floating point number and back.

.VP
/* Converts a packed number to a float */
float unpack(b)
int b;
{
    if (b & 0x80)
        b |= ~0x7f;
    else
        b &= 0x7f;
    return (float)b / 16.0;
}

/* Converts a float into a single byte packed number */
unsigned char pack(x)
float x;
{
    if (x > 8.0-1.0/16.0)
	return 0x7f;
    else if (x < -8.0)
	return 0x80;
    else
	return x*16;
}


#? ** Foreign Matrix Files.

Most program write their results in specific files under a specific
format. These files always have specific headers which describe the
file type and size. The matrix file formats of Lush are just a
typical example. We have implemented functions for reading and writing
information stored in files created by other programs. These functions
can read binary or text files into a matrix of your choice.


#? * Foreign Binary Matrices.


#? (import-raw-matrix <mat> <file> [<offset>])

This function just reads the contents of file <file> into matrix
<mat>. Accessing the matrix then access this data as single precision
numbers (float), double precision numbers (double), integers (int),
short integers (short), bytes (unsigned char) or packed numbers according
to the type of matrix <mat>.

Argument <mat> must be a matrix freshly created with functions
<matrix>, <dmatrix>, <imatrix>, <smatrix>, <bmatrix> or <pmatrix>. Submatrices
are usually rejected. Argument <file> might be a file name or a file
descriptor created with <open-read>.
When argument <offset> is specified, a header of offset bytes is skipped.

After executing this function, the file descriptor <file> points to
the first byte following the matrix data.

#? (import-raw-dmatrix <f> [<offset>])
.TYPE DE
.FILE miscenv.lsh
This function import a raw float matrix stored in file <f>.
Oppositely to <import-raw-matrix>, it compute themselves the
size of the imported matrix  using <fsize> function.
The file <f> may be either a file name or a file descriptor.
When it is not both exhaustable and rewindable it causes an error.

After executing this function, the file descriptor <file> points to
the first byte following the matrix data.

#? (import-raw-fmatrix <f> [<offset>])
.TYPE DE
.FILE miscenv.lsh
This function import a raw float matrix stored in file <f>.
Oppositely to <import-raw-matrix>, it compute themselves the
size of the imported matrix  using <fsize> function.
The file <f> may be either a file name or a file descriptor.
When it is not both exhaustable and rewindable it causes an error.

After executing this function, the file descriptor <file> points to
the first byte following the matrix data.


#? (import-raw-bmatrix <f> [<offset>])
.TYPE DE
.FILE miscenv.lsh
This function import a raw float matrix stored in file <f>.
Oppositely to <import-raw-matrix>, it compute themselves the
size of the imported matrix  using <fsize> function.
The file <f> may be either a file name or a file descriptor.
When it is not both exhaustable and rewindable it causes an error.

After executing this function, the file descriptor <file> points to
the first byte following the matrix data.


#? (export-raw-matrix <mat> <file>)
Stores the data of the matrix <mat> into the binary file <file>.
Argument <file> may be a filename string or a file descriptor created
with <open-write> or <open-append>. No header is stored.


#? * Foreign Ascii Matrices.


#? (import-text-matrix <mat> <file>)

This function reads numbers in the text file <file> and stores them in
matrix <mat>.  Argument <mat> must be a matrix freshly created with
functions <matrix>, <dmatrix>, <imatrix>, <smatrix, <bmatrix> or <pmatrix>.
Submatrices are usually rejected. Argument <file> might be or a file
descriptor created with <open-read>.

After executing this function, the file descriptor <file> points to
the first non blank character following the matrix data.


#? (export-text-matrix <mat> <file>)

Stores the data of the matrix <mat> into the text file <file>.
Argument <file> may be a filename string or a file descriptor created
with <open-write> or <open-append>. No header is stored.


#? (read-table [<rs> [<ls> [<stop> [<addlast>]]]])
.TYPE DE
.FILE miscenv.lsh
.SEE (read-lineset [<rs> [<ls> [<stop> [<addlast>]]]])

This function scan its input and returns an array.
It is equivalent to:
.VP
(list-to-array (read-lineset rs ls stop) "")
.PP
Default values are designed so that when this function is called
without argument it reads a standard tabulated ascii file of which
lines may be uncomplete; the table is assumed to be limited
in the first empty or space-made line.


#? (write-table <a> [<rs> <ls>])
.TYPE DE
.FILE miscenv.lsh
The function <write-ascii-table> writes on the output a table.
Argument <a> is an array containing only strings or empty lists.
Arguments <rs> and <ls> are strings representing
the row and lines separators.
