<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="Yann LeCun">
   <meta name="Description" content="SN Tutorial">
   <meta name="Keywords" content="SN, sn3.2, Bottou, LeCun"">
   <title>SN Tutorial</title>
</head>
<body text="#000000" bgcolor="#FFFFFF" link="#0000EE" vlink="#551A8B" alink="#FF0000">
<font face="Arial,Helvetica">

<cnter><h1>SN: An Gentle Introduction</h1></center>

<ul>
<li><a href="#Introduction">Introduction</a>
<li><a href="#What is SN good for">What is SN good for</a>
<li><a href="#A tour of the features">A tour of the features</a>
<li><a href="#Libraries">Libraries</a>
<ul>
<li><a href="#Why Lisp">Why Lisp</a>
</ul>
<li><a href="#About this document">About this document</a>
<li><a href="#Getting Started">Getting Started</a>
<ul>
<li><a href="#Getting Help">Getting Help</a>
</ul>
<li><a href="#Basic Syntax">Basic Syntax</a>
<li><a href="#Compiling SN functions">Compiling SN functions</a>
<li><a href="#On-line Documentation">On-line Documentation</a>
<li><a href="#Inline C code">Inline C code</a>
<ul>
<li><a href="#Calling C functions from SN">Calling C functions from SN</a>
<li><a href="#inline C code">inline C code</a>
</ul>
<li><a href="#Multiple file programs and search path">Multiple file programs and search path</a>
<li><a href="#Setting things up">Setting things up</a>
<li><a href="#Vectors, Matrices, and Tensors">Vectors, Matrices, and Tensors</a>
<ul>
<li><a href="#Storages">Storages</a>
<li><a href="#Manipulating Tensors/idx">Manipulating Tensors/idx</a>
<ul>
<li><a href="#creating, cloning, and copying idx">creating, cloning, and copying idx</a>
<li><a href="#tensor iterators">tensor iterators</a>
<li><a href="#reading the parameters of an idx">reading the parameters of an idx</a>
<li><a href="#idx manipulations">idx manipulations</a>
<li><a href="#non-compilable idx functions">non-compilable idx functions</a>
</ul>
<li><a href="#built-in tensor operations">built-in tensor operations</a>
<ul>
<li><a href="#component-wise unary operations">component-wise unary operations</a>
<li><a href="#component wise dyadic operations">component wise dyadic operations</a>
<li><a href="#contracting operations with scalar result">contracting operations with scalar result</a>
<li><a href="#special inner and outer products">special inner and outer products</a>
<li><a href="#backward compatibility ops">backward compatibility ops</a>
</ul>
</ul>
<li><a href="#More on the Compiler">More on the Compiler</a>
<ul>
<li><a href="#Type declaration">Type declaration</a>
<li><a href="#Class compilation, method compilation, and object creation">Class compilation, method compilation, and object creation</a><
<li><a href="#Compilable string support">Compilable string support</a>
<li><a href="#Elementary list compilation support">Elementary list compilation support</a><
<li><a href="#including C header files in compiled C files">including C header files in compiled C files</a>
<li><a href="#dynamically loading shared objects">dynamically loading shared objects</a>
<li><a href="#The dynamic loader">The dynamic loader</a>
<li><a href="#what cannot be compiled">what cannot be compiled</a>
</ul>
<li><a href="#Hints and Tips">Hints and Tips</a>
<li><a href="#Libraries">Libraries</a>
<ul>
<li><a href="#Standard Library">Standard Library</a>
<ul>
<li><a href="#basic library">basic library</a>
<li><a href="#graphics, GUI generator, and graphic tools">graphics, GUI generator, and graphic tools</a>
<li><a href="#Compiler and compiler macros">Compiler and compiler macros</a>
<li><a href="#Obsolete/undocumented">Obsolete/undocumented</a>
</ul>
<li><a href="#"Util" Library files">"Util" Library files</a>
<li><a href="#Vector, Matrix and Tensor libraries">Vector, Matrix and Tensor libraries</a>
<li><a href="#Image processing">Image processing</a>
<ul>
<li><a href="#basic function for various image types">basic function for various image types</a>
<li><a href="#specialized image processing">specialized image processing</a>
<li><a href="#reading/writing image files">reading/writing image files</a>
<li><a href="#miscellaneous image manipulation">miscellaneous image manipulation</a>
</ul>
<li><a href="#learning and neural nets libraries">learning and neural nets libraries</a>
<ul>
<li><a href="#neural net modules">neural net modules</a>
<li><a href="#various unsuported files">various unsuported files</a>
</ul>
<li><a href="#Numerical libraries">Numerical libraries</a>
<li><a href="#OpenGL and SGI-GL interface libraries">OpenGL and SGI-GL interface libraries</a>
<li><a href="#SGI Video interface">SGI Video interface</a>
<li><a href="#Ogre utilities">Ogre utilities</a>
<li><a href="#graphs, grammars, and transducers">graphs, grammars, and transducers</a>
<li><a href="#hierarchical clustering">hierarchical clustering</a>
<li><a href="#stuff for character recognition">stuff for character recognition</a>
<li><a href="#Obsolete, semi-obsolete, experimental, and undocumented stuff">Obsolete, semi-obsolete, experimental, and undocumented stuff</a>
</ul>
<li><a href="#What SN does not have (yet)">What SN does not have (yet)</a>
<li><a href="#"><a name="app-a">Appendix A: .emacs file</a></a>
<li><a href="#Credits and revision history">Credits and revision history</a>
</ul>

<h2><a name="Introduction">Introduction</a></h2>

How many times have you 
<ul>
<li>wished you had simple interpreted language with which you could quickly
try out idea, implement numerical algorithms, or prototype GUI-based
applications?  
<li> written a piece of software in C and wished you could control it from a
simple, interpreted script language?  
<li> ritten such a script language interpreter yourself and wished it 
were a full-blown programming language?  
<li>used an interpreted script-like language, such as Perl, MatLab, 
Mathematica, Tcl, or Visual Basic, and wished it would be easier
to call C routines from it?
<li>written a program with one of the above languages and wished you could
generate a portable standalone application from it? 
<li>wished you could combine two languages for your programming projects: an
efficient, compiled, no-frills language such as C or C++ for the low-level,
and an interpreted, weakly typed language with smart memory management such as
Lisp for the high level and the user interface?
</ul>
<b>If your answer to any of the above questions is ``more than once'', take a
look at SN.</b>
<p>
Many software projects, particularly research projects, require two languages:
an efficient compiled language such as C or C++ for implementing the low-level
or computationally expensive function, and a flexible, possibly interpreted
language for high-level control, scripting, experimentation, and tinkering.  A
popular instance of this is the Matlab system. Unfortunately, the Matlab
interpreted language is very inefficient, and lacks the power of a
full-fledged object-oriented programming language.
<p>
SN is a language that attempts to solve that problem.  SN is an
object-oriented, Lisp-like language with a seamless interface to C.  It has a
large library of matrix algebra routines, numerical routines, graphic
routines, image processing routines, statistics, neural nets, etc... compiled
code and libraries written in C and other languages (.o, .a, or .so files) can
be dynamically loaded into SN and called from the interpreter. SN Lisp
programs can be compiled into C source code, which can be dynamically loaded
back into the interpreter, or compiled separately as a standalone program. In
addition, C code can be freely intermixed with Lisp code, allowing to use each
language for what it does best. 
<p>
The SN compiler has several interesting properties, and a few limitations.  It
compiles Lisp source to C, then uses the machines' C compiler to generate
object code. It then loads the compiled code dynamically into the
interpreter. There are many Lispy things that the compiler can't compile, but
that's a small price to pay for the increased efficiency of what it can
compile. 
<p>
SN Currently runs on SGI/Irix, Linux/x86, and Solaris.

<h2><a name="What is SN good for">What is SN good for</a></h2>

SN is a good tool for a variety of applications. It was originally developed
as an environment for experimentation and development of machine learning
applications (especially neural networks), but over the years, it has grown
into a full-fledged language and rapid development environment.
<p>
Various versions of SN have been operational since 1987. The first version
with a compiler, SN3.1 has been operational since 1994, and the latest version
SN3.2 since April 1999.  It has been used primarily by people in image
processing and machine learning groups in AT\&T research, and in document
processing groups in Bell Labs' Advanced Technology group.
<p>
Here are examples of situations in which we use (or have used) SN:
<ul>
<li> as a simulation environment for neural network and machine 
 learning experiments.
<li> as a Matlab-type prototyping tool for numerical computation, 
 signal processing, image processing, statistical estimation,...
<li> as a "control language" for many software projects.
<li> as a super debugger and diagnostic tool for large applications
<li> as a prototyping tool for GUI-based applications.
<li> as a script language for quick hacks.
</ul>
Here is a small subset of research projects that have been done with SN:
<ul>
<li> numerous projects in handrwiting recognition
<li> many projects in neural network, machine learning, and statistical
 estimations 
<li> data mining, fault detection, and database marketing projects.
<li> image processing research
</ul>

Here are a few examples of full-fledged applications built with SN:
<ul>
<li> the foreground/background segmentation module for the DjVu
  image compression system.
<li> a complete check amount reader now integrated in NCR's automatic
 teller machines and large back-office check reading machines (SN-generated
 code runs on DSP boards). This is a huge piece of complicated code (60,000
 lines of SN Lisp code automatically converted to C).
<li> a neural network simulator and neural network training tool.
<li> A GUI-based controller for ISDN phones and AUDIX.
<li> a pen-based data entry systems with handwriting recognition
</ul>

<h2><a name="A tour of the features">A tour of the features</a></h2>

In addition to all the regular features of a full-fledged programming language
such as conditional statements, loops, local variables, classes, functions,
and macros, SN provides a large number of functions for manipulating lists,
strings, vectors, matrices, and tensors. String functions include such things
as regular expression matching and substitutions. 
<p>
The vector and matrix manipulation engine is extremely powerful and efficient,
making SN ideal for heavy numerical applications and applications such as
signal and image processing. It includes functions to create, resize, and
convert vectors, matrices, and tensors with up to eight dimensions.  It
includes basic matrix operations such as scalar operations on all elements of
a matrix, dot products, outer products, transposition, highly optimized 1D and
2D convolutions. A set of iterators is also provided to sequentially access
matrix elements without requiring costly bound checking.
<p>
SN is an object-oriented language. Classes with methods (accessed
through virtual tables) and slots can be defined and compiled.
Derived classes inherit the slots and methods of their parent class.
<p>
SN includes all the functions familiar to Lisp aficionados, such as list
functions, list iterators, physical list manipulation, macros, displace
macros, symbol manipulation, etc. 
<p>
SN provides a set of simple-to-use, low-level graphic functions to draw lines,
polygons, rectangles, pictures, and text in color, with automatic refresh and
double-buffering capability (for animations). Graphics can be drawn in a
Xwindows window, or sent to a PostScript file, or sent via RPC to a special
version of the public domain drawing program ``Idraw''. Those low-level
graphic functions are used to build high-level functionalities, such as a
function plotting package. SN also contains a very compact and easy-to-use
object-oriented graphical user interface generator called ``Ogre''. Ogre is
entirely written in Lisp and uses the low-level graphic functions mentioned
above. It contains predefined classes for buttons, sliders, radio buttons,
menus, string editors, etc... Ogre includes an automatic mechanism for placing
objects in the window, thereby greatly simplifying the design and
implementation of GUIs. Simple GUIs can be written in extremely short times
and are very compact.
<p>
SN provides two models for Input/Output. One is a set of ``Lispy'' I/O
functions that allow easy input and output of ASCII data, lisp expressions,
lisp objects, and matrices. It includes such goodies as I/O to pipes and
sockets. The other model essentially provides access to the standard C I/O
library, including fopen, popen, fprintf, fscanf, fgetc, fputc fgets, and
various functions for reading and writing matrices.
Large matrices can be mapped in the virtual addressing space, instead of
explicitely loaded in memory. This allows to access very large datasets
efficiently. 

<h2><a name="Libraries">Libraries</a></h2>

SN has a large collection of libraries and utilities available to the
user.  Some are written in Lisp, some are written in C and interfaced
to SN, others are pre-existing libraries that have been interfaced to
SN.
<p>
SN is interfaced to the Numerical Recipes library, which gives access to
commonly used functions, such as linear system solvers, eigenvalue
computations, singular value decompositions, etc. SN also contains a large
library of image processing functions to load, save, resize and resample,
warp, filter, and analyze images. Mathematical morphology operations such as
connected component analysis, distance transform, erosion, and dilation, are
also available for bilevel images.
<p>
SN includes a graph library that allows grammar finite state machine 
construction, graph transduction and composition, and viterbi search
algorithm.
<p>
SN includes a full interface to the industry-standard OpenGL library that
allows the creation of high quality 3D graphics and animations. In fact, SN
interactivity can be used as a tool to learn OpenGL and to quickly build 3D
graphic applications.
<p>
SN includes an extensive library for gradient-based machine learning,
including neural networks, radial basis functions, support vector machines,
and many others. This library is based on an innovative object-oriented design
that allows to build large learning machines out of multiple learning modules
and to train them cooperatively. Commercially used optical recognition systems
have been built with this library.
<p>
As mentioned earlier, SN has the capability of mapping large matrices stored
on disk directly into its virtual address space. It is also interfaced with
the GNU database library gdbm.
<p>
In addition, SN provides an interface to the Silicon Graphics video input
device allowing real-time frame grabbing and processing from various video
sources. 

<h3><a name="Why Lisp">Why Lisp</a></h3>

In the software industry, Lisp is often perceived as an oddity of
essentially academic interest. Its theoretical computer science
heritage also causes common misconceptions about Lisp, such as being
inefficient and difficult to learn.  So why choose Lisp?  We chose
Lisp because of its efficiency, compactness, flexibility, and, last
but not least, its extremely user-friendly syntax and quick learning
curve (though this may be contrary to common prejudice).  Lisp is
probably the easiest language to learn, with the simplest, cleanest,
and most flexible syntax. Our experience with teaching C developers to
use SN is that they become proficient at it in a few days. Script
language designers often make the mistake of not only designing their
own language functionalities, but also designing their own
syntax. Examples of this include MatLab, Mathematica, S+, Perl, and
many others. Why invent a new syntax when a good one such as Lisp
already exists? SN is an object-oriented dialect of Lisp that puts the
emphasis on ease of use, efficiency for numerical operations (unlike
most traditional lisp implementations), and easy interfacing with
existing code written in C.

<h2><a name="About this document">About this document</a></h2>

This document is not a reference manual. The reference manual is
available through SN's on-line help system described below.  This
document is a tutorial, and a way to find out things that are hard to
dig up from the on-line help. The present document has a list of all
the built-in tensor operations, a short description of all the
libraries, and a short introduction to the compiler.
<p>
The on-line help system must be used for reference documentation
on the interpreter (Lists, Predicates, Booleans Operators,
Symbols, Control structures, Functions, Numbers, Strings,
Input / Output, Miscellaneous, Objects, Graphics).

<h2><a name="Getting Started">Getting Started</a></h2>

To start SN, type "sn3.2" at the Unix prompt:
<pre>
  amiga% sn3.2
  SN3.2
   based on SN, (C) Copyright L. Bottou & Y. Le Cun 87 ... 90
   with AT&T extensions, (C) Copyright AT&T 89 ... 95
  
  Version 'sn3.2'
  
  ... loading system file "/home/snwiz/sn3.2/lib/sysenv.sn".
  ... loading file "/home/snwiz/sn3.2/lib/stdenv.sn".
  [/home/snwiz/sn3.2/lib/graphenv.sn]
  [/home/snwiz/sn3.2/lib/idxenv.sn]
  
  ?
</pre>

<h3><a name="Getting Help">Getting Help</a></h3>

SN has an on-line help system that can be invoked by typing "^A"
(which can be type either as Control-A or as Caret and A)
for general help, or "^Atopic" for help on functions or concepts
whose name include "topic":
<pre>
  ? ^Amax
      1.  (draw-value <x> <y> <val> <maxv> <maxs>)
      2.  (gray-draw-list <x> <y> <l> <ncol> <minv> <maxv> <apart> [<cmap>]))
      3.  (max <l_1> ... <l_n>)
      4.  (solve <min> <max> <f>)
  Your choice? 3
  
  ___________________________________________________________________________
  
   (max <l_1> ... <l_n>)                                       DX
  
   Return the maximum element within <l_1> ...  <l_n>.  Arguments <l_i> may be
  numbers or strings.
  ___________________________________________________________________________
  
  Your choice? 
</pre>
The list of symbols whose name contains a particular string can
be listed using "^Ssymbolstring". 

<h2><a name="Basic Syntax">Basic Syntax</a></h2>

The SN syntax is based on Lisp, i.e. everything is a list enclosed in
parentheses, the first element of which is the function and the rest
are the arguments:
<pre>
  ? (+ 3 4)
  = 7
  ? (+ 4 (* 2 3))
  = 10
</pre>
Variables can be created and set with the function <tt>setq</tt>:
<pre>
  ? (setq x 5)
  = 5
  ? (* x x)
  = 25
</pre>
In interpreted mode, the types of the variables need not be declared, though
they must be declared if the code is to be compiled. Variables can be assigned
numbers, matrices and vectors, strings, lists, functions, macros,
various predefined objects (such as functions, windows and files), and
user-defined objects (instances of user-defined classes).
<p>
Functions can be defined using the <tt>de</tt> construct. The form is 
<tt>(de &lt;name&gt; (&lt;arg1&gt;...&lt;argn&gt;) &lt;body&gt;)</tt>.
Here is an example:
<pre>
  ? (de square (x) (* x x))
  = square
  ? (square 4)
  = 16
</pre>
this definition should be interpreted as follows. <tt>de</tt> means "define
function", it is followed by the function name "<tt>square</tt>", a list of
formal argument variables <tt>(x)</tt>, and the body of the function <tt>(* x
x)</tt>, which means multiply <tt>x</tt> by itself and return the result.  The
return value of the function is the value returned by the last evaluation in
the body.  The function can now be called:
<p>
Any function definition can be obtained by typing "^Pfunctionname":
<pre>
  ? ^Psquare
  (de square (x)
    (* x x) )
  = t
</pre>
The directive "^P", like "^A" introduced earlier is a so-called
macro-character. Macro-characters a sepcial combinations of characters that
are translated into function calls by the interpreter. SN has several
predefined macro-characters for reduce typing for several commonly used
interactive functionalities. A particularly useful one is "^Lfilename"
which loads a Lisp source file.
<p>
SN provides traditional loop constructs such as <tt>for</tt>, <tt>while</tt>,
<tt>repeat</tt>, an so on. Here is an example of how to compute the sum of the
first 10 integers. [Naturally this is a very stupid way to compute the su of
the first 10 integer since there is a closed form expression for it] (the
function <tt>incr</tt> increments its first argument by the value of its
second argument, or by 1 if the second argument is not present):
<pre>
  ? (setq z 0)
  = 0
  ? (setq i 0)
  = 0
  ? (while (&lt; i 10) (incr i) (incr z i)) 
  = 55
  ? z
  = 55
</pre>
Encapsulating the above code in a function requires the use of a local variable
which can be done with the <tt>let*</tt> construct:
<pre>
  ? ;; compute the sum of the first n integers
  ? (de first-sum (n) 
        (let* ((z 0) (i 0)) (while (&lt; i 10) (incr i) (incr z i))))
  = first-sum
  ? (first-sum 10)
  = 55
</pre>
In SN, text that follow one or several semi-colons on a line are
taken as comment and ignored by the interpreter.
The <tt>let*</tt> construct is used as follows: 
<pre>
  (let* ((&lt;var1&gt; &lt;value1&gt;) ... (&lt;varN&gt; &lt;valueN&gt;)) 
        &lt;body1&gt; ... &lt;bodyP&gt;)
</pre>
which is equivalent to the C construct:
<pre>
  { &lt;type1&gt; &lt;var1&gt; = &lt;value1&gt;; 
    ... 
    &lt;typeN&gt; &lt;varN&gt; = &lt;valueN&gt;; 
    &lt;body1&gt;
    ....
    return &lt;bodyP&gt;
  }
</pre>

<h2><a name="Compiling SN functions">Compiling SN functions</a></h2>

The <tt>first-sum</tt> function defined above can be compiled, but that
requires specifying the type of the variables (so that the compiled code need
not do inefficient run-time type checking). The compilable definition for
<tt>first-sum</tt> is:
<pre>
  ? ;; define the function
  ? (de first-sum (n)
        ((-int-) n)
        (let* ((z 0) (i 0))
	  ((-int-) z i)
          (while (&lt; i n) (incr i) (incr z i)))))
  = first-sum
</pre>
The lines <tt>((-int-) n)</tt> and <tt>((-int-) z i)</tt> declare the type of
the argument <tt>n</tt> and the local variables <tt>z</tt>, and <tt>i</tt> as
integers.  Before we compile the function, let's measure the number of CPU
seconds required to compute the sum of the first 100000 integers in
interpreted mode (this is on a 300MHz PII running Linux):
<pre>
  ? (time (first-sum 100000))
  = 0.5
</pre>
We can compile the function by simply typing <tt>(dhc-make "junk"
first-sum)</tt>.  SN will translate the Lisp code into C and write the C source
into the file "junk.c". The C compiler will then compile the code and generate
the object file "OBJS/<os>/file.o", where <os> is the name of the architecture
on which SN is run (LINUX86, SGI, SOLARIS...). This allows to maintain object
files for different architectures in a single source directory tree.  Then,
SN's dynamic loader will automagically load the object code back into the
interpreter.
<pre>
  ? (dhc-make "junk" first-sum)
  Preprocessing first-sum...
  ...Done
  Parsing types for first-sum...
  ...Done
  Generating C code first-sum...
  ...Done
  "cc -I/home/snwiz/sn3.2/include -I. -c -DSGI -O -float -o OBJS/SGI/junk.o C/junk.c" 
</pre>
Now let's see how many CPU seconds it takes to execute the compiled version of
the code. We need to repeat the code 1000 times to get a meaningful figure:
<pre>
  ? (time (repeat 1000 (first-sum 100000)))
  = 1.01
</pre>
The speedup is approximately 2000. Of course, it's not always that
good, it is usually more in the 50-100 range, but it's usually just as
fast as C.  An important point to remember is that the interpreter
always treats numbers as double precision floating point, while
numbers in compiled code a treated as specified by their type
declaration.  SN understands the following scalar types: <tt>-ubyte-,
-byte-, -short-, -int-, -float-, -double-, -bool-, -gptr-</tt>.  they
correspond respectively to the C types <tt>unsigned char, signed char,
short, int, float, double, unsigned char, void*</tt>.
<p>
Now let's look at the C code generated by SN's Lisp to C compiler in
<tt>junk.c</tt>:
<pre>
  int 
  C_first_sum (L1_n)
  int L1_n;
  {
    TRACE_PUSH ("C_first_sum");
    {
      int L_Tmp0;
  
      {
        int L2_1_z;
        int L2_2_i;
  
        L2_1_z = 0;
        L2_2_i = 0;
        L_Tmp0 = 0;
  /* While loop */
        goto L_1;
      L_0:
        {
  	L2_2_i = (L2_2_i + 1);
  	L2_1_z = (L2_1_z + L2_2_i);
  	L_Tmp0 = L2_1_z;
        }
  /* While loop test */
      L_1:
        {
  	if ((L2_2_i &lt; L1_n))
  	  goto L_0;
        }
      }
      TRACE_POP ("C_first_sum");
      return L_Tmp0;
    }
  }
</pre>
Pretty simple and straightforward code.
<p>
The normal way to write SN code is to open a file, say "toto.sn", in your
favorite editor, and to write all the necessary function definitions and
compilation instructions in it. The file can then be loaded into the
interpreter with <tt>(load "toto")</tt>. For example, an SN file for the above
function would contain:
<pre>
  ;; a function that computes the sum of the first n integers.
  (de first-sum (n)
      ((-int-) n)
      (let* ((z 0) (i 0)) 
        ((-int-) z i)
        (while (&lt; i n) (incr i) (incr z i))))
  
  ;; compile the function to toto.c and toto.o
  ;; if the first arg is nil, the .c file has the same 
  ;; base name as the file being loaded.
  (dhc-make () toto)
</pre>
When loading this file, SN processes its content as if it were typed at the
prompt. The compilation into C and object code will only be executed if the
source file <tt>toto.sn</tt> has been modified since the last compilation.
The use of GNUemacs to edit SN files is very strongly recommended as
it has a special Lisp mode that flashes matching parentheses, highlights
keywords and comments, and automatically indents Lisp expressions (using
ALT-CTRL-Q). More details on how to setup Emacs are given in
the "setting things up" section.

<h2><a name="On-line Documentation">On-line Documentation</a></h2>

As we said earlier, SN possesses an on-line help system. This system can be
used by SN users to document their own programs. Its use is strongly
recommended. Documenting functions or other objects
can be done with the ``#?'' macro-character. Here is what <tt>toto.sn</tt> should
have looked like in the first place:
<pre>
  #? (first-sum &lt;n&gt;)
  ;; computes the sum of the first &lt;n&gt; integers.
  (de first-sum (n)
      ((-int-) n)
      (let* ((z 0) (i 0)) 
        ((-int-) z i)
        (while (&lt; i n) (incr i) (incr z i))))
  
  ;; compile the function to toto.c and toto.o
  (dhc-make "toto" toto)
</pre>
The string after the ``#?'' is what will be searched when "^A" is invoked at
the lisp prompt. Contiguous comment lines immediately following the "#?"
line constitute the text of the help. After this file is loaded, the on-line
help for <tt>first-sum</tt> can be displayed:
<pre>
  ? ^Asum
      1.  (first-sum &lt;n&gt;)
      2.  (sum &lt;l&gt;)
  Your choice? 1
  
  ______________________________________________________________________________
  
   (first-sum &lt;n&gt;)                                             DE    toto.sn
  
   computes the sum of the first &lt;n&gt; integers.
  ______________________________________________________________________________
  
  Your choice? 
  = ()
</pre>

<h2><a name="Inline C code">Inline C code</a></h2>

The ability to freely mix Lisp and C code is one of the most
interesting properties of SN.

<h3><a name="Calling C functions from SN">Calling C functions from SN</a></h3>

Let's say you have written a C file called <tt>titi.c</tt> with the 
following content:
<pre>
  float sq(float x)
  {
    return x*x;
  }
</pre>
You have compiled the file and produced the object file <tt>titi.o</tt>.
Calling <tt>sq</tt> from the SN interpreter is as simple as the following.
First, dynamically load the object file into SN
<pre>
  ? (mod-load "titi.o")
</pre>
then, write a lisp function whose only purpose is to call <tt>sq</tt>.
To be able to call C from SN, we need to load the "cmacro" library.
<pre>
  ? (mload "cmacro")
  [/home/snwiz/sn3.2/util/cmacro.sn]
  = "/home/snwiz/sn3.2/util/cmacro.sn"  
  ? (de square (x) ((-float-) x) 
        (cheader "extern float sq(float);")
        (float #{ sq( $x ) #} )
</pre>
Here is what the above means: <tt>(de square (x) ...)</tt> means define a new Lisp
function called <tt>square</tt> with a single argument <tt>x</tt>.
<tt>((-float-) x)</tt> simply declares <tt>x</tt> as float.  <tt>(float
....)</tt> converts its argument to float (like a cast in C).  The sequence
<tt>#{ .... #}</tt> allows to insert C code within Lisp code.  Therefore
<tt>#{ sq( $x ) #}</tt> simply calls the C function <tt>sq</tt> and returns
the result.  Lisp variables can be inserted in in-line C code by prepending a
Dollar sign, thus <tt>$x</tt> refers to the Lisp float variable <tt>x</tt>.  
The <tt>cheader</tt> directive allows one to include a string in the "header"
section of the C files generated by the Lisp to C compiler. We use it here
to specify the type of the argument and the return value of <tt>sq</tt>.
<p>
We can now compile the above function using:
<pre>
  ? (dhc-make "junk" sq)
</pre>
Two file <tt>junk.c</tt> and <tt>junk.o</tt> will be generated with the C
source and the object code for <tt>square</tt>.  Now <tt>square</tt> can be
called from the Lisp interpreter:
<pre>
  ? (square 5)
  = 25
</pre>
In the above example, the <tt>float</tt> casting function was used to
tell the compiler what type the returned value has.  The following
"cast" functions are available: <tt>number, flt, float, int, real,
double, bool, gptr</tt>.  These functions cast their argument to the
corresponding type.

<h3><a name="inline C code">inline C code</a></h3>

If we do not have a ready-made C file for our function, we can use
the inline C capability to write to function in C right in the Lisp
function. Here is how we could write the <tt>first-sum</tt> function
this way:
<pre>
  (de first-sum (n)
      ((-int-) n)
      (let ((r 0))
        ((-int-) r)
        #{ { int z, i;
             z=0; i=0;
	     while ( i < $n ) { i++; z += i; };
	     $r = z;
	    }
	 #}
         r))
  (dhc-make () first-sum)
  Preprocessing first-sum...
  ...Done
  Parsing types for first-sum...
  ...Done
  Generating C code first-sum...
  ...Done
  "cc -I/home/snwiz/sn3.2/include -I. -c -DLINUX86 -O -o OBJS/LINUX86/first_sum.o first_sum.c" 
  = (first-sum)
  ? (time (repeat 1000 (first-sum 100000)))
  = 0.77
</pre>
That's about 23 percent faster than the full lisp version.

<h2><a name="Multiple file programs and search path">Multiple file programs and search path</a></h2>

Sometimes, a Lisp program requires other Lisp files to be loaded in order to
run. For example imagine that we have written a set of signal processing
functions in the file <tt>"/usr/yann/sn/dsp.sn"</tt>, and now we are writing a
program <tt>"tutu.sn"</tt> that uses some of those functions.  The beginning of
<tt>"tutu.sn"</tt> would look like the following
<pre>
  #? File "tutu.sn"
  ;; my really cool dsp application
  
  (load "/usr/yann/sn/dsp")
  .....
</pre>
(the <tt>.sn</tt> extension is automatically added if required).  However, if
<tt>"tutu.sn"</tt> is loaded by other programs that also load <tt>"dsp.sn"</tt>
on their own, <tt>"dsp.sn"</tt> will be loaded several times.  This can be
alleviated by using the function <tt>mload</tt> which loads a file only if it
has not been loaded before.
<pre>
  #? File "tutu.sn"
  ;; my really cool dsp application
  
  (mload "/usr/yann/sn/dsp")
  .....
</pre>
Putting absolute path names in a program is generally a bad idea since
programs have a pernicious tendency to move from time to time.  The solution
is to rely on SN's search path mechanism. When any loading directive is
executed, SN looks for the file in the current directory, and then in the
search path. The default search path includes the <tt>"sn3.2/lib"</tt> and
<tt>"sn3.2/util"</tt> that contain the standard libraries. The search path
can be user-extended with the <tt>addpath</tt> function:
<pre>
  (addpath "/usr/yann/sn")
</pre>
now, loading <tt>"dsp.sn"</tt> only requires:
<pre>
  (mload "dsp")
</pre>

<h2><a name="Setting things up">Setting things up</a></h2>

To use SN comfortably, most people rely on one of two methods:
running SN within "fep", or running it withing Emacs.
<p>
<tt>fep</tt>, which stands for front-end processor, is a standard
Unix utility that adds history and command-line edition capabilities
to any commend line-based program.
<p>
Most people will prefer to run SN from within Emacs.  To make this
convenient, a few lines should be included in your .emacs file so as
to correctly format and indent SN Lisp code, hilite the commands
apropriately, and automatically turn on the SN Lisp mode whenever an
SN file is loaded. Such additions to the .emacs file are given in <a
href="#app-a">appendix A</a>.
<p>
Then, in your bin directory, make a symbolic link from "lisp"
to the SN executable:
<pre>
amiga% ln -s /home/snwiz/sn3.2/bin/SGI/sn3.2 /home/yann/bin/lisp
</pre>
When in Emacs, type "ESC-X run-lisp" (or M-X run-lisp).
This will start SN in the directory of the current buffer file.
<p>
It is convenient to split the Emacs window into two. 
The bottom window will be the SN execution buffer (called
"*inferior-lisp*) while the top window will contain the
SN source file being worked on.
<p>
Emacs provides nice commands for Lisp programming. Among them
are C-M-e (Ctrl-Meta-e) to jump to the end of a function, 
C-M-a to jump to the beginning, C-M-q to indent/format
a function,and C-M-x to send the function or expression in 
which the cursor is to the interpreter (assuming it is 
running in the *inferior-lisp* buffer).

<h2><a name="Vectors, Matrices, and Tensors">Vectors, Matrices, and Tensors</a></h2>

SN's piece de resistance is its matrix engine. SN can operate
on scalars, vectors, matrices, or high-dimensional tensors from
0 to 8 dimensions. creating a tensor of <tt>float</tt> is done simply with:
<pre>
  ? (setq m (matrix 10 8 4))   ; create 3d matrix
  = ::INDEX3:<10x8x4>
  ? (m 3 4 2 45.6)       ; set value of element (3,4,2) to 45.6
  = ::INDEX3:<10x8x4>
  ? (m 3 4 2)            ; get value of element (3,4,2).
  = 45.6
</pre>
Tensors of various basic types can be created with the following functions.
Each function has two versions, the regular version initializes all the
elements to zero, while the version with <tt>-nc</tt> at the end do not
(no clear). All of these functions take 0 to 8 integer arguments that
are the sizes in each dimension:
<ul>
<li><tt>double-matrix, double-matrix-nc, real-matrix, real-matrix-nc</tt>: doubles
<li><tt>float-matrix, float-matrix-nc, flt-matrix, flt-matrix-nc</tt>: floats
<li><tt>int-matrix, int-matrix-nc</tt>: 32-bit ints
<li><tt>short-matrix, short-matrix-nc</tt>: 16-bit shorts
<li><tt>byte-matrix, byte-matrix-nc</tt>: 8-bit bytes
<li><tt>ubyte-matrix, ubyte-matrix-nc</tt>: 8-bit unsigned bytes
<li><tt>gptr-matrix, gptr-matrix-nc</tt>: generic pointers (void*)
</ul>
Matrices are really composed of two data structures: 
<ul>
<li>the <tt>storage</tt> or <tt>srg</tt> which contains the actual data,
an element type identifier (and the size thereof), and flags that indicate 
if the data is writable or not, if it is in RAM or memory-mapped from 
a file, etc.
<li>the <tt>index</tt> or <tt>idx</tt> which contains a pointer to the 
<tt>storage</tt>, as well as the number of dimensions of the tensor,
the size in each dimension, the address increment from one element to
the next in each dimension (called <tt>modulo</tt>), and the offset
of the first tensor element in the storage.
</ul>

<h3><a name="Storages">Storages</a></h3>

Storages and idx can be created independently of each other.
So for example <tt>(new-index (new-d-storage 12) '(3 4))</tt>
creates a storage of "doubles" of size 12, then creates a new
idx of size (3,4) on this storage. This allows to access the same
piece of data in multiple ways.
Below are the functions to allocate storages. 
None of them can be called in compiled code.
Calling them without argument <tt>(new-xxx-storage)</tt>
will return an unsized storage, which can subsequently
be sized, or mapped to a file with <tt>(storage-mmap</tt>.
Calling them with one integer argument will allocate the 
corresponding number of elements in memory:
<ul>
<li><tt>new-real-storage</tt> doubles
<li><tt>new-float-storage, new-flt-storage</tt> floats
<li><tt>new-int-storage</tt> 32-bit ints
<li><tt>new-short-storage</tt> 16-bit shorts
<li><tt>new-byte-storage</tt> 8-bit bytes
<li><tt>new-ubyte-storage</tt> 8-bit unsinged bytes
<li><tt>new-gptr-storage</tt> generic pointers (void *)
<li><tt>new-at-storage</tt> lisp objects
</ul>
Storage elements can be accessed as with vectors.
Storages can be sized, resized, cleared, loaded from a file, memory-mapped from a file,
and saved with the following functions (none of which can be called in compiled code):
<ul>
<li><tt>(storage-malloc s n)</tt> allocates <tt>n</tt> elements. 
  Storage <tt>s</tt> must be unsized
<li><tt>storage-malloc-nc</tt> same as above, but does not clear the memory
<li><tt>(storage-realloc s n)</tt> resizes an already allocated storage. The new size
  can be smaller or larger than the original size. The data will be copied, and the
  new area cleared.
<li><tt>storage-realloc-nc</tt> same, but new area is not cleared
<li><tt>(storage-mmap s f [o])</tt> memory-maps file <tt>f</tt> into storage <tt>s</tt>.
  Optional argument <tt>o</tt> is the byte offset in the file at which the
  storage is mapped.
<li><tt>(storage-clear s)</tt> clears storage s
<li><tt>(storage-load s f)</tt> loads storage file <tt>f</tt> into storage <tt>s</tt>.
  Storage <tt>s</tt> will be resized to the apropriate size.
<li><tt>(storage-save s f)</tt> save storage <tt>s</tt> into file <tt>f</tt>
<li><tt>(storage-read-only s)</tt> marks <tt>s</tt> as read only. Attempts to write
  into it will cause and error.
<li><tt>(storage-size s)</tt> returns the size of storage <tt>s</tt>
<li><tt>(storagep s)</tt> returns <tt>t</tt> (true) iff <tt>s</tt> is a storage.
</ul>

<h3><a name="Manipulating Tensors/idx">Manipulating Tensors/idx</a></h3>

Several functions are provided to create and 
manipulate the "idx" structures.

<h4><a name="creating, cloning, and copying idx">creating, cloning, and copying idx</a></h4>
<ul>
<li><tt>(new-index s dimlist</tt> creates a new idx on storage <tt>s</tt>. The
dimensions of the idx are given in <tt>dimlist</tt>. The storage is resized
if needed.
<li><tt>(idx-storage m)</tt> returns storage of idx <tt>m</tt>
<li><tt>(idx-clone m)</tt> make a clone of idx <tt>m</tt> (a copy of <tt>m</tt>
  that points to the same storage).
<li><tt>(copy-matrix m [r])</tt> returns a fresh copy of tensor <tt>m</tt>.
 if <tt>r</tt> is present, <tt>m</tt> is copied into <tt>r</tt> with apropriate
 type conversion if necessary.
<li><tt>(copy-any-matrix m [r])</tt> copy a tensor of any structure and type into
a tensor of a possibly different structure an type, as long as it has the
same number of elements.
<li><tt>submatrix</tt> obsolete way of defining a submatrix, 
  use <tt>narrow</tt> instead.
<li><tt>clone-matrix</tt> obsolete function for making a copy of a matrix of floats.
</ul>

<h4><a name="tensor iterators">tensor iterators</a></h4>

SN provides efficient iterators to cycle over dimensions of a tensor.
It is almost always better to use those iterators, rather than a regular
loop with regular access to array elements because the latter method causes
an array bound checking at each access, while the former doesn't.
<ul>
<li><tt> (idx-bloop ((s1 idx1) [ (s2 idx2) [...(sn idxn) ]]) body)</tt> 
  make each <tt>si</tt> be an idx with one less dimension than the
  corresponding <tt>idxi</tt>, and which simulataneously loops over the
  successive "slices" of <tt>idxi</tt> for each possible value of the
  first index. Execute <tt>body</tt> for each value.  
<li><tt> (idx-bloop ((s1 idx1) [ (s2 idx2) [...(sn idxn) ]]) body)</tt> 
  same as above, but loops over the last dimension.
<li><tt>(cidx-bloop (i_1 [i_2...i_n] (c_1 l_1) [(c_1 l_1)...(c_m l_m)) p_1 [p_2...])</tt>
  This is a idx-bloop which will loop over the n first dimensions of idxs <tt>l_1</tt>
  to <tt>l_m</tt>.  The loop counters are strings (such as "i" "j") and are specified
  by <tt>i_1</tt> to <tt>i_n</tt>.  During each iteration, the C variables provided 
  in <tt>c_1</tt> to <tt>c_m</tt> will point to the appropriate values in the 
  idxs <tt>l_1</tt> to <tt>l_m</tt>.  For example, the following function will 
  fill matrix a with cos(i+j).
  <pre>
    (de foo (a)
       ((-idx2- (-flt-)) a)
       (cidx-bloop ("i" "j" ("a" a)) #{ *a = cos(i+j); #}) a)
  </pre>
  The return value is (like in idx-bloop) the last idx specified in the
  declaration (in the example above, the return value is superfluous).  
  Here is another (ugly) example for using cidx-bloop (note that absence of typing):
  <pre>
    (dmd idx-m1fill (a v)
      '(cidx-bloop ("i" ("a" `a)) (cinline "*a = %s;" `v)))
  </pre>
  The return value can be used directly as in:
  <pre>
     (let ((a (idx-m1fill (matrix-nc n) value)))
           [...]
     )
  </pre>
  Note that each idx <tt>l_1</tt> to <tt>lm</tt> should have at least <tt>n</tt> 
  dimensions, but can have more (only the first <tt>n</tt> dimensions will be looped on).
</ul>

<h4><a name="reading the parameters of an idx">reading the parameters of an idx</a></h4>
<ul>
<li><tt>(idx-ndim m)</tt> return number of dimensions.
<li><tt>(idx-dim m n)</tt> return size of n-th dimension.
<li><tt>(idx-modulo m n)</tt> return number of elements that separate two 
  successive elements in the n-th dimension.
<li><tt>(idx-offset m)</tt> return offset of first element of <tt>m</tt> in storage.
<li><tt>(idx-size m)</tt> return size of memory are used by idx data in bytes.
<li><tt>(idx-storage m)</tt> return storage pointed t by <tt>m</tt>.
<li><tt>(contiguep m)</tt> returns true if the elements of <tt>m</tt> are
  contiguous in memory.
</ul>

<h4><a name="idx manipulations">idx manipulations</a></h4>
<ul>
<li><tt>(narrow m n s [o])</tt> make a clone of idx <tt>m</tt>, and reduce it
  size in the n-th dimension to <tt>s</tt> elements, offset by <tt>o</tt>.
<li><tt>(select m n s)</tt>  return a clone of <tt>m</tt>, with the n-th
  dimension removed, and which is the s-th "slice" of <tt>m</tt>, 
  in the n-th dimension.
<li><tt>(unfold m n ksize step)</tt>  Return an idx with an added dimension 
 at the end of m obtained by "unfolding" n-th dimension.  The size of the new 
 dimension is ksize.  A subsampled convolution of kernel size ksize and stride 
 step can be done by calling <tt>(idx-m2dotm1 this-unfolded-idx kernel)</tt>:
 <pre>
   ? (unfold [3 4 5 6 7] 0 5 1)
   = [[ 3.00  4.00  5.00  6.00  7.00 ]]
   ? (unfold [3 4] 0 1 1)      
   = [[ 3.00 ]
      [ 4.00 ]]
 </pre>
<li><tt>(idx-transclone m dimlist)</tt> return a clone of idx <tt>m</tt> where
  the dimensions have been permuted according to the list of dimension indices
  <tt>dimlist</tt>. For example <tt>(idx-transclone m '(0 2 1))</tt> permutes
  the second and third dimensions.
<li><tt>transpose</tt> obsolete transpose function superseded by idx-transclone.
<li><tt>(diagonal m d)</tt>  return a clone of <tt>m</tt> where the modulos
  and dimensions have been hacked  so as to grab the diagonal of the last 
  d dimensions.  The result has d-1 less dimensions than the original idx.
<li><tt>(idx-narrow m n s [o])</tt> like narrow, but hack <tt>m</tt> "in place"
  instead of returning a hacked clone.
<li><tt>(idx-changedim m n v)</tt> change size of n-th dimension of <tt>m</tt> 
  to <tt>v</tt>
<li><tt>(idx-changemod m n v)</tt> change modulo of n-th dimension of <tt>m</tt> 
  to <tt>v</tt>
<li><tt>(idx-changeoffset m n)</tt> change offset of <tt>m</tt> in its storage
  to <tt>n</tt>
</ul>

<h4><a name="non-compilable idx functions">non-compilable idx functions</a></h4>
<ul>
<li><tt>idx-bound 	</tt>
<li><tt>bound    	</tt>
<li><tt>idx-nelements 	</tt>
<li><tt>idx-redim 	</tt>
<li><tt>idx-same-size 	</tt>
<li><tt>idx-select 	</tt>
<li><tt>idx-size-or-check </tt>
<li><tt>idx-transpose	</tt>
<li><tt>idx-transpose2 	</tt>
<li><tt>idx-undim 	</tt>
<li><tt>idx-unfold	</tt>
<li><tt>idx-inv		</tt>
<li><tt></tt>
</ul>

<h3><a name="built-in tensor operations">built-in tensor operations</a></h3>

These are the tensor operation that are available at startup.
These functions operate on tensors of all types with up to
3 dimensions. They all take either <tt>n</tt> or <tt>n+1</tt>
arguments (with n from 1 to 3). With <tt>n</tt> arguments,
the result is computed and returned. With <tt>n+1</tt> arguments
the result is written in the last argument (which must have the
right type and size). Many more tensor operators are available 
in the various libraries.
<h4><a name="component-wise unary operations">component-wise unary operations</a></h4>
<ul>
<li><tt>(idx-abs m [r])</tt> absolute value
<li><tt>(idx-atan m [r])</tt> arctangent
<li><tt>(idx-clear m [r])</tt> set to 0
<li><tt>(idx-copy m [r])</tt> copy elements
<li><tt>(idx-cos m [r])</tt> cosine
<li><tt>(idx-dexpmx m [r])</tt> fast approximation of derivative of <tt>exp(-x)</tt> 
  using ratio of polynomials
<li><tt>(idx-dstdsigmoid m [r])</tt> fast approximation of the derivative of SN's 
  standard sigmoid function using ratios of polynomials
<li><tt>(idx-exp m [r])</tt> exponential
<li><tt>(idx-expmx m [r])</tt> fast approximation of <tt>exp(-x)</tt> using ratio 
  of polynomials
<li><tt>(idx-log m [r])</tt> natural logarithm
<li><tt>(idx-minus m [r])</tt> change sign
<li><tt>(idx-qdtanh m [r])</tt> fast approximation of derivative of hyperbolic 
  tangent using ratios of polynomial
<li><tt>(idx-qtanh m [r])</tt>  fast approximation of hyperbolic tangent using ratios 
  of polynomial
<li><tt>(idx-sin m [r])</tt> sine
<li><tt>(idx-sqrt m [r])</tt>
<li><tt>(idx-stdsigmoid m [r])</tt> fast approximation of SN's standard sigmoid
  function using ratios of polynomials
</ul>

<h4><a name="component wise dyadic operations">component wise dyadic operations</a></h4>
<ul>
<li><tt>(idx-add m1 m2 [r])</tt> add two tensors
<li><tt>(idx-addm0 m s [r])</tt> add scalar <tt>s</tt> to each element of tensor <tt>m</tt>
<li><tt>(idx-addm0acc m s r)</tt> add scalar <tt>s</tt> to tensor <tt>m</tt>,
  and accumulate result in <tt>r</tt>
<li><tt>(idx-div m1 m2 [r])</tt> divide elements of <tt>m1</tt> by those of <tt>m2</tt>
<li><tt>(idx-dotm0 m1 s [r])</tt> multiply scalar <tt>s</tt> by each element of 
  tensor <tt>m</tt>
<li><tt>(idx-dotm0acc m1 s r)</tt> multiply scalar <tt>s</tt> by each element of 
  tensor <tt>m</tt> and accumulate result in <tt>r</tt>
<li><tt>(idx-mul m1 m2 [r])</tt> compoenet-wise multiply 
<li><tt>idx-sub </tt> subtract two tensors
</ul>

<h4><a name="contracting operations with scalar result">contracting operations with scalar result</a></h4>

The following functions include dot products, distances, sums of terms, etc
and return scalars. These operations "contract" all the dimensions, i.e. the
generalized dot product of two tensors is the sum of all the products of 
corresponding terms in the two tensors.
<ul>
<li><tt>(idx-dot m1 m2 [r])</tt> generalized dot product: computes sum of products of 
  terms of <tt>m1</tt> and <tt>m2</tt>
<li><tt>(idx-dotaccm1 m2 r)</tt> same as above, but accumulates result into <tt>r</tt>
<li><tt>(idx-inf m [r])</tt> smallest element of <tt>m</tt>
<li><tt>(idx-infacc m r)</tt> accumulate smallest element of <tt>m</tt>
<li><tt>(idx-sqrdist m1 m2 [r])</tt> sum of squared differences between terms of
  <tt>m1</tt> and terms of <tt>m2</tt>
<li><tt>(idx-sqrdistacc m1 m2 r)</tt> same as above, but result is accumulated 
  in <tt>r</tt>
<li><tt>(idx-sum m [r])</tt> sum of all terms of <tt>m</tt>
<li><tt>(idx-sumacc m r)</tt> accumulating version of the above 
<li><tt>(idx-sumsqr m [r])</tt> sum of squares of terms of <tt>m</tt>
<li><tt>(idx-sumsqracc m r)</tt> accumulating version of the above 
<li><tt>(idx-sup m [r])</tt> largest value in <tt>m</tt>
<li><tt>(idx-supacc m r)</tt> accumulating version of the above  
</ul>

<h4><a name="special inner and outer products">special inner and outer products</a></h4>

The following functions are available only for tensors of floats.
<ul>
<li><tt>(idx-m1extm1 m1 m2 [r])</tt> outer product of vectors <tt>m1</tt> and 
  <tt>m2</tt>. Rij = M1i x M2j
<li><tt>(idx-m1extm1acc m1 m2 r)</tt> accumulating version of the above  
<li><tt>(idx-m2dotm1 m v [r])</tt> matrix-vector multiply. Rij = sum_k Mik x Vk
<li><tt>(idx-m2dotm1acc m v r)</tt> accumulating version of the above  
<li><tt>(idx-m2extm2 m1 m2 [r])</tt> outer product of matrices <tt>m1</tt> and 
  <tt>m2</tt>. result is a 4D tensor. Rijkl = M1ij x M2kl
<li><tt>(idx-m2extm2acc m1 m2 r)</tt> accumulating version of the above  
<li><tt>(idx-m4dotm2 m v [r])</tt> 4D-tensor by matrix multiply. result
  is a 2D matrix. Rij = sum_kl Mijkl x Vkl
<li><tt>(idx-m4dotm2acc m v r)</tt> accumulating version of the above  
</ul>

<h4><a name="backward compatibility ops">backward compatibility ops</a></h4>

these are only provided for backward compatibility 
with previous versions of SN.
<ul>
<li><tt>(m*m m1 m2)</tt> matrix multiplication
<li><tt>(m+m m1 m2)</tt> matrix addition
<li><tt>(mxm m1 m2)</tt> term by term multiplication
<li><tt>(m-m m1 m2)</tt> matrix subtraction
<li><tt>(m*c m1 c)</tt> multiplication by a constant
<li><tt>(m+c m1 c)</tt> addition of a constant
<li><tt>transpose</tt> matrix transpose
</ul>


<h2><a name="More on the Compiler">More on the Compiler</a></h2>

The main compilation function is <tt>dhc-make</tt>. <tt>dhc-make</tt>
compiles a set of lisp functions and classes to C, then calls the C
compiler, then loads the object file dynamically into the
interpreter. <tt>dhc-make</tt> takes a list of arguments, the first of
which is either a string or a null list.  If it is a string it will be
used as the base name of the .c file. The .c file will be placed in
the current directory, or in the C directory in the current directory
if such a directory exists. If the first argument is a nil, the name
of the compiled class or function which appears last is used as the
file name, unless the <tt>dhc-make</tt> occurs in a file being loaded,
in which case the name for the C source is the same as the name of the
file being loaded, but with a ".c" suffix. The object file is placed
in the OBJS/(OS) directory in the current directory, where (OS) is the
name of the operating system and architecture of the machine
(e.g. SGI, LINUX86, SOLARIS). This allows to use the same source tree
location for binaries on multiple platforms.
<p>
If the call to <tt>dhc-make</tt> occurs in a file being loaded, the
modification date of the file being loaded is compared with the date
of the C source and object file that would be generated by the
"dhc-make" command.  If the object file is more recent, it is simply
loaded and no compilation occurs.  If the object file is older or does
not exist, the C source is recompiled.  If the C source is older or
does not exist, the C source is regenerated, compiled, and loaded.
<p>
The remaining arguments to "dhc-make" are either symbols or lists.  If
an argument is a symbol, the symbol is treated as the name of a
function to be compiled.  If an argument is a list, the list is
expected to contain a class as its car, and an (optional) list of
methods as its cdr.  All arguments are compiled in the order they
appear in the <tt>dhc-make</tt> call.  All methods of a class are
compiled in the order listed.  Here are Some examples:
<ul>
<li><tt>(dhc-make () foo)</tt>  Function "foo" is compiled and 
source is written to the file "foo.c" or "C/foo.c".
<li><tt>(dhc-make "bar" foo)</tt> Function "foo" is compiled 
and source is written to the file "bar.c" 
<li><tt>(dhc-make () foo bar)</tt> Functions "foo" and "bar" 
are both compiled into the file "bar.c"
<li><tt>(dhc-make () foo bar (mark1 mark1 meth1 meth2)</tt> 
Functions "foo" and "bar", and class "mark1" with constructor ("mark1")
and methods ("meth1" and "meth2") are all compiled and placed in the file
"mark1.c"
<li><tt>(dhc-make "bar" foo (mark1 meth1 mark1 meth2) bar)</tt>Similar 
to #4. However, the constructor appears second in the methods
list in the C code.  The function "bar" is actually compiled after the
class "mark1" in this case, and all code is place in the file "bar.c"
</ul>

<h3><a name="Type declaration">Type declaration</a></h3>

The compiler understands the following built-in types:
<ul>
<li><tt>-real-, -double-</tt> double precision floating point
<li><tt>-flt-, -float-</tt> single precision floating point
<li><tt>-int-</tt> 32 bit integer 
<li><tt>-short-</tt> 16 bit integer
<li><tt>-byte-</tt> 8 bit signed integer
<li><tt>-ubyte-</tt> 8 bit unsigned integer
<li><tt>-bool-</tt> boolean, really an int
<li><tt>-str-</tt> C-style strings
<li><tt>-gptr-</tt> generic pointer, like void*
<li><tt>-list-</tt> lists
<li><tt>-obj-</tt> objects
<li><tt>-idx0-, -idx1-, -idx2-, -idx3-,... -idx15-</tt> 
 scalar, vectors, matrices, tensors with 0 to 15 dimensions
</ul>
The type declaration format is a list whose car is a list containing
a type, and whose cdr is a list of symbols to declare.  By way of example:
<ul>
<li><tt>((-int-) a b c)</tt> a, b, and c are declared as integers
<li><tt>((-str-) str1 str2)</tt> str1 and str2 are declared as strings
<li><tt>((-idx2- (-flt-)) q)  </tt> q is an idx2 of floats
<li><tt>((-obj- (mark1)) m1)  </tt> m1 is an object which is an 
  instantiation of class mark1
<li><tt>((-list- (-int-) (-flt-)) l1)</tt> l1 is a list containing two elements, 
  an integer and a float
<li><tt>((-list- (-str-) (-list- (-int-) (-int-))) bl)</tt> bl is a list of 
two elements, the first of which is a string and the second of which is a 
list containing two integers.  For example, bl might be ("Hello" (42 43)).
</ul>

<h3><a name="Class compilation, method compilation, and object creation">Class compilation, method compilation, and object creation</a></h3> 

Classes can be compiled together with their methods. Inheritance of
slots from a super-class is provided, along with inheritance of the
super-class's methods.  Instantiation of a class yields an object with
slots of the class and all slots of the super-classes of the class,
along with access to the methods available to the class and its
super-classes. Method inheritance is performed using the concept of a
virtual function.  If a super-class and a class share a method of the
same name, the class's method is only compilable if it has the same
interface (argument number and types, temporaries, and return type) as
the super-class's.
<p>
Objects can be passed to functions using the "-obj-" type declaration.
The one exception to the above requirement of identical types for virtual
methods occurs when an object is passed as an argument in the method.  If
the sub-class method contains an object parameter whose class is a
sub-class of the super-classes object, then compilation is allowed.
<p>
Objects which are subclasses of the expected class may also be passed to a
function.  In cases in which the function calls a method, the appropriate
method of the object's class is called.  Thus, the appropriate virtual
method is automatically called by the compiled function whether the object
is of the expected class or is of a subclass of the expected class.
<p>
As an example of both virtual methods and object parameter passing, assume
ClassB is a sub-class of ClassA, and is defined as follows:
<pre>
  (de foo (a b) 
	  ((-int-) a)
          ((-obj- (ClassA)) b)
          ...)
</pre>
The function "foo" can be called with parameter "b" being an object of
ClassA or of ClassB.  In addition, provided the types of the return value
and temporaries are identical, "foo" could be compiled as a method for
ClassA and as a virtual method for ClassB.  If a compiled function contains
"(==> a foo)", cases where "a" is a ClassA object call ClassA's "foo" and
cases where "a" is a ClassB object call ClassB's foo.

Creation of objects using "new" and sending messages using "==>" function 
similarly in interpreted Lisp whether the class has been compiled or not.  
There are, however, restrictions on the type of classes that can be compiled and
restrictions on the constructor of the class.  To be compiled, all slots of
the class must be typed.  The constructor must initialize any complex slots
of an object of the class to prevent slots from having uninitialized
pointers.  Thus, constructors can choose not to initialize simple types,
such as ints or floats, but complex types such as strings, lists, and
idx-es (types whose slots are actually pointers) must be initialized.  The
constructor's side effects are checked to verify that any initialized slots
are initialized to the correct type and that all complex slots are
initialized.

The currently compilable class and object related functions are:
<pre>
		new		new-empty
		==>		scope (:<obj>:<slot>)
		letslot
</pre>
"New" calls "new-empty" and then the constructor of the class to initialize
the object.  "==>" calls a method (the second argument) of an object (the
first argument) and automatically calls the appropriate virtual method
based on the object's class.  Support for the construct
"(==> obj (class . method) ...)"  is not currently available due to a bug
in append's handling of dotted constructions.  The function "letslot" is
available and allows direct access to a slot without scoping.  Finally,
"scope" or its equivalent form ":<obj>:<slot>" compiles and can be chained
if a slot in an object is another object.

<h3><a name="Compilable string support">Compilable string support</a></h3>

Support for compiling most string-related functions is available.
The following commands are compilable if the library "dh-string.sn" 
is loaded prior to running "dhc-make":
<pre>
	asc		chr		concat
	downcase	index		len
	left		mid		right	
	str		strdel		strins
	upcase		val		printf
	sprintf	
</pre>
The regular expression functions are the only string-related functions
currently not compilable.  There are slight differences in the Lisp and C
versions of "printf" and "sprintf" to be aware of.  First, the "%l" option
is not available in the compiled version of the functions.  Second, the
default format for parameter types such as "%f" and "%d" are different in
Lisp and compiled code.  This is a result of the Lisp code using a
hand-made "printf" command and the compiled code simply calling the C
version of "printf".  There is some simple type checking present in the
"printf" and "sprintf" format strings, but it may need to be extended or
modified to be more complete/thorough.

<h3><a name="Elementary list compilation support">Elementary list compilation support</a></h3> 

Compilation of lists in SN is somewhat restricted.  Because the
compiled code doesn't have a garbage collector, lists can only be
compiled if their length and the type of their elements are known at
compile time. This is mainly useful for returning multiple values from
a function, but it's seldom used. To compile lists, load the library
"dh-list.sn" prior to compilation.  The following list commands are
compilable:
<pre>
	car		length		last
	list		cons		cdr
	reverse		nth		append
</pre>
All should function exactly as they do in Lisp, with the exception of
"nth".  "Nth"'s first argument must be a specific number when compiled -
symbols of number type are not sufficient and will not compile.  This is
due to the need to determine at compile time the exact list type that the
function returns. 

<h3><a name="including C header files in compiled C files">including C header files in compiled C files</a></h3>

Sometimes, C header files need to be included in the generated
C file. This can be done with the <tt>cheader</tt> function.
For example, here is how the stdio function <tt>fputc</tt>
is interfaced to SN:
<pre>
  (de fputc (file val)
      ((-gptr-) file)   ; the file pointer returned by a fopen
      ((-int-) val)     ; contains the byte to be written to the file
      (cheader "#include &lt;stdio.h&gt;\n")
      #{ putc((char)$val,(FILE *)$file); #}
      () )
</pre>

<h3><a name="dynamically loading shared objects">dynamically loading shared objects</a></h3>

If your C code is not in a <tt>.o</tt> file, but in a shared library
(<tt>.so</tt> file), as is often the case with precompiled libraries, you can
load it into SN using the <tt>mod-dlopen</tt> directive. For example, loading
the OpenGL shared library on SGI can be done with:
<pre>
  (mod-dlopen "/usr/lib/libGLcore.so")
  (mod-dlopen "/usr/lib/libGL.so")
</pre>
OpenGL functions can now be called from within C in-line code (though there is
no need to do this since SN's <tt>"gl/openglu"</tt> library already provides a
full interface to OpenGL).

<h3><a name="The dynamic loader">The dynamic loader</a></h3>

[hacker mode on] SN's dynamic loader is extremely sophisticated.  It
can not only load object files, but also unload them.  When a file is
unloaded, the compiled functions that call a function in this file are
marked as partially linked and non-executable. They are marked as
executable as soon as a file with the required functions is loaded.
[hacker mode off]

<h3><a name="what cannot be compiled">what cannot be compiled</a></h3>

Things that call non-compilable functions, and recursive calls.
SN has no garbage collector for data allocated in compiled code.
All data allocated in compiled code is either allocated on the stack
or allocated by the user (who then must deallocate it appropriately).
This means that dynamic data structures such a lists cannot
be created in compiled code unless their size is known 
in advance.

<h2><a name="Hints and Tips">Hints and Tips</a></h2>

[to be written]

<h2><a name="Libraries">Libraries</a></h2>

Some functionalities are provided in the standard libraries that are 
automatically loaded in SN at startup. Some others are loaded on demand
from the "util" directory.

<h3><a name="Standard Library">Standard Library</a></h3>

The standard SN library files are contained in <tt>sn3.2/lib</tt>

<h4><a name="basic library">basic library</a></h4>

These files are part of the standard environment and automatically
loaded at startup.
<ul>
<li><a href="sn3.2/lib/stdenv.sn">stdenv.sn</a>: standard environment
<li><a href="sn3.2/lib/sysenv.sn">sysenv.sn</a>: system functions and macros
<li><a href="sn3.2/lib/idxenv.sn">idxenv.sn</a>: on-line help for storage, idx, and
standard matrix functions, plus additional matrix functions and macros.
<li><a href="sn3.2/lib/help.sn">help.sn</a>: on-line help system.
</ul>

<h4><a name="graphics, GUI generator, and graphic tools">graphics, GUI generator, and graphic tools</a></h4>

<ul>
<li><a href="sn3.2/lib/graphenv.sn">graphenv.sn</a>: standard graphic
functions: drawing, plotting, IDraw interface [loaded at startup]
<li><a href="sn3.2/lib/ogre.sn">ogre.sn</a>: complete object-oriented
GUI widget library, buttons, sliders, requesters...
<li><a href="sn3.2/lib/classtool.sn">classtool.sn</a>: a GUI-based
classs navigation tool.
<li><a href="sn3.2/lib/objtool.sn">objtool.sn</a>: a simple GUI-based object
browser.
</ul>

<h4><a name="Compiler and compiler macros">Compiler and compiler macros</a></h4>

The compiler is not loaded at startup, but it is loaded automatically
the first time <tt>dhc-make</tt> is called.
<ul>
<li><a href="sn3.2/lib/dh-compile.sn">dh-compile.sn</a>: main Lisp-C compiler. This
is the file to load, it loads all the others.
<li><a href="sn3.2/lib/dh-class.sn">dh-class.sn</a>: compiler macros for
compiling classes.
<li><a href="sn3.2/lib/dh-list.sn">dh-list.sn</a>: compiler macros for lists.
<li><a href="sn3.2/lib/dh-macro.sn">dh-macro.sn</a>: compiler macros for most
lisp functions and types.
<li><a href="sn3.2/lib/dh-string.sn">dh-string.sn</a>: compiler macros for
string manipulation functions.
<li><a href="sn3.2/lib/dh-graphics.sn">dh-graphics.sn</a>: compiler macros for
graphic calls.
<li><a href="sn3.2/lib/dh-util.sn">dh-util.sn</a>: low-level compiler utilities.
</ul>
<h4><a name="Obsolete/undocumented">Obsolete/undocumented</a></h4>
<ul>
<li><a href="no-dld.sn">no-dld.sn</a>: to be used only on platforms
  where the dynamic loader doesn't work. This permits loading .so
  but not .o
<li><a href="psdriver.pro">psdriver.pro</a>: PostScript prolog file
  for postscript files generated by the SN postscript graphic driver.
<li><a href="dz-compile.sn">dz-compile.sn</a>: obsolete very simple
  compiler of numerical expressions for a stack machine. superseded
  by the Lisp-C compiler.
<li><a href="debug.sn">debug.sn</a>: old stuff
</ul>

<h3><a name=""Util" Library files">"Util" Library files</a></h3>

It is recommended to load these files with the <tt>mload</tt>
function. This function remembers which files have already been loaded
and avoids loading the same file twice. The load functions follow the
SN search path, so for example, the file <tt>sn3.2/util/gl/opengl.sn</tt> 
can be loaded with <tt>(mload "gl/opengl")</tt>. Here is a list of all 
the library files with a short description of their content.
<UL>
<li><a href="sn3.2/util/cmacro.sn">cmacro.sn</a>: macros to allow 
  in-line C code within Lisp code
<li><a href="sn3.2/util/file-std.sn">file-std.sn</a>: interface to the C
  I/O library (<tt>fopen, fclose, fgetc</tt> etc)
<li><a href="sn3.2/util/dynamic.sn">dynamic.sn</a>: functions for handling 
  dynamically allocated data structures in compiled code such as pools.
<li><a href="sn3.2/util/arithmetic.sn">arithmetic.sn</a>: 
  various integer arithmetic functions 
<li><a href="sn3.2/util/str-manip.sn">str-manip.sn</a>: 
  extracts words from strings
<li><a href="sn3.2/util/db.sn">db.sn</a>: a "database" class convenient
  for handling training and testing data in learning simulations.
<li><a href="sn3.2/util/hash.sn">hash.sn</a>: hash table functions
</UL>
<h3><a name="Vector, Matrix and Tensor libraries">Vector, Matrix and Tensor libraries</a></h3>
<UL>
<li><a href="sn3.2/util/idx-macros.sn">idx-macros.sn</a>: matrix resizing
macros, and efficient matrix iterators for inline C code.
<li><a href="sn3.2/util/idx-flt.sn">idx-flt.sn</a>: macros and functions for
vectors, matrices and tensors of floats (dot products, outer products, fill,
max, clip, logadd....).
<li><a href="sn3.2/util/idx-int.sn">idx-int.sn</a>: macros and functions for
vectors, matrices and tensors of ints.
<li><a href="sn3.2/util/idx-map.sn">idx-map.sn</a>: functions for mapping
large matrices in memory without having to explicitely load them.
<li><a href="sn3.2/util/idx-sort.sn">idx-sort.sn</a>: sorting functions, and
binary search in vectors of floats and ints.
<li><a href="sn3.2/util/idx-convol.sn">idx-convol.sn</a>: 1D and 2D
convolution fonctions. Fast version with unrolled loops are available
for kernel sizes up to 5.
<li><a href="sn3.2/util/idx-squops.sn">idx-squops.sn</a>: a few funky dot
products and outer products that are needed for second-derivative back prop
in neural nets.
<li><a href="sn3.2/util/idx-array.sn">idx-array.sn</a>: arrays of pinters to 
vectors and matrices.
<li><a href="sn3.2/util/idx-ubyte.sn">idx-ubyte.sn</a>: a few functions on
tensors of unsigned bytes (partially documented).
</UL>
<h3><a name="Image processing">Image processing</a></h3>

Several categories of image processing libraries are available.

<h4><a name="basic function for various image types">basic function for various image types</a></h4>

most of these libraries include functions for subsampling, oversampling,
warping, rotating, blitting, extracting luminance or chrominance, 
applying median filters, and computing histograms.
<ul>
<li><a href="sn3.2/util/image/rgbaimage.sn">image/rgbaimage.sn</a>: on RGBA
images with one byte per component.
<li><a href="sn3.2/util/image/rgbafimage.sn">image/rgbafimage.sn</a>: on RGBA
images with one float per component.
<li><a href="sn3.2/util/image/abgrimage.sn">image/abgrimage.sn</a>: on ABGR
images with one byte per component.
<li><a href="sn3.2/util/image/fimage.sn">image/fimage.sn</a>: on grayscale
images of floats
<li><a href="sn3.2/util/image/ubimage.sn">image/ubimage.sn</a>: on grayscale
images with one byte per pixel
<li><a href="sn3.2/util/image/shimage.sn">image/shimage.sn</a>: on grayscale
images with one short (two bytes) per pxiel
</ul>
<h4><a name="specialized image processing">specialized image processing</a></h4>
<ul>
<li><a href="sn3.2/util/image/image-transform.sn">image/image-transform.sn</a>:
computes coordinate mappings for transforming a quadrilateral into a rectangle
(used by image warping functions).
<li><a href="sn3.2/util/image/morpho.sn">image/morpho.sn</a>: morhological
operations such as erosion, dialation, distance transform.
<li><a href="sn3.2/util/image/cca.sn">image/cca.sn</a>: connected component
analysis: truns images into a list of blobs.
<li><a href="sn3.2/util/image/color-quantize.sn">image/color-quantize.sn</a>:
<li><a href="sn3.2/util/image/rgbaim-greypage.sn">image/rgbaim-greypage.sn</a>:
transforms a color image into a grayscale image using color clustering (simple
foreground/background extraction).
<li><a href="sn3.2/util/image/rgbafim-greypage.sn">image/rgbafim-greypage.sn</a>: 
same as above for RGBA images of floats. 
<li><a href="sn3.2/util/image/img-util.sn">image/img-util.sn</a>: a few mildly
useful functions for image conversion.
</ul>
<h4><a name="reading/writing image files">reading/writing image files</a></h4>
<ul>
<li><a href="sn3.2/util/image/pnm.sn">image/pnm.sn</a>: reading/writing
ppm/pgm/pbm (i.e. pnm) files from/to RGB, and ubyte formats.
<li><a href="sn3.2/util/image/pnm-rgba.sn">image/pnm-rgba.sn</a>:
reading pnm image files into RGBA images.
<li><a href="sn3.2/util/image/pnm-stream.sn">image/pnm-stream.sn</a>:
reading/mapping pnm image files to from rgb and ubyte images.
<li><a href="sn3.2/util/image/pbm.sn">image/pbm.sn</a>: reading/writing pbm
image files from ubyte images and run images.
<li><a href="sn3.2/util/image/rle.sn">image/rle.sn</a>: reading/writing
run-length encoded images.
<li><a href="sn3.2/util/image/tiff.sn">image/tiff.sn</a>: reading TIFF
images. 
<li><a href="sn3.2/util/image/jpeg.sn">image/jpeg.sn</a>: reading JPEG images
into RGBA images.
<li><a href="sn3.2/util/image/img-rw.sn">image/img-rw.sn</a>: classes for
reading/writing IW44, JPEG, and JB2 images.
</ul>
<h4><a name="miscellaneous image manipulation">miscellaneous image manipulation</a></h4>
<ul>
<li><a href="sn3.2/util/image/runs2ubim.sn">image/runs2ubim.sn</a>: convert
images to/from run representation and pixel representation.
<li><a href="sn3.2/util/image/run-macros.sn">image/run-macros.sn</a>: constant
definitions for run representations.
<li><a href="sn3.2/util/image/ogrimage.sn">image/ogrimage.sn</a>: Ogre GUI 
class for displaying images.
<li><a href="sn3.2/util/image/xv.sn">image/xv.sn</a>: unsupported pipe output
to XV.
<li><a href="sn3.2/util/image/morpho-patrick.sn">image/morpho-patrick.sn</a>:
unsupported undebugged morphological functions.
<li><a href="sn3.2/util/image/shimage-demo.sn">image/shimage-demo.sn</a>: demo
of warping of images of shorts.
<li><a href="sn3.2/util/image/foreback.sn">image/foreback.sn</a>: old
prototype for DjVu foreground/background segmentation based on color
clustering. 
</ul>

<h3><a name="learning and neural nets libraries">learning and neural nets libraries</a></h3>

This is an object-oriented library of trainable modules.
Each module is a class with fprop, bprop, and bbprop methods
whose arguments are the inputs, outputs, and parameters of
the module (generally in the form of an sn-state).
Simple modules can be assembled in complex arrangements.
Gradients computed by the bprop methd can be used to update
parameter vectors using various algorithms. Module libraries
are provided for most standard neural net architectures,
and most common loss functions. A trainer class is provided 
that can encapsulate a trainable machine, a loss function module, 
a parameter vector, and which can run a learning algorithm. 
A workbench class encapsulates a trainer, a training database,
a test database, and a performance measurement module.
<UL>
<li><a href="sn3.2/util/nets/workbench.sn">nets/workbench.sn</a>: workbench
class definition.
<li><a href="sn3.2/util/nets/trainer.sn">nets/trainer.sn</a>: trainer class
definition.
<li><a href="sn3.2/util/nets/params.sn">nets/params.sn</a>: trainable
parameter class definition with gradient-based learning algorithms
<li><a href="sn3.2/util/nets/states.sn">nets/states.sn</a>: state class
definition. 
<li><a href="sn3.2/util/nets/libnets.sn">nets/libnets.sn</a>: standard module
classes such as fully-connected layers, convolutional layers, and RBF layers.
<li><a href="sn3.2/util/nets/modules.sn">nets/modules.sn</a>: loss functions
and simple module classes.
<li><a href="sn3.2/util/nets/lclass-meter.sn">nets/lclass-meter.sn</a>:
performance measurement class for classifiers.
</ul>
<h4><a name="neural net modules">neural net modules</a></h4>

The libraries below contain class definitions for common neural-net
architectures. Each layer type is identified as a letter:
"f" for fully connected layer, "c" for convolutional layer, 
"s" for subsampling layer, "e" for Euclidean RBF layer, "x"
for simultaneous subsampling and convolutional layer.
So for example LeNet5 is a net-cscscfe.
<ul>
<li><a href="sn3.2/util/nets/ccc-tdnn.sn">nets/ccc-tdnn.sn</a>:
<li><a href="sn3.2/util/nets/ftdnn.sn">nets/ftdnn.sn</a>:
<li><a href="sn3.2/util/nets/net-c.sn">nets/net-c.sn</a>:
<li><a href="sn3.2/util/nets/net-ccc.sn">nets/net-ccc.sn</a>:
<li><a href="sn3.2/util/nets/net-cf.sn">nets/net-cf.sn</a>:
<li><a href="sn3.2/util/nets/net-cfe.sn">nets/net-cfe.sn</a>:
<li><a href="sn3.2/util/nets/net-cff.sn">nets/net-cff.sn</a>:
<li><a href="sn3.2/util/nets/net-csccf.sn">nets/net-csccf.sn</a>:
<li><a href="sn3.2/util/nets/net-cscscf.sn">nets/net-cscscf.sn</a>:
<li><a href="sn3.2/util/nets/net-cscscfe.sn">nets/net-cscscfe.sn</a>:
<li><a href="sn3.2/util/nets/net-ff.sn">nets/net-ff.sn</a>:
<li><a href="sn3.2/util/nets/net-fff.sn">nets/net-fff.sn</a>:
<li><a href="sn3.2/util/nets/net-xx.sn">nets/net-xx.sn</a>:
<li><a href="sn3.2/util/nets/net-xxx.sn">nets/net-xxx.sn</a>:
</ul>
<h4><a name="various unsuported files">various unsuported files</a></h4>
<ul>
<li><a href="sn3.2/util/nets/xor-example.sn">nets/xor-example.sn</a>:
<li><a href="sn3.2/util/nets/seq3-modules.sn">nets/seq3-modules.sn</a>:
<li><a href="sn3.2/util/nets/conx.sn">nets/conx.sn</a>:
</UL>
<h3><a name="Numerical libraries">Numerical libraries</a></h3>
<UL>
<li><a href="sn3.2/util/numerical/nr.sn">numerical/nr.sn</a>: interface to the
numerical recipes library. 
<li><a href="sn3.2/util/numerical/strassen.sn">numerical/strassen.sn</a>:
matrix inversion with the Strassen method (unsupported).
</UL>
<h3><a name="OpenGL and SGI-GL interface libraries">OpenGL and SGI-GL interface libraries</a></h3>
<UL>
<li><a href="sn3.2/util/gl/gl.sn">gl/gl.sn</a>:
<li><a href="sn3.2/util/gl/opengl.sn">gl/opengl.sn</a>:
<li><a href="sn3.2/util/gl/openglu.sn">gl/openglu.sn</a>:
<li><a href="sn3.2/util/gl/opengldemo.sn">gl/opengldemo.sn</a>:
<li><a href="sn3.2/util/gl/gl-video-demo.sn">gl/gl-video-demo.sn</a>:
<li><a href="sn3.2/util/gl/glogre.sn">gl/glogre.sn</a>:
</UL>
<h3><a name="SGI Video interface">SGI Video interface</a></h3>
<UL>
<li><a href="sn3.2/util/video/sgi-vl.sn">video/sgi-vl.sn</a>:
<li><a href="sn3.2/util/video/video-sgi-demo.sn">video/video-sgi-demo.sn</a>:
<li><a href="sn3.2/util/video/video-sgi.sn">video/video-sgi.sn</a>:
</UL>
<h3><a name="Ogre utilities">Ogre utilities</a></h3>
<UL>
<li><a href="sn3.2/util/ogre/classtool.sn">ogre/classtool.sn</a>:
<li><a href="sn3.2/util/ogre/edittext.sn">ogre/edittext.sn</a>:
</UL>
<h3><a name="graphs, grammars, and transducers">graphs, grammars, and transducers</a></h3>
<UL>
<li><a href="sn3.2/util/graph/grammar.sn">graph/grammar.sn</a>:
<li><a href="sn3.2/util/graph/graph.sn">graph/graph.sn</a>:
<li><a href="sn3.2/util/graph/gsearch.sn">graph/gsearch.sn</a>:
<li><a href="sn3.2/util/graph/gtransform.sn">graph/gtransform.sn</a>:
<li><a href="sn3.2/util/graph/rsearch.sn">graph/rsearch.sn</a>:
</UL>
<h3><a name="hierarchical clustering">hierarchical clustering</a></h3>
<UL>
<li><a href="sn3.2/util/hcluster/cluster_funcs.sn">hcluster/cluster_funcs.sn</a>:
<li><a href="sn3.2/util/hcluster/euc-cluster.sn">hcluster/euc-cluster.sn</a>:
<li><a href="sn3.2/util/hcluster/euc-test.sn">hcluster/euc-test.sn</a>:
<li><a href="sn3.2/util/hcluster/hcluster.sn">hcluster/hcluster.sn</a>:
<li><a href="sn3.2/util/hcluster/im-cluster.sn">hcluster/im-cluster.sn</a>:
<li><a href="sn3.2/util/hcluster/im-tree-display.sn">hcluster/im-tree-display.sn</a>:
<li><a href="sn3.2/util/hcluster/test_cluster.sn">hcluster/test_cluster.sn</a>:
<li><a href="sn3.2/util/hcluster/wrapper.sn">hcluster/wrapper.sn</a>:
</UL>
<h3><a name="stuff for character recognition">stuff for character recognition</a></h3>
<UL>
<li><a href="sn3.2/util/ocr/char-db.sn">ocr/char-db.sn</a>:
<li><a href="sn3.2/util/ocr/rawchar-process.sn">ocr/rawchar-process.sn</a>:
<li><a href="sn3.2/util/ocr/rawchar.sn">ocr/rawchar.sn</a>:
<li><a href="sn3.2/util/ocr/sidemen-db.sn">ocr/sidemen-db.sn</a>:
</UL>
<h3><a name="Obsolete, semi-obsolete, experimental, and undocumented stuff">Obsolete, semi-obsolete, experimental, and undocumented stuff</a></h3>
<UL>
<li><a href="sn3.2/util/xmovie.sn">xmovie.sn</a>: an object for dumping 
  SN graphic windows into "movie" files.
<li><a href="sn3.2/util/profile.sn">profile.sn</a>: very crude and 
  undocumented profiling utility
<li><a href="sn3.2/util/display-db.sn">display-db.sn</a>: somewhat obsolescent
  class for visually browsing through "db".
<li><a href="sn3.2/util/dc.sn">dc.sn</a>: attempt at providing direct 
  access to C data structures from Lisp
<li><a href="sn3.2/util/bldb.sn">bldb.sn</a>: interface to the Gnu gdbm
  database system. Hasn't been tested in a long time.
<li><a href="sn3.2/util/math.sn">math.sn</a>: very minimal interface 
  to Mathematica.
</UL>

<h2><a name="What SN does not have (yet)">What SN does not have (yet)</a></h2>

SN does not support multiple inheritance. While its interface to C is simple
and covenient, its interface to C++ could be better. The difficulty with C++
is mainly due to the fact that the current version of the Lisp to C compiler
does not generate C prototypes, but K&amp;R declarations.
Patrice Simard wrote a utility called <tt>cpp2sn</tt> to automatically
generate the Lisp interface to a set of C++ classes. It's a Perl script
located in the <tt>sn3.2/tools</tt> directory. It's somewhat experimental
and has a few loopholes, but it works.
<p>
The main shortcoming of SN is that not all interpreted code is compilable.  In
particular the compiled code does not have a garbage collector.  This leads to
somewhat complicated schemes for allocating dynamic structures in the compiled
code, but it guarantees C-like efficiency of the compiled code.
Unfortunately, this limitation leads to increased complexity of the interface
code that allows calling C code from Lisp code, and accessing Lisp
datastructures from C, because SN has to do significant bookeeping to ensure
the consistency of the C world and the Lisp world.
<p>
There are other minor shortcomings such as the fact that numbers in
interpreted code are always double, while they can be of any numerical type in
compiled code. This may cause some functions to behave differently when
interpreted and when compiled.
<p>
Lastly, the symbol binding is dynamic in the interpreter, but static
in compiled code. Interestingly enough, the compiler cannot compile code
in which dynamic/static binding lead to different behaviors.

<h2><a name=""><a name="app-a">Appendix A: .emacs file</a></a></h2>

If you intend to use Emacs to edit SN code, the 
following lines should be added to your .emacs file:
<pre>
;; turn on lisp mode when .sn file is loaded
(setq auto-mode-alist
      (append
       (list (cons "\\.sn$"     'lisp-mode))
       auto-mode-alist))
(progn
  (put 'when 'lisp-indent-function 1)
  (put 'ifdef 'lisp-indent-function 2)
  (put 'repeat 'lisp-indent-function 1)
  (put 'selectq 'lisp-indent-function 1)
  (put 'reading 'lisp-indent-function 1)
  (put 'writing 'lisp-indent-function 1)
  (put 'all 'lisp-indent-function 1)
  (put 'each 'lisp-indent-function 1)
  (put 'for 'lisp-indent-function 1)
  (put 'do-while 'lisp-indent-function 1)
  (put 'all-bag 'lisp-indent-function 1)
  (put 'all-nodes 'lisp-indent-function 1)
  (put 'all-downlink 'lisp-indent-function 1)
  (put 'all-uplink 'lisp-indent-function 1)
  (put 'all-miset 'lisp-indent-function 1)
  (put 'idx-bloop 'lisp-indent-function 1)
  (put 'idx-eloop 'lisp-indent-function 1)
  (put 'idx-gloop 'lisp-indent-function 1)
  (put 'cidx-bloop 'lisp-indent-function 1)
  (put 'demethod 'lisp-indent-function 'defun)
  (put 'dfmethod 'lisp-indent-function 'defun)
  (put 'dmmethod 'lisp-indent-function 'defun)
  (put 'reading 'lisp-indent-function 1)
  (put 'writing 'lisp-indent-function 1)
  (put 'cinline-idx1loop 'lisp-indent-function 'defun)
  (put 'cinline-idx1loop2 'lisp-indent-function 'defun)
  (put 'cinline-idx1loop3 'lisp-indent-function 'defun))
;; load hilite/coloring mode
(load "hilit19")
;; a hilite mode for SN
(hilit-set-mode-patterns
 '(lisp-mode)
 '(
   (";.*" nil comment)
   ("#|" "|#" comment)
   (hilit-string-find ?\\ string)

   ("^\\s *(def\\(un\\|macro\\|advice\\|subst\\|method\\)\\s " "\\()\\|nil\\)" defun)
   ("^\\s *(d\\(e\\|f\\|m\\|md\\|mc\\|hm-t\\|hm-c\\|efmethod\\|emethod\\|fmethod\\|mmethod\\)\\s "  "\\()\\|nil\\)" defun)

   ("^\\s *(\\(def\\(var\\|type\\|parameter\\)\\|declare\\)\\s +\\S +" nil decl)
   ("^\\s *(def\\(const\\(ant\\)?\\|class\\|struct\\)\\s \\S +[ \t\n]+\\((\\(([^()]*)\\|[^()]+\\)*)\\)?" nil define)
   ("^\\s *(\\(load\\|mload\\).*$" nil include)
   ("[ \t]\\&\\(key\\|rest\\|optional\\|aux\\)\\s *" nil keyword)
   ("(\\(set\\|setq\\|eval\\|apply\\|progn\\|prog1\\|let\\*?\\|if\\|when\\|do=while\\|repeat\\|for\\|mapfor\\|cond\\|selectq\\|mapc\
\|mapcar\\|rmapc\\|rmapcar\\|each\\|all\\|lambda\\|flambda\\|mlambda\\)[ \t\n]" 1 keyword)
   ))
</pre>

<h2><a name="Credits and revision history">Credits and revision history</a></h2>

The SN1.0 project was started in 1987 by Leon Bottou and Yann LeCun
(both were students in Paris) as the front-end of a neural net
simulator. Yann completed v1.0 while a postdoc at U. of Toronto, after
which Leon wrote version 2.0. 
In the late 80s Yann joined AT&T and brought SN2.0 with him, while
Leon launched a startup company called Neuristique to make a
commercial version called SN2.5.  
<p>
Leon joined AT&T in 1991, and wrote the first version of the compiler
on AT&T's version of SN, which became SN3.0. In 1992 he went back to
France to run Neuristique and branched off the development into
Neuristique's own version of the interpreter called TL3. In many ways
TL3 is cleaner and better documented than SN3.0 (it also runs on
Windows), but it doesn't have the compiler and the tensor engine that
the AT&T version has. Recently, Neuristique released TL3 under the
GPL.  Yann picked up where Leon left, completed the first compiler,
and wrote a library of compiled trainable modules for building modular
learning machines using gradient-based learning.  
<p>
The SN3.0 compiler had unique features like type inferencing and
automatic resizing of tensors, but it had too many limitations and hit
a dead end. An overhaul was needed. Withi his unwavering thirst for
tool building, Patrice Simard volunteered to do the rewrite. In the
process he shed the type inferencing, and updated the compiler so it
could compile classes, strings, lists, and other structures that the
the "numericially centric" first version could not handle.  After
two years of efforts, SN3.1 was operational.  Yann added the inline C
capability and wrote various numerical libraries together with Yoshua
Bengio who was then at AT&T.  
<p>
In 1995, Leon re-joined AT&T, and added the "graph transformer"
library, with graph search and graph-algebra routines. He also wrote
"dynamic.sn" which gives complete control over dynamic memory
allocation in compiled code. Patrick Haffner, Pascal Vincent (now a
PhD student with Yoshua Bengio) and Yann LeCun added many libraries
for image processing, file I/O, and other functions. 
<p>
SN3.1 was used to produce several succesful commercial products,
including the check amount reader used in NCR's check reading machines
and ATMs. It was also used to produce the first DjVu compressor.  The
commercial version of the segmentation algorithm in DjVu is
SN-generated C code.
<p>
Yann LeCun, April 1999
</body>
</html>