/*   
 * This file is part of the subset of the SN3.2 Lisp 
 * interpreter/compiler and libraries that are not owned by Neuristique S.A.
 * (i.e. the pieces owned by either AT&T, Leon Bottou, or Yann LeCun).
 * This code is not functional as is, but is intended as a 
 * repository of code to be ported to Lush.
 *
 *
 *   SN3.2
 *   Copyright (C) 1987-2001 
 *   Leon Bottou, Yann Le Cun, AT&T Corp.
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

/*
 * WARNING: This code has been automatically generated by the DH compiler.
 * Exercise care while modifying it.
 */

#include "header.h"
#include "dh.h"
#include "idxmac.h"
#include "idxops.h"


extern void dp_match(/*seq1,seq1_len,seq2,seq2_len,n_ins,n_del,n_sub,path1,path2,path_len*/);


/*
 * C_FUNCTION
 */
void 
C_dp_match (PL0_seq1, PL0_seq2, PL0_n_ins, PL0_n_del, PL0_n_sub, PL0_path1, PL0_path2, PRET0_res)
struct idx *PL0_seq1;
struct idx *PL0_seq2;
struct idx *PL0_n_ins;
struct idx *PL0_n_del;
struct idx *PL0_n_sub;
struct idx *PL0_path1;
struct idx *PL0_path2;
int *PRET0_res;
{
  flt *seq1,*seq2,*path1,*path2;
  int seq1_len, seq2_len, path_len, n_ins, n_del, n_sub;

  seq1 = IDX_PTR(PL0_seq1, BASETYPE);
  seq2 = IDX_PTR(PL0_seq2, BASETYPE);
  seq1_len = (int)(PL0_seq1->dim[0]);
  seq2_len = (int)(PL0_seq2->dim[0]);
  path1 = IDX_PTR(PL0_path1, BASETYPE);
  path2 = IDX_PTR(PL0_path2, BASETYPE);
/* path1 and path2 must initially have length = len(seq1) + len(seq2) */
  if (PL0_path1->dim[0] != seq1_len+seq2_len ||
  		PL0_path2->dim[0] != seq1_len+seq2_len)
    error(NIL,"arguments 6 and 7 must have length= size(arg1)+size(arg2)", NIL);

  dp_match(seq1,seq1_len,seq2,seq2_len,&n_ins,&n_del,&n_sub,path1,path2,&path_len);

  *IDX_PTR(PL0_n_ins, BASETYPE) = (BASETYPE) n_ins;
  *IDX_PTR(PL0_n_del, BASETYPE) = (BASETYPE) n_del;
  *IDX_PTR(PL0_n_sub, BASETYPE) = (BASETYPE) n_sub;
/* narrow path1 and path2 to size path_len */
  if (path_len<0 || path_len>PL0_path1->dim[0] || path_len>PL0_path2->dim[0])
	error(NIL,"Unexpected path_len in dp_match",NIL);
  Midx_narrow(PL0_path1, 0, path_len, 0, BASETYPE);
  Midx_narrow(PL0_path2, 0, path_len, 0, BASETYPE);
  ((*PRET0_res)) = (0);
}


/*
 * X_FUNCTION
 */
#ifndef NOLISP
DH (X_dp_match)
{
  dharg ret;
/* C_dp_match (&a[1].dh_in, &a[2].dh_in, &a[3].dh_out, &a[4].dh_out, &a[5].dh_out, &a[6].dh_out, &a[7].dh_out, a[8].dh_bool); */
  C_dp_match (a[1].dh_idx_ptr, a[2].dh_idx_ptr, a[3].dh_idx_ptr, a[4].dh_idx_ptr, a[5].dh_idx_ptr, a[6].dh_idx_ptr, a[7].dh_idx_ptr, &ret.dh_bool);
  ret.dh_bool = 0;	/* ADDED */
  return ret;
}
#endif


/*
 * K_RECORD
 */
/* DHDOC (K_dp_match, X_dp_match, "C_dp_match", NULL, DHT_BOOL, 0) */
DHDOC (K_dp_match, X_dp_match, "C_dp_match", NULL, NULL) 
{
    DH_FUNC(7),
    DH_IDX (DHT_READ, 1),	/* DH_IDX1 (DHT_IN, 0), */
    DH_SRG (DHT_READ),
    DH_FLT,
    DH_IDX (DHT_READ, 1),	/* DH_IDX1 (DHT_IN, 1), */
    DH_SRG (DHT_READ),
    DH_FLT,
    DH_IDX (DHT_READ, 0),	/* DH_IDX0 (DHT_OUT), */
    DH_SRG (DHT_WRITE),
    DH_FLT,
    DH_IDX (DHT_READ, 0),	/* DH_IDX0 (DHT_OUT), */
    DH_SRG (DHT_WRITE),
    DH_FLT,
    DH_IDX (DHT_READ, 0),	/* DH_IDX0 (DHT_OUT), */
    DH_SRG (DHT_WRITE),
    DH_FLT,
    DH_IDX (DHT_READ, 1),	/* DH_IDX1 (DHT_OUT, 2), */
    DH_SRG (DHT_WRITE),
    DH_FLT,
    DH_IDX (DHT_READ, 1),	/* DH_IDX1 (DHT_OUT, 2), */
    DH_SRG (DHT_WRITE),
    DH_FLT,
    DH_RETURN,
    DH_BOOL,
    DH_END_FUNC,
    DH_NIL,
};



/*
 * INIT FUNCTION
 */
void 
init_dp_match ()
{
  dh_define ("dp-match", &K_dp_match);
}

int majver_dp_match = 3;
int minver_dp_match = 1;

/* match.c

	dynamic programming match between two symbol sequences in order to
	minimize number of insertions, deletions, substitutions.

	Input:
	seq1
	seq1_len
	seq2
	seq2_len

	Output:
	n_ins
	n_del
	n_sub
	path1
	path2
	path_len

*/

#define DIST(a,b) (a!=b)
#define MIN(a,b) ((a)<(b)?(a):(b))
#define MAX(a,b) ((a)>(b)?(a):(b))

flt min3(a,b,c,choice)	/* with a bias towards the last choice */
flt a,b,c;
int *choice;
{
	if (a<b)
	{	if (a<c)
		{	*choice=0;
			return(a);
		}
		else
		{	*choice=2;
			return(c);
		}
	}
	else
	{	if (b<c)
		{	*choice=1;
			return(b);
		}
		else
		{	*choice=2;
			return(c);
		}
	}
}

void dp_match(seq1,seq1_len,seq2,seq2_len,n_ins,n_del,n_sub,path1,path2,path_len)
flt *seq1,*seq2,*path1,*path2;
int seq1_len,seq2_len,*path_len,*n_ins,*n_del,*n_sub;
{
	flt **Cost;
	int i,j,k,l,**Prev, prev_choice;
	Cost=(flt **)calloc(seq1_len+1,sizeof(flt *));
	for (i=0;i<=seq1_len;i++)
		Cost[i]=(flt *)calloc(seq2_len+1,sizeof(flt));
	Prev=(int **)calloc(seq1_len+1,sizeof(int *));
	for (i=0;i<=seq1_len;i++)
		Prev[i]=(int *)calloc(seq2_len+1,sizeof(int));


/* FORWARD PASS */

	Cost[0][0]= 0;
	Prev[0][0]= 2;

	for (j=1;j<=seq2_len;j++) {
		/* initial deletions */
		Cost[0][j]=j; 
		Prev[0][j]=1;
	}
	for (i=1;i<=seq1_len;i++) {
		/* initial insertions */
		Cost[i][0]=i; 
		Prev[i][0]=0;
	}

	for (i=1;i<=seq1_len;i++)
	{
		for (j=1;j<=seq2_len;j++)
		{	Cost[i][j]=
				min3(Cost[i-1][j]+1,
					Cost[i][j-1]+1,
					Cost[i-1][j-1]+DIST(seq1[i-1],seq2[j-1]),&prev_choice);
			Prev[i][j]=prev_choice;
		}
	}
	
/*printf("\n");
for (j=0;j<=seq2_len;j++) {
	for (i=0;i<=seq1_len;i++) 
		printf("%2d ",(int)Cost[i][j]);
	printf("\n");
}*/
/* BACKWARD PASS */

	i=seq1_len;
	j=seq2_len;
	path1[0]=i;
	path2[0]=j;

	*n_ins=0;
	*n_del=0;
	*n_sub=0;

	for (k=1;;)
	{	
		if (i<0 || j<0)
		{	printf("error in dp_match!!!\n");
			return;
		}
		if (i==0 && j==0)
			break;
		else
		switch (Prev[i][j])
		{
		case 0:
			i--;
			path1[k]=(flt)i;
			path2[k]=(flt)j;
			(*n_ins)++;
			k++;
			break;
		case 1:
			j--;
			path1[k]=(flt)i;
			path2[k]=(flt)j;
			(*n_del)++;
			k++;
			break;
		case 2:
			j--;
			i--;
			path1[k]=(flt)i;
			path2[k]=(flt)j;
			(*n_sub)+=DIST(seq1[i],seq2[j]);
			k++;
			break;
		}
	}
	*path_len=k;

	for (i=0;i<seq1_len;i++)
		free(Cost[i]);
	free(Cost);
	for (i=0;i<seq1_len;i++)
		free(Prev[i]);
	free(Prev);
}


