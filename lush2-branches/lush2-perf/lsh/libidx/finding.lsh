;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; PSU Lush
;;;   Copyright (C) 2005 Ralf Juengling
;;; Derived from LUSH Lisp Universal Shell
;;;   Copyright (C) 2002 Leon Bottou, Yann Le Cun, AT&T Corp, NECI.
;;; Includes parts of TL3:
;;;   Copyright (C) 1987-1999 Leon Bottou and Neuristique.
;;; Includes selected parts of SN3.2:
;;;   Copyright (C) 1991-2001 AT&T Corp.
;;;
;;; This program is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 2 of the License, or
;;; (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program; if not, write to the Free Software
;;; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(libload "overload")

;; functions for finding sets of elements in an array

(defun -find-nonzero-1d-double (v)
  (declare (-idx1- (-double-)) v)
  (when (not (contiguousp v)) (error "index must be contiguous"))
  (let ((out (int-array (length v) 1))
	(j 0)
	(i 0) )
    (declare (-idx2- (-int-)) out)
    (idx-bloop ((e v))
      (when (<> (e) 0)
	(out i 0 j)
	(incr i)) 
      (incr j) )
    (idx-trim out 0 0 i) ))

(defun -find-nonzero-1d-int (v)
  (declare (-idx1- (-int-)) v)
  (when (not (contiguousp v)) (error "index must be contiguous"))
  (let ((out (int-array (length v) 1))
	(j 0)
	(i 0) )
    (declare (-idx2- (-int-)) out)
    (idx-bloop ((e v))
      (when (<> (e) 0)
	(out i 0 j)
	(incr i)) 
      (incr j) )
    (idx-trim out 0 0 i) ))

(defun -find-nonzero-1d-ubyte (v)
  (declare (-idx1- (-ubyte-)) v)
  (when (not (contiguousp v)) (error "index must be contiguous"))
  (let ((out (int-array (length v) 1))
	(j 0)
	(i 0) )
    (declare (-idx2- (-int-)) out)
    (idx-bloop ((e v))
      (when (<> (e) 0)
	(out i 0 j)
	(incr i)) 
      (incr j) )
    (idx-trim out 0 0 i) ))

(defun -find-nonzero-2d-double (m)
  (declare (-idx2- (-double-)) m)
  (when (not (contiguousp m)) (error "index must be contiguous"))
  (let* ((nzs (-find-nonzero-1d-double (ravel m)))
	 (out (int-array (length nzs) 2))
	 (d1  (idx-dim m 1)) )
    (declare (-idx2- (-int-)) nzs out)
    (idx-bloop ((nz nzs) (o out))
      (o 0 (int (/ (nz 0) d1)))
      (o 1 (mod (nz 0) d1)) )
    out))
 
(defun -find-nonzero-2d-int (m)
  (declare (-idx2- (-int-)) m)
  (when (not (contiguousp m)) (error "index must be contiguous"))
  (let* ((nzs (-find-nonzero-1d-int (ravel m)))
	 (out (int-array (length nzs) 2))
	 (d1  (idx-dim m 1)) )
    (declare (-idx2- (-int-)) nzs out)
    (idx-bloop ((nz nzs) (o out))
      (o 0 (int (/ (nz 0) d1)))
      (o 1 (mod (nz 0) d1)) )
    out))

(defun -find-nonzero-2d-ubyte (m)
  (declare (-idx2- (-ubyte-)) m)
  (when (not (contiguousp m)) (error "index must be contiguous"))
  (let* ((nzs (-find-nonzero-1d-ubyte (ravel m)))
	 (out (int-array (length nzs) 2))
	 (d1  (idx-dim m 1)) )
    (declare (-idx2- (-int-)) nzs out)
    (idx-bloop ((nz nzs) (o out))
      (o 0 (int (/ (nz 0) d1)))
      (o 1 (mod (nz 0) d1)) )
    out))

(defun -find-nonzero-3d-double (m)
  (declare (-idx3- (-double-)) m)
  (when (not (contiguousp m)) (error "index must be contiguous"))
  (let* ((nzs (-find-nonzero-1d-double (ravel m)))
	 (out (int-array (length nzs) 3))
	 (d1  (idx-dim m 1))
	 (d2  (idx-dim m 2))
	 (d12 (* d1 d2)) )
    (declare (-idx2- (-int-)) nzs out)
    (idx-bloop ((nz nzs) (o out))
      (o 0 (int (/ (nz 0) d12)))
      (o 1 (int (/ (mod (nz 0) d12) d2)))
      (o 2 (mod (nz 0) d2)) )
    out))

(defun -find-nonzero-3d-int (m)
  (declare (-idx3- (-int-)) m)
  (when (not (contiguousp m)) (error "index must be contiguous"))
  (let* ((nzs (-find-nonzero-1d-int (ravel m)))
	 (out (int-array (length nzs) 3))
	 (d1  (idx-dim m 1))
	 (d2  (idx-dim m 2))
	 (d12 (* d1 d2)) )
    (declare (-idx2- (-int-)) nzs out)
    (idx-bloop ((nz nzs) (o out))
      (o 0 (int (/ (nz 0) d12)))
      (o 1 (int (/ (mod (nz 0) d12) d2)))
      (o 2 (mod (nz 0) d2)) )
    out))

(defun -find-nonzero-3d-ubyte (m)
  (declare (-idx3- (-ubyte-)) m)
  (when (not (contiguousp m)) (error "index must be contiguous"))
  (let* ((nzs (-find-nonzero-1d-ubyte (ravel m)))
	 (out (int-array (length nzs) 3))
	 (d1  (idx-dim m 1))
	 (d2  (idx-dim m 2))
	 (d12 (* d1 d2)) )
    (declare (-idx2- (-int-)) nzs out)
    (idx-bloop ((nz nzs) (o out))
      (o 0 (int (/ (nz 0) d12)))
      (o 1 (int (/ (mod (nz 0) d12) d2)))
      (o 2 (mod (nz 0) d2)) )
    out))

(let ((funcs '(-find-nonzero-1d-double
	       -find-nonzero-1d-int
	       -find-nonzero-1d-ubyte
	       -find-nonzero-2d-double
	       -find-nonzero-2d-int
	       -find-nonzero-2d-ubyte
	       -find-nonzero-3d-double
	       -find-nonzero-3d-int
	       -find-nonzero-3d-ubyte)))
  
  (apply dhc-make () funcs)
  (apply defoverload '-array-where-nonzero funcs) )

;(defmacro array-where-nonzero (m)
;  `(-array-where-nonzero (as-contiguous-array ,m)) )

(defun array-take* (m map &optional legend)
  (let ((shp-map (idx-shape map)))
    (when (or (< (idx-rank m) (idx-rank map))
              (<> (car (list-split! (shape m) (idx-rank map))) shp-map) )
      (error "shape of map must be a prefix of shape of array" 
             (list (shape m) 'vs. (shape map))) ))
    
  (let ((m   (idx-flatten m (idx-rank map)))
	(map (idx-flatten map)) )
    (if (null legend)
        (let ((ss (idx-flatten (array-where-nonzero map))))
          (array-take m 0 ss) )
      (let ((leg (idx-flatten legend))
	    (res (atom-array (length legend))) )
	(idx-bloop ((i leg) (r res))
	  (r (array-take m 0 (ravel (array-where-nonzero (c== map i))))) )
	(idx-reshape res (idx-shape legend)) ))))
