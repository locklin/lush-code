;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; PSU Lush
;;;   Copyright (C) 2005 Ralf Juengling
;;; Derived from LUSH Lisp Universal Shell
;;;   Copyright (C) 2002 Leon Bottou, Yann Le Cun, AT&T Corp, NECI.
;;; Includes parts of TL3:
;;;   Copyright (C) 1987-1999 Leon Bottou and Neuristique.
;;; Includes selected parts of SN3.2:
;;;   Copyright (C) 1991-2001 AT&T Corp.
;;;
;;; This program is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 2 of the License, or
;;; (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program; if not, write to the Free Software
;;; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; CL functions for list processing

(defalias atom atomp)

(defun find (item seq)
  (if (null seq)
      nil
    (if (= (car seq) item)
        item
      (find item (cdr seq)) ) ) )

(defun find-if (p seq)
  (if (null seq)
      nil
    (if (p (car seq))
        (car seq)
      (find-if p (cdr seq)) ) ) )

(defun some (p &rest seqs)
  (if (null (car seqs))
      nil
    (let ((pres (apply p (mapcar car seqs))))
      (if pres
          pres
        (some p (mapcar cdr seqs)) ) ) ) )

(defun every (p &rest seqs)
  (if (null (car seqs))
      t
    (if (apply p (mapcar car seqs))
        (every p (mapcar cdr seqs))
      nil) ) )

(defun remove (item lst)
  (if (null lst)
      nil
    (if (= (car lst) item)
        (remove item (cdr lst))
      (cons (car lst) (remove item (cdr lst))) ) ) )

(defun remove-if (p lst)
  (if (null lst)
      nil
    (if (p (car lst) item)
        (remove item (cdr lst))
      (cons (car lst) (remove item (cdr lst))) ) ) )

(defun last (l &optional n)
  (if (null n)
      (lastcdr l)
    (let ((lcdr (cdr (lastcdr l))))
      (if (= n 0)
          lcdr
        (let ((ln (reverse (nfirst n (reverse l)))))
          (rplacd (lastcdr ln)  lcdr)
          ln)))))

;;
;; some more CL functions; need to decide where to put them
;;

;; (defun flatten (x)
;;   (labels ((rec (x acc)
;;                 (cond ((null x) acc)
;;                       ((atom x) (cons x acc))
;;                       (t (rec (car x) (rec (cdr x) acc))) ) ))
;;     (rec x nil)) )

;; (defun prune (test tree)
;;   (labels ((rec (tree acc)
;;                 (cond ((null tree) (nreverse acc))
;;                       ((consp (car tree))
;;                        (rec (cdr tree)
;;                             (cons (rec (car tree) nil) acc)))
;;                       (t (rec (cdr tree)
;;                               (if (test (car tree))
;;                                   acc
;;                                 (cons (car tree) acc) ) )) ) ))
;;    (rec tree nil)))

;; create list of non-nil results of fn applied to elements
;; of lst
;; (defun filter (fn lst)
;;   (let ((acc nil))
;;     (dolist (x lst)
;;       (let ((val (fn x)))
;;         (if (val (push val acc))) ) ) 
;;     (nreverse acc) ) )

;; group elements of a list
;; (defun group (lst n)
;;   (if (zerop n) 
;;       (error "zero length")
;;     (labels ((rec (source acc)
;;                   (let ((rest (nthcdr n source)))
;;                     (if (consp rest)
;;                         (rec rest (cons (subseq source 0 n) acc))
;;                       (nreverse (cons source acc)) ) ) )))
;;     (if lst (rec lst nil) nil) ) )
