$Id: graphics.hlp,v 1.1.1.1 2002-04-16 17:37:30 leonb Exp $
#? *** Graphics.

TLisp features a collection of graphics functions for creating
windows, drawing figures, plotting curves, and handling graphical
events.

A window descriptor is a lisp object of class <|WINDOW|>. 
Most graphical commands implicitely operate on the current window
defined by the window descriptor stored in the symbol <window>.

Each window descriptor forwards all drawing requests to a
``Graphic Driver'' which performs the system dependent calls
required to display the drawings on your screen. It is possible
however to create a window descriptor that outputs graphics
on your printer (as printer dependent codes) or into an 
Encapsulated PostScript file.


#? ** Creating a Window Descriptor.

The standard function for creating a window on
your screen is <new-window>. This function determines
which system your are running and calls the appropriate
low level function.  

Function <print-window> performs
the same task for creating a window descriptor
that accesses your printer.



#? (new-window [[<x> <y>] <w> <h>] [<name>])
.TYPE DX
.SEE (x11-window  [[[<x> <y>] <w> <h>] <name>])
.SEE (wbm-window  [[[<x> <y>] <w> <h>] <name>])
.SEE window

This is the device independent function for creating a window.  It
figures out which drivers are available, and call the appropriate
function for creating a window.

Function <new-window> function creates a window named <name>.
Arguments <w> and <h> specify the size of the window.
Arguments <x> and <y> specify the location of the window.

The resulting window descriptor is then stored into 
variable <window>. This operation makes the window current.

Windows are closed when they are no longer referenced by the
lisp interpreter, when they are deleted with the <delete> 
function, or when the windowing system sends a deletion request.



#? (print-window <w> <h> [<destination>])
.TYPE DX
.SEE (ps-window [[<w> <h>] <name>])
.SEE (wpr-window [[<w> <h>] <name>])
.SEE (wpr-printers)
.SEE Print Requester.
.SEE Producing Encapsulated PostScript Files.
.SEE window

This is the device independent function for printing
graphics on the system printer. This function figures
out the best way to send graphics on the printer
or the file specified by string <destination>.
Arguments <w> and <h> specify the size of the printing area.
The drawings will be scaled to fit a standard size page.

The resulting window descriptor is then stored into 
variable <window>. This operation makes the window current.

Function <print-window> actually calls a system
dependent function (e.g. <wpr-window> under Windows 95 and NT,
<ps-window> under Unix operating systems). Argument <destination>
is passed verbatim to these functions.
There are therefore two ways to write a portable program.
The simplest way consists in omitting argument <destination>. 
The best way consists in using the <PrintRequester> class
provided with the Ogre library.

The window descriptors returned by <print-window> are very
similar to the window descriptors returned by <new-window>.
They print pages instead of rendering graphics on your screen.
A page is output when you call function <cls> or when the
window descriptor is closed (because it is no longer
referenced by the interpretor or because you called function
<delete>).  

Note: Calling function <cls> while a clip rectangle is active
(see function <clip>) will not output a page. It will simply
clears the clipping zone. Before using <cls>, you can use 
function <clip> to make sure that no clipping rectangle is active.


#? ** Drawing.

The coordinate system of a window has its origin in the upper left
hand corner.  Positive x and y coordinates go to the right and
downwards.


#? (cls)  

Clears the current graphics window.

#? (draw-line  <x1> <y1> <x2> <y2>)

Draws a line from point (<x1>, <y1>) to the point (<x2>, <y2>) in the
current window, with the current color.


#? (draw-rect <x> <y> <w> <h>)

Draws a hollow rectangle in the current window, with the current
color.  Its top-left corner is located at coordinates (<x>, <y>); its
width is <w>, and its height is <h>.

#? (draw-round-rect <x> <y> <w> <h> [<r>])

Draws a hollow rectangle whith rounded corners of radius <r>.


#? (draw-circle  <x> <y> <r>)

Draws a hollow circle in the current window, with the current color.
The center of the circle is located at position (<x>, <y>).  The radius
of the circle is radius is <r>.


#? (draw-arc  <x> <y> <r> <fromangle> <toangle>)

Draws a segment of a circle in the current window, with the current
color.  The center of the circle is located at position (<x>, <y>).
The radius of the circle is radius is <r>.  The segment is delimited
by angle <fromangle> and <toangle> which are values between -360 and
360 inclusive. Argument <toangle> must be larger than <fromangle>.


#? (fill-rect <x> <y> <w> <h>)

Fills a rectangle in the current window, with the current color.  Its
top-left corner is located at coordinates (<x>, <y>); its width is <w>,
and its height is <h>.


#? (fill-round-rect  <x> <y> <w> <h> [<r>])

Fills a rectangle whith rounded corners of radius <r>.


#? (fill-circle  <x> <y> <r>)

Fills a circle in the current window, with the current color.  The
center of the circle is located at position (<x>, <y>).  The radius of
the circle is radius is <r>.


#? (fill-arc  <x> <y> <r> <fromangle> <toangle>)

Fills a segment of a circle in the current window, with the current
color.  The center of the circle is located at position (<x>, <y>).
The radius of the circle is radius is <r>.  The segment is delimited
by angle <fromangle> and <toangle> which are values between -360 and
360 inclusive. Argument <toangle> must be larger than <fromangle>.


#? (fill-polygon <x1> <y1> ... <xn> <yn>)

Fills the polygon defined by the points (<x1>, <y1>) to (<xn>, <yn>),
in the current window, with the current color.


#? (draw-value  <x> <y> <val> <maxv> <maxs>)

This function displays a real value as a white or black square.

Arguments <x> and <y> are the coordinates of the center of the square.
Argument <val> is the value to be displayed.  Argument <maxv> is the
maximum absolute value for <val>.  Argument <maxs> is the maximum size
of the square. When <val> is larger than <maxv>, a square of size
<maxs> is drawn.

Note: The square will not be visible if it is drawn in the same color
as the background.



#? (draw-list  <x> <y> <l> <ncol> <maxv> <apart> <maxs>)

High level drawing function to graphically represent a list of real
numbers. A list of real numbers <l> will be represented as a series of
black or white squares on a grey background (actual colors depend on
the implementation).

Arguments <x> and <y> are the coordinates of the top left edge of the
background area.  The squares are arranged in an array with <ncol>
columns, the number of lines is then defined by the length of the list
<l>.  The grey background is always rectangular, even if <ncol> is not
a divisor of the length of <l>.

As with <draw-value>, argument <maxv> is the maximum absolute value
for the list elements. The size of the square is however bounded by
<maxs>.

Argument <apart> defines the size of the space occupied by a single
square, i.e, the centers of two neighboring squares will be apart
pixels apart. It is generally suitable to choose a value for <apart>
slightly greater than maxs so that no squares will overlap. For best
results, the difference between <apart> and <maxs> should be an even
number.

Example:
.VP
 ; draw 6 values on 3 columns and 2 lines, in 50 pixel squares
 (draw-list 50 50 '( 4 5 -10 
                     0 4  16 ) 3 16 52 50)

 ; draw the values in l on a single line
 (draw-list 100 100 l (length l) 10 20 18)
.PP


#? (gray-draw-list  <x> <y> <l> <ncol> <minv> <maxv> <apart>)

High level drawing function to graphically represent a list of real
numbers. A list of real numbers <l> will be represented as a series of
gray squares whose gray level is related to the represented value.
This function uses a clever dithering algorithm on black&white
displays.

Arguments <x> and <y> are the coordinates of the topleft edge of the
first square (representing the first element in the list).  The
squares are arranged in an array with <ncol> columns, the number of
lines is defined by the length of the list <l>.  

Values between <minv> and <maxv> will be displayed as gray levels.  A
value of <minv> will be rendered as a black square. A value of <maxv>
will be rendered as a white square.  Argument <minv> can be defined to
be greater than <maxv> in order to produce a reverse video effect.
The sizes of the squares are defined by the <apart> parameter.



#? (gray-draw-matrix  <x> <y> <mat> <minv> <maxv> <apartx> <aparty>)

High level drawing function to graphically represent a 2D matrix <mat>
as a series of gray rectangles whose gray level is related to the
represented value. This function uses a clever dithering algorithm on
black and white displays.

Arguments <x> and <y> are the coordinates of the topleft edge of the
first square (representing the first element in the list).  The values
between <minv> and <maxv> will be displayed as gray levels.  A value
<minv> will be rendered as a black rectangle. A value <maxv> will be
rendered as a white rectangle.  Value <minv> can be defined to be
greater than <maxv> in order to produce a reverse video effect.  The
sizes of the rectangles are defined by the <apartx> and <aparty>
parameter.

#? (draw-mat <m> [<x> <y>])
Function <draw-mat> is easy-to-use wrapper for function <gray-draw-matrix>.
Argument <m> is the matrix to draw. 
Optional arguments <x> and <y> define the position of
the upper left corner of the matrix display.

The function <draw-mat> computes statistical information about 
the matrix values in order to adjust the gray scales.
This function automatically creates a window if no window
is current when the function is called.


#? (color-draw-list  <x> <y> <l> <ncol> <minv> <maxv> <apart> <cmap>)
.SEE (alloccolor <r> <g> <b>)

This function is essentially similar to <gray-draw-list>.  Argument
<cmap> however must be a one-dimensional matrix of 64 color numbers
returned by <alloccolor>.  Values between <minv> and <maxv> are
rendered using the ramp of colors specified by this matrix.



#? (color-draw-matrix  <x> <y> <mat> <minv> <maxv> <apartx> <aparty> <cmap>)
.SEE (alloccolor <r> <g> <b>)

This function is essentially similar to <gray-draw-matrix>.  Argument
<cmap> however must be a one-dimensional integer matrix of 64 color numbers
returned by <alloccolor>.  Values between <minv> and <maxv> are
rendered using the ramp of colors specified by this matrix.


#? (draw-pixel-matrix <x> <y> <imat> [<sx> <sy> [<cmap>]])
.SEE (alloccolor <r> <g> <b>)

This function displays the pixels contained in integer matrix <imat> at
location (<x>,<y>) in the current window. The optional arguments <sx> and
<sy> specify the horizontal and vertical zoom factors.

The optional argument <cmap> is an integer matrix containing a number
of color numbers returned by <alloccolor>.
.IP
When argument <cmap> is not provided, the numbers contained in matrix <imat>
are interpreted as color numbers.
.IP
When integer matrix <cmap> is provided, the numbers in matrix <imat> are
interpreted as subscript in the color map <cmap>. If a number exceeds the
size of the colormap, color number 0 is assumed.



#? ** Drawing with Colors.

Color selection is highly dependent on the capabilities
of your graphics hardware and drivers.
.IP
There are still computers equipped with black and white screens.
You can check that your hardware can display enough colors
using function <colorp>. 
.IP
Many graphic devices use color palettes. The color palette defines
a small set of colors that can be displayed simultaneously on the 
screen. TLisp will allocate palette entries as soon as you 
start using a new color. Since palette entries are rare resources,
you should use colors cautiously.
.PP
TL3 provides two elementary functions for dealing with colors.
Function <alloccolor> takes a set of three numbers (ranging from 0 to 1)
representing the red, green and blue component of the color. 
This function allocates a palette entry if necessary and 
returns a hardware dependent color number. These color numbers
can be used with function <color> to set the current drawing color.

It happens sometimes that it is not possible to allocate a color
because the color palette is full. TL3 will first try to create
its own color palette and install it whenever you activate a TL3 window.
Windows created by other programs can display funny colors until
you activate one of these windows. If the private color palette is full,
function <alloccolor> simply returns a default color.

The use of a limited number of colors is therefore highly encouraged.
The function <color-stdmap> provides several convenient
sets of standard colors for this purpose.

.SEE Ogre Color Palette.

#? (colorp)
The function <colorp> is a predicate which returns <t> when the display
is known to support color. This function returns <()> 
when the display does not support color.

#? (color [<c>])
.SEE (alloccolor <r> <g> <b>)
If <c> is specified, sets the current color to color number <c>.
Function <color> always returns the current color.  
Color numbers are obtained with function <alloccolor>. A few
predefined color numbers however are defined by the file
<"graphenv.sn">:
.IP
<color-fg> or -1  for the system foreground color.
.IP
<color-bg> or -2  for the system background color.
.IP
<color-gray> or -3 for a 50 percent dithered gray level.


#? (alloccolor <r> <g> <b>)
.SEE (color [<c>])

Ask the driver for a color number defined by its three primitive
values. Arguments <r>, <g>, <b> are reals between 0 and 1 that define
the red, green and blue components of the desired color.

Returns a color number suitable for using with the <color> function.
This function returns the constant <color-gray> if the 
system is not able to display the requested color.

#? color-fg
.TYPE VAR
.FILE graphenv.sn
.SEE (color [<c>])
System foreground color.

#? color-bg
.TYPE VAR
.FILE graphenv.sn
.SEE (color [<c>])
System background color.

#? color-gray
.TYPE VAR
.FILE graphenv.sn
.SEE (color [<c>])
A 50 percent dithered gray level.

#? (color-shade <x>)
.TYPE DE
.FILE graphenv.sn

This function calls <alloccolor> then <color> for setting a grayscale
color. Argument <x> is a real between 0 and 1. Function <color-shade>
provides support for grayscale monitors. In addition, drivers often
use dithering for filling circles or rectangles on black and white
monitors .

#? (color-rgb  <r> <g> <b>)
.TYPE DE
.FILE graphenv.sn

This function calls <alloccolor> then <color> for setting the current
color according to its three primitive values. Arguments <r>, <g>, <b>
are reals between 0 and 1. Of course, this function has a poor effect
without a color screen.


#? (color-stdmap [<symb>])
The function <color-std> provides a convenient way to
create a set of predefined matching colors. This function
returns an integer matrix containing color identifiers that
you can use with function <color>.

Using this function maximizes the chances that several part
of your TL3 programs will use the same palette entries and therefore
avoid palette saturation.
.PP
The argument <symb> is a symbol which specifies 
ont of the predefined color sets:
.IP
Symbol <rainbow> defines 64 colors located on a circle 
linking the pure red, green and blue hues. The first
48 colors actually represent a rainbow. The last 16 colors
directly interpolate purple to red.
.IP
Symbol <spread> defines 7 colors that are easy to discriminate.
.IP
Symbol <shade> defines a set of 64 gray levels
going from black to white.


#? (color-std (<x> [<symb>])
The function <color-std> provides access to the convenient sets
of colors allocated by <color-stdmap>.
.IP
Argument <x> is number whose decimal part selects a color
in the set returned by function <color-stdmap>.
Value <0> selects the first color of the set. 
Value <0.9999> selects the last color of the set.
.IP
Optional argument <symb> is a symbol which specifies a color set
for function <color-stdmap>.
.SEE (color-stdmap [<symb>])


#? ** Drawing Text.

Text may be printed in graphic window by using the functions
<draw-text> and <gprintf>. The current font may be changed by
the function <font>. The size and/or rectangle of a graphic text
may be scaned by the functions <text-width>, <text-height> and
<rect-text>.


#? (draw-text <x> <y> <s>)

Draws the text of the string <s> in the current window at position
(<x>, <y>), using the current font and the current color.

#? (gprintf <x> <y> <fmt> ... <args> ...)
.TYPE DE
.FILE graphenv.sn
.SEE (draw-text <x> <y> <s>)

Function <gprintf> behaves like function <printf>, but prints out the
text on the current graphic window, with the current font and color,
starting at location (<x>, <y>).


#? (font  [<fontname>])
.SEE (draw-text <x> <y> <s>)

Function <font> sets the font used for rendering characters in
subsequent calls of function <draw-text>. It always returns the
current font name.

Font <"default"> is recognized by all the drivers, and sets a reasonably
small default font. Always using font <"default"> is the only guaranteed
way to write fully portable programs.

All drivers however recognize PostScript(tm) style font names.
These font names have the following form:
.VP
    "<family>[-<style>][-<size>]"
.IP
The recognized font family <family> usually depends heavily
on the operating system configuration. It is reasonable to
assume that the basic families <"Times">, <"Helvetica"> and <"Courier">
are available (or translated) everywhere. 
.IP
The optional style is preceded by a dash. Style <"Roman"> lets you
print plain text. More complex style are composed by concatenating 
an optional weight specification (e.g. <Light>, <DemiBold>, <Bold>, 
<Black>, etc...)  and an optional slant specification (i.e. <Italic>
or <Oblique>). 
.IP
The optional size is a number between 1 and 128.
.PP
Not all combination of families, styles and size are supported on all
systems. A good compromise between fancy display and portable graphics 
consists in using PostScript font names, but to limit yourself to the 
following fonts:
.VP
    Courier-X, Courier-Bold-X, Courier-Italic-X, Courier-BoldItalic-X
    Times-Roman-X, Times-Bold-X, Times-Italic-X, Times-BoldItalic-X,
    Helvetica-X, Helvetica-Bold-X, Helvetica-Oblique-X, 
    Helvetica-BoldOblique-X, Symbol-X
.PP
where size <X> is one of <8>, <10>, <11>, <12>, <14>, <18>, <24>.
.PP
Most drivers also understand window system dependent font names (when such
font names are defined by the window system). For instance, the X11 driver 
recognizes all font names listed by the utility program <xlsfonts>. 
These font names are very long, but a star <*> can be used
as a wildcard character. A typical example is <"-*-times-*medium-*r-*--18-*">.
Function <x11-fontname> can be used to translate a Postrscript(tm) style
font name into a system specific font name.


#? (rect-text <x> <y> <s>)

Returns a list <(x y w h)> describing the rectangle that would be
affected by a call to <(draw-text x y s)>. 

A few driver, including the PS driver, do not implement this function.
In that case, <rect-text> returns the empty list.

#? (text-width <s>)
.TYPE DE
.FILE graphenv.sn
.SEE (rect-text <x> <y> <s>)

Returns the width of the text in string <s>, if it is printed with the
current font. This function uses <rect-text> if it is available, or
uses some crude heuristics.

#? (text-height <s>)
.TYPE DE
.FILE graphenv.sn

Returns the height of the text in string <s>, if it is printed with
the current font. This function uses <rect-text> if it is available,
or uses some crude heuristics.


#? ** The Drawing Context.

Several features define the drawing context.
The most usefull ones are the current driver,
the current font, the current color and the clipping rectangle.

#? (gsave <l1> ...<ln>)
Function <gsave> saves the graphics state of the current window,
evaluates lists <l1> to <ln> with a call to <progn>, and restores the
saved graphics state. Function <gsave> returns the result of the last
evaluation.

#? (gdriver)
Returns the name of the graphic driver of the current window.

#? (xsize)
Returns the width of the current window.

#? (ysize)
Returns the height of the current window.

#? window
.TYPE VAR
This variable <window> defines the current window. Most graphics
functions refers implicitly to the window descriptor stored in this
variable.

#? (clip [<x> <y> <w> <h>])

When a clip rectangle has been set, graphics output is restricted to
the inner part of the clip rectangle. the <clip> function allows for
manipulating the clip rectangle.

.IP
<(clip x y w h)> sets a new clip rectangle whose top left corner is
located at position (<x>, <y>), whose width is <w>, and whose height
is <h>.
.IP
<(clip ())> cancels clipping and unset the clipping rectangle.
.IP
<(clip)> just returns the current clipping rectangle.
.PP

Function <(clip)> always returns the previous clip rectangle, as a
list <(x y w h)>, or the empty list if no previous clipping rectangle
was set.

#? (addclip <rect>)

Argument <rect> must be a list of the form <(x y w h)>, where <x>,
<y>, <w>, and <h> are numbers.

Function <addclip> sets the current clip rectangle to the
intersection of the current clipping rectangle with a rectangle whose
top left corner is located at position (<x>, <y>), whose width is <w>,
and whose height is <h>.

If this intersection is empty, the empty list is returned.  Otherwise,
<addclip> returns the new clip rectangle.


#? ** Double Buffering and Synchronization.

#? (graphics-batch  <l1> ... <ln>)

Most graphics drivers can work with an off-screen bitmap to update the
screen after several graphics commands. The <graphics-batch> function
provides a support for this double buffering abilities.  

This function evaluates the lists <l1> to <ln>, but if a graphic
instruction is executed, the screen update is delayed until the end of
these evaluations, and is performed only once.

#? (graphics-sync)

Inside a <graphics-batch> construct, this function immediatly
updates the screen without waiting for the completion of
the <graphics-batch> instruction.



#? ** Plotting.

The following functions provide an easy way to plot curves. The basic
abstraction is the plot port data structure, a TLisp list which
contains:

.IP
The position of the current point,
.IP
A pointer to the  graphics window,
.IP
Information for mapping real coordinates to pixel positions.
.PP

The plotting functions perform their drawing action in the current
plot port. Function, <setup-axes> is provided for quickly initializing
a plot port, making it current and drawing the axes.

Currently, plot ports are implemented as lists rather than a user
defined class. In fact, the <"graphenv.sn"> package has existed prior
to the object extensions of TLisp. This silly implementation has been
kept for preserving backwards compatibility.



#? (new-plot-port <brect> <rect> <object>) 
.TYPE DE 
.FILE graphenv.sn 

Initializes a new plot port in the current window, and returns it. 

Argument <brect> is a list <(bxmin bymin bxmax bymax)> whose elements
are the pixel coordinates of the target rectangle in the current
window.

Argument <rect> is a list <(xmin ymin xmax ymax)> whose elements are the
extremal real coordinates.  No clipping is performed, except window clipping.

Argument <object> is a function generally called by <plt-plot> for drawing a
small object at the current pen location. A few predefined functions are
documented with <plt-plot>.


#? (copy-plot-port  <p> [<object>])
.TYPE DE
.FILE graphenv.sn

Returns a new plot port, with the same real to pixel coordinates and
window data as the plot-port <p>, but with a different current point
and a different object. This function allows the user to plot a second
curve simultaneously, using the same axis system.

#? (draw-axes  <brect> <xl> <yl> <name> [<x2l>] [<y2l>])
.TYPE DE
.FILE graphenv.sn

Draws axes on the leftmost and bottommost side of rectangle <brect>.

Argument <brect> is a list <(bxmin bymin bxmax bymax)> whose elements are
the pixel coordinates of the target rectangle in the current window.

Arguments <xl> and <yl> are lists of label values for the <x> and <y>
axis.  These labels are numbers expressed with the same scale than the
axes. The optional functions <x2l> and <y2l> are used to convert these
numbers into strings to display at the proper positions along the
axes. Both functions default to <str> which just prints the textual
representation of the number.

Finally, argument <name> is a string that will be printed at the top of the
<brect> using a 18 points font.


#? plot-port
.TYPE VAR
.FILE graphenv.sn

The current plot port is stored in this global variable.  Most of the
plotting functions refers implicitly to the plot port stored in
<plot-port>.

#? (setup-axes <x1> <y1> <x2> <y2> [<xst> <yst> [<s> [<object>]]])
.TYPE DE
.FILE graphenv.sn
.SEE (new-plot-port <brect> <rect> <object>) 
.SEE (draw-axes  <brect> <xl> <yl> <name> [<x2l>] [<y2l>])

Calls both <new-plot-port> and <draw-axes>, for drawing a curve in the
current window. Makes the resulting <plot-port> current. The curve
will occupy the entire window. Function <setup-axes> is the simplest
way to initialize the plotting package.

Arguments <x1> and <y1> are the lower bounds of the actual
coordinates; arguments <x2> and <y2> are the upper bounds of the
actual coordinates. The axes will be labeled every <xst> units
horizontally and every <yst> units vertically. Argument <s> is a
string that will be printed at the top of the window. <object> is the
default plot object used by <plt-plot>.

When arguments <xst> or <yst> are not provided (or are the empty
list), function <setup-axes> computes a reasonable value using the
extrema.


#? (plot-lists <lx> <ly>)
.TYPE DE
.FILE graphenv.sn

Plots a curve taking using in list <lx> as abscissas and values in
<ly> as ordinates in the current plot port. This function uses uses
<plt-draw> and <plt-plot> to draw a symbol at each data point.


#? (graph-xy <lx> <ly> <name>) 
.TYPE DE 
.FILE graphenv.sn 

Creates a convenient plot port in the current window, draws the axes,
and calls the function <plot-lists>.

#? (plot-lists-sd  <lx> <ly> <lsd>)
.TYPE DE
.FILE graphenv.sn

Plots a curve taking values in list <lx> as abscissas and values in
<ly> as ordinates. Argument <lsd> is a list of values that will be
displayed as uncertainty bars around each data point.

This function uses uses <plt-draw>, <plt-sd> and <plt-plot> to draw a
symbol and an uncertainity bar at each data point.

#? (graph-xyv  <lx> <ly> <lsd> <name>)
.TYPE DE
.FILE graphenv.sn

Creates a convenient plot port in the current window, draws the axes,
and calls the function <plot-lists-sd>.



#? (plt-clear)
.TYPE DE
.FILE graphenv.sn

Clears the current point. The the next <plt-draw> will thus not draw a
line.

#? (plt-move <x> <y>)
.TYPE DE
.FILE graphenv.sn

Sets the current point to real coordinates <x> and <y>.

#? (plt-draw  <x y)
.TYPE DE
.FILE graphenv.sn

Draws a line from current point to actual coordinates <x> and <y>.
Sets the current point to coordinates <x> and <y>.  Nothing is drawn
if no current point was set.

#? (plt-plot  <x> <y>)
.TYPE DE
.FILE graphenv.sn
.SEE current-object
.SEE object-size

Moves the current point to the actual coordinates <x> and <y>, and
draws a small symbol like those used for showing the data points on a
curve.

The shape of this symbol is defined by the argument <object> of
<new-plot-port> or <setup-axes>. this argument must be a function that
draws the object at the specified position. The following functions
are predefined:

.IP
<object-nil> does nothing. It is useful if you want cancel the
effect of <plt-plot>.
.IP
<open-square>, <closed-square>, <open-circle>, and <closed-circle>
respectively draw a small hollow square, a small filled square, a
small hollow circle or a small filled circle.
.IP
<open-up-triangle>, <closed-up-triangle>, <open-down-triangle>,
<closed-down-triangle>, draw various kind of small triangles.
.IP
<straight-cross> and <oblique-cross> draw small crosses.
.PP

All these predefined object functions use the global variable
<object-size> for defining the size of the object drawn by <plt-plot>.
The default object may be overridden by setting the variable
<current-object> to a new object function.

#? (plt-sd  <x> <y> <sd>)
.TYPE DE
.FILE graphenv.sn

Draws a standard deviation bar given by <sd> around point (<x>,<y>).
The horizontal size of the bar is defined by the global variable
<object-size>.


#? (in-plot-port <l1> ... <ln>)
.TYPE DMD
.FILE graphenv.sn

Function <in-plot-port> unpacks the current plot port info and stores
it in local variables while executing <l1> ... <ln>.  You may then
call the <(plt-rbx x)> and <(plt-rby y)> functions to compute the
pixel coordinates of a real point (<x>,<y>).

#? current-object
.TYPE VAR
.FILE graphenv.sn
.SEE (plt-plot  <x> <y>)

If <current-object> is equal to the empty list, the function
<plt-plot> will draw the default object defined in the current port.
However you can store a new object definition function in
<current-object>. This function will then be called instead of the
default one.

#? object-size
.TYPE VAR
.FILE	graphenv.sn
.SEE (plt-plot  <x> <y>)
.SEE (plt-sd <x> <y> <sd>)

This global variable controls the size of the drawings performed by
<plt-plot> and <plt-sd>.




#? ** Events.
.SEE Ogre.

A few functions can be used for handling mouse and keyboard events
occurring on windows. TLisp controls a centralized event queue.  It is
possible to obtain the events occuring on a window by creating an
<EventLock> object. Messages <read-event> and <check-event> allow for
testing and waiting for events.

This mechanism is used by a few handy functions <get-click>,
<get-vector> and <get-rect>, as demonstrated by the function <snpaint>
below:

.VP
(de snpaint()
    (let ((window ()))
      (new-window)
      (draw-line 2 5 18 5)
      (draw-rect 22 2 18 8)
      (fill-rect 42 2 18 9)
      (gprintf 102 10 "Quit")
      (clip 0 12 1000 1000)
      (let ((ok t)
	    (mode draw-line)
	    (echo get-vector))
	(while ok
	   (let (((x y) (get-click)))
	     (cond
	      ((> y 10)
	       (apply mode (echo)) )
	      ((point-in-rect x y '(0 0 20 10))
	       (setq mode draw-line echo get-vector) )
	      ((point-in-rect x y '(20 0 20 10))
	       (setq mode draw-rect echo get-rect) )
	      ((point-in-rect x y '(40 0 20 10))
	       (setq mode fill-rect echo get-rect) )
	      ((point-in-rect x y '(100 0 20 10))
	       (setq ok ()) )) ) ) )
      (delete window) ) )		
.PP


#? * Event Functions.

#? (new EventLock <window>)
.FILE graphenv.sn

Creating an <EventLock> object sets up window <window> to record
graphical events in the event-queue. Events can be retrieved with
messages <read-event> and <check-event>.

The initial state of the window is restored when the <EventLock>
object is destroyed.

#? (==> <EventLock> read-event)
.FILE graphenv.sn
.SEE Event Lists.
.SEE (eventinfo)

This function returns the first available event on the window
associated to the <EventLock> object. Each event is represented
by a list whose first element broadly describes the event type.
Additional information can be obtained using function <eventinfo>. 

If the event queue is empty,
this function blocks until an event occurs.


#? (==> <EventLock> check-event)
.FILE graphenv.sn
.SEE Event Lists.
.SEE (eventinfo)

This function returns the first available event on the window
associated to the <EventLock> object. Each event is represented
by a list whose first element broadly describes the event type.
Additional information can be obtained using function <eventinfo>. 

This function returns the empty list when no events are available.


#? (hilite <mode> <x1> <y1> <x2> <y2>)

The <hilite> function is used for displaying transient drawings when
the mouse button is depressed. As soon as the mouse button is
released, these transient drawings are cleared, and the window is
refreshed.

Four kinds of drawings are supported, whose names are defined by
<"graphenv.sn">:

.IP
When <mode> is <hilite-invert>, the rectangle defined by the points
(<x1>,<y1>) and (<x2>,<y2>) is inverted. The result however is
poor on color displays.
.IP
When <mode> is <hilite-rect>, the rectangle defined by the points 
(<x1>,<y1>) and (<x2>,<y2>) is outlined with a dashed line.
.IP
When <mode> is <hilite-line>, a dashed line is drawn from point 
(<x1>,<y1>) to point (<x2>,<y2>).
.IP
When <mode> is <hilite-none>, any transient graphics are cleared, and
the window is refreshed.
.PP

Transient drawings created with <hilite> are very efficient, and
totally disappear when the mouse button is released. This function is
useful for providing an echo to the user during a mouse drag
operation. For example, function <hilite> can display a rectangular
outline while the user is dragging the mouse for selecting a part of
an image.


#? (get-click [<rect>])
.TYPE DE
.FILE graphenv.sn

Waits for a mouse click on the current window.  Returns a list <(x y)>
giving the coordinates of the mouse during the mouse click.  Mouse
clisks will be ignored outside the rectangle specified by the optional
argument <rect>.

#? (get-vector [<rect>])
.TYPE DE
.FILE graphenv.sn

Waits for a mouse down on the current window.  Tracks the mouse moves
with a dashed line, until the mouse button is released.  Returns a
list <(x1 y1 x2 y2)> telling where the mouse button has been depressed
and where it has been released.

The optional argument <rect> indicates a bouding rectangle which must
entirely contain the resulting vector. The echoed dashed line reflects
then this limitation.

#? (get-rect [<rect>])
.TYPE DE
.FILE graphenv.sn

Waits for a mouse down on the current window.  Tracks the mouse moves
with a dashed rectangle, until the mouse button is released.  Returns
a list <(x y w h)> telling the location of the top left corner of the
rectangle, its width and its height.

The optional argument <rect> indicates a bouding rectangle which must
entirely contain the resulting rectangle. The echoed dashed rectangle
reflects then this limitation.


#? * Event Lists.
.SEE (eventinfo)

Events returned by methods <read-event> and <check-event> are encoded
as lists, according to the following templates:

.IP
<(mouse-down x y)>:
The mouse button has been depressed at position (<x>,<y>).
You may use function <eventinfo> to query the identity of the
button and the status of the shift and control keys.
.IP
<(mouse-drag x_1 y_1 x_2 y_2)>:
The mouse button has been depressed at position (<x1>,<y1>).The
mouse has then been moved to position (<x2>,<y2>). The mouse button
still is depressed. 
You may use function <eventinfo> to query the identity of the
button and the status of the shift and control keys.

.IP
<(mouse-up x_1 y_1 x_2 y_2)>:
The mouse button has been depressed at position (x_1,y-1). The mouse
has then been moved to position (x_2,y_2), where the button has been
released.
You may use function <eventinfo> to query the identity of the
button and the status of the shift and control keys.
.IP
<("c" x y)>:
The key associated to the single character string <"c"> has been hit,
while the mouse pointer was located at position (<x>,<y>). These
events often are referred as keypress events.
.IP
<(arrow-left x y)>, <(arrow-right x y)>,
<(arrow-up x y)> or <(arrow-down x y)>:
The left (respectively right, up and down) arrow has been hit, while
the mouse pointer was located at position (<x>,<y>).
You may use function <eventinfo> to query the exact identity of the
depressed key and the status of the shift and control keys.
.IP
<(help x y)>:
The keyboard dependent help key has been hit, while the mouse pointer
was located at position (<x>,<y>).
You may use function <eventinfo> to query the exact name of the
depressed key and the status of the shift and control keys.
.IP
<(fkey x y)>:
A function key has been depressed. You must use function <eventinfo>
to get more information about the identity of the function key
and of the status of the shift and control keys.
.IP
<(resize w h)>
The window has been resized by the user, and is now <w>x<h> pixels large.
.IP
<(delete)>:
Windowing systems often provides a mean to delete a window. For
example, X11 ICCM compliant window managers are able to send a
WM_DELETE message to a client. If an event handler is attached to the
window, a delete event is added to the event queue, and the window is
not destroyed. A program thus gets a chance to display a confirmation
dialog before deleting the window.
.IP
<(sendevent x y)>:
These event is generated by function <sendevent>. Integer values <x>
and <y> are arbitrary.
.PP
These few events give enough information for building graphics
interfaces. The class library <"ogre.sn"> is designed for that
purpose.


#? * Events Implementation.

As soon as an event handler has been defined for the window, using
<set-event-handler>, all events occurring on this window are enqueued
on the centralized event queue.  The functions <waitevent> and
<checkevent> are used for removing events from the TLisp event queue.

In addition, the function <event-hook> is called whenever new events
are available on the queue, and the function <idle-hook> is called
whenever the event queue is empty. These calls occur either
asynchronously during a read on the TLisp input, or synchronously
during the execution of the function <process-pending-events>.

These automatic call allow the implementation of asynchronous graphic
interfaces, like those defined with the library <"ogre.sn">.

#? (set-event-handler <w> <h>)
.SEE Ogre.

Attach an event handler <h> to window  <w>.
 
Once an event handler has been attached to a window, graphics events
occuring on that window, like mouse or keyboard interaction, are
recorded on the TLisp event queue, and flagged with the event handler.
The event handler actually is a key for accessing events.

Any non nil TLisp object is a legal event handler. When the
<"ogre.sn"> library is running however, <manage-event> messages are
automatically sent to the event handler by the <event-hook> function.
It is thus unsafe to attach an event handler which is not an instance
of a subclass of class <VisualObject>.

#? (checkevent [<h>])
.SEE Event Lists.

The checkevent function returns the next available event on the
current window.  This event is then removed from the event queue. When
an event handler <h> is provided, function <checkevent> examines the
events associated to the indicated event handler.

There is a special case when argument <h> is the empty list <()>.
Function <checkevent> returns then the event handler for which one or
several events are available. It does not remove the event from the
event queue.

Function <checkevent> always returns the empty list <()> if no events
are pending.

#? (eventinfo)

Function <eventinfo> returns a list providing more information
about the last event returned by function <checkevent>.
This list contains:
.IP
The exact name of the key or mouse button involved in the event.
Since key and mouse button names are quite machine dependent, 
your event handling procedure should always use this name as a hint
rather than expecting well defined values.
.IP
A boolean value <t> or <()> describing the state of the shift key
when the event occurred.
.IP
A boolean value <t> or <()> describing the state of the control key
when the event occurred.


#? (testevent)

Function <testevent> returns the first event available on the current
window without removing it from the queue. It returns <()> if no
events are pending.

#? (sendevent <x> <y>)

This function posts an event <sendevent x y> on the event queue for
the current window.

#? (waitevent)

If no events are available on the TLisp event queue, waitevent waits
for user interaction, and returns the event handler associated to the
first resulting event.  If events are available on the event queue,
function <waitevent> immediatly returns the event handler associated
to the first available event.


#? (event-hook)
.TYPE DE

While TLisp is waiting for user commands on the standard input during
the execution of a read call, the <event-hook> function is
repetitively called until the event queue becomes empty. Whenever the
event queue becomes empty, TLisp calls the <idle-hook> function once.

Exercise care when defining or modifying those functions. An erroneous
definition sometimes causes Tlisp to enter a deadly infinite loop.

#? (idle-hook)
.TYPE DE

While TLisp is waiting for user commands on the standard input during
the execution of a read call, the <event-hook> function is
repetitively called until the event queue becomes empty. Whenever the
event queue becomes empty, TLisp calls the <idle-hook> function once.

Exercise care when defining or modifying those functions. An erroneous
definition sometimes causes Tlisp to enter a deadly infinite loop.


#? (process-pending-events)

This function repetitively calls <event-hook>, until the event queue
becomes empty. It calls then the <idle-hook> function once. If new
events have occurred during the execution of <idle-hook>, the process
is restarted.

The <process-pending-events> function returns when no events are
available on the event queue. Of course, <process-pending-events>
immediatly returns if the <event-hook> and <idle-hook> functions are
undefined.

Long TLisp programs should sometimes call this function. Event driven
interfaces thus remains active during the program execution.


#? ** System Specific Graphic Functions

TL3 provides also system specific functions.
The name of these functions always begin with the name
of the supported graphic system.  For example, "x11" is the
prefix for X-Windows specific functions and "win" is 
the prefix for Windows (95 and NT) specific functions.



#? * Specific graphic functions for X11

The following functions are only implemented on 
Unix systems implementing the X Windows standard.
This includes ``Motif'' and ``OpenWindows'' based systems.


#? (x11-window  [[[<x> <y>] <w> <h>] <name>])
.SEE (new-window [[<x> <y>] <w> <h>] [<name>])

This is the low level function called by <new-window>
on X Windows systems.

This function creates a window of size <w> and <h> at position <x> and
<y> named <name> on the default X Windows screen. During the first
call of function <x11-window>, TLisp searches the variable <display>
and the environment variable DISPLAY for the name of the X Windows
server and display to use.

Unlike <new-window>, this function does not store the newly created
window in the variable <window>, and thus does not make this window
current.


#? (x11-fontname <s>)
.SEE (font [<fontname>])

This function comes with the X11 driver. It converts a legal
PostScript(TM) font name, into a X11 font name.

String <s> must be a legal PostScript font name, composed of a font
family, an optional font style, and a font size, possibly separated by
dashes, like <"Helvetica-18">, <"Times-Roman24">, <"Courier-Bold-12">.
This function returns the corresponding font name under the X11.
conventions.

Example:
.EX (when x11-fontname (x11-fontname "Times-Roman18"))

#? (x11-depth)

Returns the depth of the current screen.

#? (x11-lookup-color <name>)

Lookup the (R,G,B) components of a color named <name>.


#? (x11-configure [<raise> <x> <y> <w> <h>])

Changes the window location (<x>,<y>) and size (<w>,<h>).  Giving the
empty list as argument leaves the corresponding characteristic
unchanged. When argument <raise> is true, the window is deiconified
and raised.

This function works only with X11R4 or greater. When effective, it
returns a list <(visible w h)> whose elements indicate the window
visibility and size.


#? (x11-text-to-clip <text>)

This function stores string <text> into the X11 copy/paste mechanism.
This function will some day recognize the copy/paste protocol used and
behave accordingly.

It implements today a cut buffer based mechanism suitable for
exchanging text with emacs and xterm. We plan to support selection as
soon as possible.


#? (x11-clip-to-text)

This function retrieves a string from the X11 copy/paste mechanism. It
returns the empty list <()> if no string is available. This function
will some day recognize the copy/paste protocol used and behave
accordingly.

It implements today a cut buffer based mechanism suitable for
exchanging text with emacs and xterm. We plan to support selection as
soon as possible.




#? * Specific graphic functions for Windows 95 and NT

The following functions are only implemented on Windows 95 and NT.


#? (wbm-window  [[[<x> <y>] <w> <h>] <name>])
.SEE (new-window [[<x> <y>] <w> <h>] [<name>])
.SEE (wbm-toplevel-window  [[[<x> <y>] <w> <h>] <name>])

This is the low level function called by <new-window>
on Windows 95 and NT systems. This function is available
under WinTL3 only.

Function <wbm-window> creates a window of size <w> and <h> 
at position <x> and <y> named <name> in the WinTL3 environment.  
The command line version of TL3 cannot create graphic windows yet.

Unlike <new-window>, this function does not store the newly created
window in the variable <window>, and thus does not make this window
current.


#? (wbm-toplevel-window  [[[<x> <y>] <w> <h>] <name>])
.SEE (new-window [[<x> <y>] <w> <h>] [<name>])
.SEE (wbm-window  [[[<x> <y>] <w> <h>] <name>])

This function is very similar to function <wbm-window>
described above. Instead of creating a child window
of the main WinTL3 window (according to the Windows MDI scheme),
function <wbm-toplevel-window> creates a toplevel window
that is not attached to the main WinTL3 window.


#? (wpr-window [[<w> <h>] <name>])
.SEE (print-window <w> <h> [<destination>])
.SEE (wpr-printers)

This is the low level function called by <print-window>
on Windows 95 and NT systems.

Function <wpr-window> creates a window descriptor which actually
accesses the printer named <name>. The default printer
is used if argument <name> is not specified. Function
<wpr-printers> should be used to obtain the list
of valid printer names.

Unlike <new-window> or <print-window>, 
this function does not store the newly created
window in the variable <window>, and thus does not make this window
current.

Arguments <w> and <h> specify the width and height 
of the coordinate system. The drawings will be scaled to fit
the size of the page returned by your printer.


#? (wpr-printers)
.SEE (wpr-window [[ <w> <h>] <name>])

This function returns a list of printers names suitable
for function <wpr-window>. The default printer name comes first.


#? (win-depth)

Returns the depth of the default display of your computer.
This is the number of bits specified in the Display Properties
dialog box.


#? (win-configure [<raise> <x> <y> <w> <h>])

Changes the window location (<x>,<y>) and size (<w>,<h>).  Giving the
empty list as argument leaves the corresponding characteristic
unchanged. When argument <raise> is true, the window is deiconified
and raised.

This function returns a list <(visible w h)> whose elements
indicate the window visibility and size.

#? (win-text-to-clip <text>)

This function stores string <text> into the clipboard.

#? (win-clip-to-text)

This function retrieves a string from the clipboard.
It returns () if the clipboard does not currently contain a string.




#? * Knowing how a system dependent feature is supported.

The function <gdriver-feature> implements a small database
about the features supported by the common graphic drivers.
We suggest you use this function to implement portable
programs.

#? (gdriver-feature <feat> <opt>)

This function provides a portable mean to scan the current
graphic system for a feature. It returns the function
implementing the feature specified by symbol <feat> on the
given window. The result depends on the parameter <opt>.
.IP
When <opt> is symbol <loose>, this function always
returns a function. It returns the feature function
as soon as a partial implementation exists.
It returns function <progn> if the feature is
not implemented.

This option is usefull for calling minor services
(e.g. puting text into the clipboard)
for which failure has little consequence.
.IP
When <opt> is symbol <strict>, this function returns
a function if and only if the feature is fully implemented.
It returns the empty list otherwise.
.PP

Features are the following.
.IP 
<depth>:
This feature is a generalization of <x11-depth>.
.IP 
<text-to-clip>:
This feature is a generalization of <x11-text-to-clip>.
.IP
<clip-to-text>:
This feature is a generalization of <x11-clip-to-text>.
.IP
<configure>:
This feature is a generalization of <x11-configure>.
.IP
<fontname>:
This feature is a generalization of <x11-fontname>.
.IP
<lookup-color>:
This feature is a generalization of <x11-lookup-color>.
.PP

Here is an example of the use which can be made of
<gdriver-feature>.
.VP
? (new-window 400 400 400 400 "test")
= ::WINDOW:X11:8c440
? ((gdriver-feature 'configure 'loose) () 300 300 400 400)
= (t 400 400)
.PP





#? ** Producing Encapsulated PostScript Files.

TL3 can output graphics commands into an Encapsulated PostScript
File (EPS). You can then send these files to a PostScript printer
or use adequate software packages to modify these files and integrate
them into your documents.  There is even a TL3 command that 
tranlates these files into a sequence of TL3 drawing commands.

Note: Many computers use incompatible conventions for
marking the end of lines (Unix machines use the character NL, Macs use
the character CR and PC use a sequence CR NL.)
Several popular software exhibit a strange behavior when they attempt
to read a sequence of characters which appears to them as a very long
line.  You must probably use a text filter like <dos2unix> to convert
your EPS files.



#? (ps-window [[<w> <h>] <name>])
.SEE (print-window <w> <h> [<destination>])

Function <ps-window> is the low level function called by
<print-window> on systems that provide no other alternative.
All versions of TL3 however support Encapsulated PostScript
files.

Function <ps-window> returns a window descriptor which actually 
writes PostScript commands into a file named <name>. 
When argument <name> is omitted, the
PostScript commands are written to file <"tloutput.ps">.

Unlike <new-window> or <print-window>, this function does not store 
the newly created window in the variable <window>, and thus does not 
make this window current.

Arguments <w> and <h> specify the width and height 
of the coordinate system. The target rectangle will be scaled 
to fit a standard A4 or Letter format page.


#? (gspecial <string>)

This function sends a system specific command represented
by string <string>. This function is ignored if
the graphics driver does not recognize the string <string>.
In the case of a window descriptor created with <ps-window>,
the string <string> is inserted verbatim into the 
Encapsulated PostScript file. 


#? (ps-play <filename> [<function>])
.SEE (ps-window [[[<x> <y>] <w> <h>] <name>])

This function interprets PostScript files created with <ps-window>.  
Function <ps-play> parses the PostScript file <filename>, converts
it into a sequence of SN calls, and applies function <function> to
these calls.  The default value for the optional argument
<function> is <eval>. Function <ps-play> thus plays the contents of
the PostScript file in the current window.

Exemples: 

To play a EPS file into a window, type:
.VP
? (let ((window (new-window)))
   (ps-play "your_file.ps") )
.PP

To see the contents of a EPS file, type:
.VP
? (ps-play "your_file.ps" pprint)
.PP
Note: This function only interprets PostScript files created by the
TL3 PostScript driver. It is by no means a complete PostScript 
interpreter.  


#? (ps-plot <filename> <x> <y> <w> <h> [<bb-overrule>])
.SEE (ps-play <filename> [<function>]) 

This function plots EPS-files created with SN or TL3 in the window
referred to by the symbol <window> in the region determined by <x> <y>
<w> and <h>. <x> <y> correspond to the coordinates of the region's
upper-left corner, <w> to its width and <h> to its height. The plot is
scaled to fill exactly this region using the EPS <"%%BoundingBox">
directive which can be overruled by the optional <bb-overrule>
parameter. If <w> or <h> are 0 or nil, scaling in their
respective directions are choosen as to preserve proportions. 
If both <w> and <h> are 0 or nil, no scaling is performed.







#? ** Graphical Utilities.

A couple of TLisp functions perform elementary computations on
rectangles. A rectangle is stored as a list <(x y w h)>. The first two
elements <x> and <y> are the coordinates of its top left corner; <w>
is its width, <h> its height.


#? (rect-2-ppbrect <r>)
.TYPE DE
.FILE graphenv.sn

Returns rectangle <r> under a format suitable for using with
<new-plot-port>.


#? (window-rect)
.TYPE DE
.FILE graphenv.sn

Returns the boundaries of the current window as a rectangle.

#? (point-in-rect <x> <y> <r>)

The point-in-rect function returns <t> if point (<x>,<y>) is located
inside rectangle <r>.

#? (rect-in-rect <r1> <r2>)

The <rect-in-rect> function returns <t> if rectangle <r2> encloses
rectangle <r1>.

#? (collide-rect <r1> <r2>)

Returns the intersection of <r1> and <r2>. If rectangle <r1> and <r2>
do not intersect, <collide-rect> returns the empty list.

#? (bounding-rect <r1> <r2>)

Returns the smallest rectangle that encloses both 
rectangles <r1> and <r2>.





