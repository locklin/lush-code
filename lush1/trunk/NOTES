
oostruct.c:
        Implement typed version of defclass.

unix.c:
        Lack of ALARM support
        Move DLOPEN support elsewhere

x11_driver.c:
        Lack of OPENGL support

idx-base.lsh:
        Add TL3 compat matrix functions.
        Check SN2/TL3 matrix emulation.

module.c:
        Document new lush functions.
        Add support for primitive methods.

dh.c:



----------------------------------------------
Documentation update
----------------------------------------------

TL3 * import_raw_matrix
TL3 * import_text_matrix
TL3 * export_raw_matrix
TL3 * export_text_matrix
TL3 * save_matrix
TL3 * save_ascii_matrix
TL3 * load_matrix
TL3 * map_matrix          
DELETED * save_flt_matrix
DELETED * save_packed_matrix
DELETED * map_pmatrix
SN3 * putmethod, defmethod, demethod, dfmethod, dmmethod
TL3 * mapfor mapwhile
TL3 * nfirst
LUSH * (makeclass <classname> <superclass> <slotnamelist> <slotdefaultlist>)
LUSH * (defclass <classname> <superclass> <...slots...> )    [DM]
SN3 * new_unode, unode_val, unode_uid, unode_eq, unode_unify
TL3 * alist_add, alist_get
LUSH * getp, putp
LUSH * defvar
LUSH * package private


----------------------------------------------
LUSH Specific doc
----------------------------------------------

#? (defvar name val)

Defines a new variable named <name> (a symbol) and initialized with value
<val>.  Traditionally function <setq> was used for that purpose in SN/TLisp.
There are cases however when <setq> refuses to create a new global variable.
Eventually we will completely disallow creating global variables with <setq>
and require the use of <defvar> for that purpose.

#? (private <..symbols..>

This function must be used inside a package definition.
It indicates that the symbols <..symbols..> must be considered
private to the package.
.SEE (package <name> <..expressions..>)

#? (package <name> <..expressions..>) 

This function provides a simple way to identify symbols that should remain
private to a group of functions.  Symbol <name> is used to identify the group
of functions.  Function <package> maintains a list of hidden symbols declared
with function <private>.  Each expression is first transformed to replace all
occurences of a hidden symbol by a new symbol whose name is composed by
prepending the package name <name>, then evaluated as usual.

Example:
.VP
   (package foobar
      (private foo)   
      (de foo(x) (print x)) 
      (de bar(x) (foo x)) )
.PP
defines a global symbol <bar>.
Symbol <foo> however was renamed as <foobar.foo> in all 
expressions occuring after <(private foo)>.  Hence the
actual definition of the two above functions read as:
.VP
(de bar (x)
  (toto.foo x) )
(de toto.foo (x)
  (print x) )


#? (makeclass <classname> <superclass> <slotnamelist> <slotdefaultlist>)

Creates and return a new class named <classname>.  The new class inherits
class <superclass>.  List <slotnamelist> contains the names of the additional
slots defined by the new class.  List <slotdefaultlist> contains the default
values for these slots.  Both lists are in reverse order (i.e. the first slot
in the list appears last when pretty-printing the class).  This function does
not set the value of symbol <classname>.  Use the macro function <defclass>
for that.


#? (putp <anything> <name> <value>)

Every Lush object (atoms, cons, etc.) may be enriched by defining properties
identified by a symbolic name.  Function <putp> is used to define such 
properties.  Its first argument is an arbitrary Lush object <anything>.
Function <putp> sets the property named by symbol <name> to value <value>.
Properties can be later retrieved using <getp>.

#? (getp <anything> <name>

Retrieves the property <name> for the Lush object <anything>.



----------------------------------------------
LUSH changes to TL3 documentation
----------------------------------------------



#? (bwrite <l1> ... <ln>)
.SEE (bread)

Function <bwrite> writes the lisp objects <l1> to <ln> on the current
output stream as a sequence of binary tokens.  This function is able 
to write correctly lisp objects with circular references. It cannot 
however write lisp objects useful for their side effects like open 
file descriptors or windows.

#? (bwrite-exact <l1> ... <ln>)
.SEE (bwrite <l1> ... <ln>)
.SEE (bread)

Function <bwrite-exact> is similar to <bwrite> with a few twists
that makes it more accurate but less frequently useful.
.IP
Function <bwrite> writes objects by first specifying the class name.  This
implies the class must be defined and have the same name when reading the
object.  Function <bwrite-exact> instead writes a complete definition of the
class.  This implies that <bread> will create a new unnamed class regardless
of the existing classes.
.IP
Function <bwrite> writes indexes by saving their content regardless of how
the index is laid out in the corresponding storages.  This implies that
<bread> will create a new storage for each of them.  Function <bwrite-exact>
instead writes the storage and the index layout.  But this is wasteful
if the storage is much larger than the index.


#? (bread)
.SEE (read)

Function <bread> reads on the current input stream a binary sequence of tokens
and builds the corresponding lisp object.  Functions <read> and <load> are
also able to recognize binary tokens in the middle of a text file. This allows
for reading a file containing a mixture of lisp objects representing as binary
sequence of tokens or as text.


#? (bread-exact)
.SEE (bread)

Function <bread-exact> is similar to <bwrite> with one twists
that makes it more accurate but less frequently useful.
.IP
Saving an instance of a user defined class with <bwrite> saves only the slots
of the instance and a reference to the class name.  Function <bread> will be
able to read this binary file if the class has already been defined in the
interpreter.  This class must define the same slots with the same order as the
class of the actual object stored in the file.  Additional slots will just be
skipped and left with their default value.  Function <bread-exact> instead
causes an error when there are additional slots.
.PP
Note that both <bread> and <bread-exact> can read files produced
by either <bwrite> or <bwrite-exact>.  There is no difference between
<bread> and <bread-exact> when reading a file produced by <bwrite-exact>.



----------------------------------------------
Not for lush-1.0
----------------------------------------------

- win32 port (cygwin)

        


