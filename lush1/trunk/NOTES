r


----------------------------------------------
TODO
----------------------------------------------



oostruct.c:
        Implement typed version of defclass.

unix.c:
        Lack of ALARM support

x11_driver.c:
        Lack of OPENGL support

idx-base.lsh:
        Add TL3 compat matrix functions.
        Check SN2/TL3 matrix emulation.

dh.c:
lisp_c.c:
        Everything to do!
        



----------------------------------------------
Documentation update
----------------------------------------------

TL3 * import_raw_matrix
TL3 * import_text_matrix
TL3 * export_raw_matrix
TL3 * export_text_matrix
TL3 * save_matrix
TL3 * save_ascii_matrix
TL3 * load_matrix
TL3 * map_matrix          
DELETED * save_flt_matrix
DELETED * save_packed_matrix
DELETED * map_pmatrix
SN3 * putmethod, defmethod, demethod, dfmethod, dmmethod
TL3 * mapfor mapwhile
TL3 * nfirst
LUSH * (makeclass <classname> <superclass> <slotnamelist> <slotdefaultlist>)
LUSH * (defclass <classname> <superclass> <...slots...> )    [DM]
SN3 * new_unode, unode_val, unode_uid, unode_eq, unode_unify
TL3 * alist_add, alist_get
LUSH * getp, putp
LUSH * defvar
LUSH * package private
DELETED * mod-dlopen  [use mod-load instead]


----------------------------------------------
LUSH Specific doc
----------------------------------------------

#? (defvar name val)
Defines a new variable named <name> (a symbol) and initialized with value
<val>.  Traditionally function <setq> was used for that purpose in SN/TLisp.
There are cases however when <setq> refuses to create a new global variable.
Eventually we will completely disallow creating global variables with <setq>
and require the use of <defvar> for that purpose.

#? (private <..symbols..>
This function must be used inside a package definition.
It indicates that the symbols <..symbols..> must be considered
private to the package.
.SEE (package <name> <..expressions..>)

#? (package <name> <..expressions..>) 
This function provides a simple way to identify symbols that should remain
private to a group of functions.  Symbol <name> is used to identify the group
of functions.  Function <package> maintains a list of hidden symbols declared
with function <private>.  Each expression is first transformed to replace all
occurences of a hidden symbol by a new symbol whose name is composed by
prepending the package name <name>, then evaluated as usual.

Example:
.VP
   (package foobar
      (private foo)   
      (de foo(x) (print x)) 
      (de bar(x) (foo x)) )
.PP
defines a global symbol <bar>.
Symbol <foo> however was renamed as <foobar.foo> in all 
expressions occuring after <(private foo)>.  Hence the
actual definition of the two above functions read as:
.VP
(de bar (x)
  (toto.foo x) )
(de toto.foo (x)
  (print x) )


#? (makeclass <classname> <superclass> <slotnamelist> <slotdefaultlist>)
Creates and return a new class named <classname>.  The new class inherits
class <superclass>.  List <slotnamelist> contains the names of the additional
slots defined by the new class.  List <slotdefaultlist> contains the default
values for these slots.  Both lists are in reverse order (i.e. the first slot
in the list appears last when pretty-printing the class).  This function does
not set the value of symbol <classname>.  Use the macro function <defclass>
for that.


#? (putp <anything> <name> <value>)
Every Lush object (atoms, cons, etc.) may be enriched by defining properties
identified by a symbolic name.  Function <putp> is used to define such 
properties.  Its first argument is an arbitrary Lush object <anything>.
Function <putp> sets the property named by symbol <name> to value <value>.
Properties can be later retrieved using <getp>.

#? (getp <anything> <name>)
Retrieves the property <name> for the Lush object <anything>.


#? (fileinfo <filename>)
Returns an a-list containing lots of information about 
the file named <filename>.  This function returns nil
if the named file does not exist.
.EX (fileinfo ".")




----------------------------------------------
LUSH changes to TL3 documentation
----------------------------------------------


#? (libload <libname>)
.SEE (load  <in> [<out> [<prompt>]])
.FILE sysenv.lsh
Function <libload> loads the lisp file <libname>
when either of the following condition is true:
.IP
The file <libname> was never loaded using <libload>.
.IP
The file <libname> has been modified since the last time 
it was loaded using <libload>.
.IP
A dependency of <libname> has been modified since the last time 
it was loaded using <libload>.  The dependencies of <libname> 
are those lisp files that were loaded using <libload> in the 
body of file <libname>.
.PP
In other words, function <libload> provides a functionality 
similar to the well known unix tool <"make">.
This is achieved by recoding the loading date of all
files loaded using <libload> as well as the list
of all files loaded using <libload> as a consequence
of a first call to <libload>.


#? (bwrite <l1> ... <ln>)
.SEE (bread)
Function <bwrite> writes the lisp objects <l1> to <ln> on the current
output stream as a sequence of binary tokens.  This function is able 
to write correctly lisp objects with circular references. It cannot 
however write lisp objects useful for their side effects like open 
file descriptors or windows.

#? (bwrite-exact <l1> ... <ln>)
.SEE (bwrite <l1> ... <ln>)
.SEE (bread)
Function <bwrite-exact> is similar to <bwrite> with a few twists
that makes it more accurate but less frequently useful.
.IP
Function <bwrite> writes objects by first specifying the class name.  This
implies the class must be defined and have the same name when reading the
object.  Function <bwrite-exact> instead writes a complete definition of the
class.  This implies that <bread> will create a new unnamed class regardless
of the existing classes.
.IP
Function <bwrite> writes indexes by saving their content regardless of how
the index is laid out in the corresponding storages.  This implies that
<bread> will create a new storage for each of them.  Function <bwrite-exact>
instead writes the storage and the index layout.  But this is wasteful
if the storage is much larger than the index.


#? (bread)
.SEE (read)
Function <bread> reads on the current input stream a binary sequence of tokens
and builds the corresponding lisp object.  Functions <read> and <load> are
also able to recognize binary tokens in the middle of a text file. This allows
for reading a file containing a mixture of lisp objects representing as binary
sequence of tokens or as text.


#? (bread-exact)
.SEE (bread)
Function <bread-exact> is similar to <bwrite> with one twists
that makes it more accurate but less frequently useful.
.IP
Saving an instance of a user defined class with <bwrite> saves only the slots
of the instance and a reference to the class name.  Function <bread> will be
able to read this binary file if the class has already been defined in the
interpreter.  This class must define the same slots with the same order as the
class of the actual object stored in the file.  Additional slots will just be
skipped and left with their default value.  Function <bread-exact> instead
causes an error when there are additional slots.
.PP
Note that both <bread> and <bread-exact> can read files produced
by either <bwrite> or <bwrite-exact>.  There is no difference between
<bread> and <bread-exact> when reading a file produced by <bwrite-exact>.



#? * Representing Associations with Hash Tables.
...
.IP
The most useful hash tables use the logical equality, as implemented by
function <=>. Two objects are logically equal if they convey the same useful
information. These hash table work properly as long as you do not modify the
objects used as keys by the hash table.  This can happen if you used arrays or
custom objects as keys in your hash table. See the description of function
<htable-rehash> for more information about this point.
.IP
Hash tables can also rely on pointer equality, as implemented by function
<==>.  These hash tables are useful to associate a piece of information with a
particular lisp object.  Functions <getp> and <putp>, for instance, make use
of pointer-equality hash tables.  The associations of a pointer-equality 
hash table are automatically removed when the key object is deallocated.




----------------------------------------------
MODULES
----------------------------------------------


#? ** Modules.

This section describes a set of function aiming at dynamically linking object
files (commonly referred to as ``.o'' files) containing new C functions. Such
object modules can define new Lisp functions, or provide support functions for
other object modules.

Lush unifies two sets of function for dynamically linking modules.
.IP
The TL3 style dynamic linking is described at length in the "TL/Open" documentation.  
It internally relies on the operating system provided dynamic linking capabilities.
.IP
The SN3 style dynamic linking offers vastly superior possibilities.
It internally relies on the GNU-BFD library and is able to dynamically link
and unlink aribitrary object files.  This piece of documentation
describes the SN3 style dynamic linking.
.PP


Here is an example of a file, named <"essai.c">, which defines a new
lisp function written in C for computing the square of the hypotenuse
of certain triangles.

.VP
   /* ------ Beginning of File "essai.c" ------ */

   #include "header.h"

   /* This is my function */

   real hypotenuse(x,y)
   real x,y;
   {
     real z = x*x + y*y; 
     printf("hypot(%f,%f)=%f\n",x,y,z);
     return z;
   }
   
   
   /* This is the interface */
   
   DX(xhypotenuse) {
     ARG_NUMBER(2); 
     ALL_ARGS_EVAL;
     return NEW_NUMBER( hypotenuse(AREAL(1),AREAL(2)));
   }
   
   
   /* This is the initialization routine.
    * Its name is composed by prepending "init_" to the file name
    */
   void init_essai()
   {
     dx_define("hypotenuse",xhypotenuse);
   }

   /* These two (optional) definitions guarantee that
    * this module will only be loaded by compatible versions of LUSH. 
    */
   int majver_essai = LUSH_MAJOR;
   int minver_essai = LUSH_MINOR;


   /* ------ End of File "essai.c" ------ */
.PP 
Integrating this function into LUSH can be achieved in two ways: 
.IP
Copying this file in the <"src"> directory of SN, adding <"essai.o"> to
the list of objects in the <"Makefile">, calling <"init_essai()"> 
from file <"toplevel.c"> and recompiling everything.
This will build a new version of LUSH with the new function.
.IP
Compiling this file separately and loading the resulting object file into LUSH
at run-time.  This solution is named dynamic linking of an external module.
Modules are loaded with the function <mod-load>, and unloaded with the
function <mod-unload>. These functions allocate the necessary memory, relocate
the machine code, and resolve the external references.
.PP
The compilation is performed by the command:
.VP
  globina% gcc -c -I/home/leonb/lush/include essai.c
.PP
The resulting <"essai.o"> file can be loaded into LUSH 
with the following command.
.VP
  ? (mod-load "essai.o")
  = "/home/user/subdir/essai.o"
  ? (hypotenuse 3 4)
  hypot(3.000000,4.000000)=25.000000
  = 25
.PP

Modules can call any extern function or variable defined or used by LUSH as
well as extern functions and variable defined in other modules.  In
particuler, the C library functions are accessible.

A function defined in a module however is not always executable.
Indeed, its module might call an undefined function, or a function
defined by another non executable module.
In fact, four situations occur: 
.IP 
Initialized and executable modules are the only accessible modules.
All functions referenced by these modules have been found, and the
initialization routine (e.g.  <init_essai>) has been succesfully
executed, creating descriptors for the new lisp functions defined in
the modules.  At this point, all new lisp functions defined by such a
module are accessible and work as expected.

.IP
Uninitialized modules reference some undefined functions, or some
functions defined by a non executable module.  Therefore, the
initialization function has not been executed, and the descriptors for
the new lisp functions defined by such a module have not been created.

.IP
Modules may be initialized but non executable. Such a situation occurs
when a module has been initialized and executable, but is no longer
executable, because it uses some function or global variable which is
no longer defined, because its module has been unloaded.

.IP 
Finally, certain modules do not define an initialization function.
Such modules just define C functions used by other modules.
We say that such a module is in a unknown state.
.PP

#? (mod-list)
This function returns the list of the currently loaded modules.

Example:
.VP
   ? (mod-list)
   = ("/home/leonb/lush/src/lush" "/home/leonb/test/essai.o")
.PP

#? (mod-undefined)
This function returns a list with the names of all undefined C
functions and global variables in the current modules.

Example:
.VP
   ? (mod-undefined)
   = ("compute_squares" "numbers_of_squares")
.PP

#? (mod-status)
Displays a summary of all loaded modules.

#? (mod-inquire <filename>)
This function returns a list describing the status of a loaded module defined
by the object file <filename>. The first element of this list is a string
describing the states of a module.  When the initialization function has been
called, the names of the new lisp functions are provided in the remaining part
of this list.

#? (mod-load <filename>)
This function loads a piece of binary code into LUSH.
It can be used to load various kind of files containing object code:
.IP
Shared libraries (usually a file with extension <".so">)
containing a TL/Open extension to the Lisp interpreter.
.IP
Object files (usually a file with extension <".o">)
containing a SN3 style module.
.IP
Object files (usually a file with extension <".o">)
providing support functions for a SN3 style module.
.IP
Library archives (usually a file with extension <".a">) containing a
collection of object files providing support functions for a SN3 style module.
LUSH only loads the library components that provide definitions for currently
undefined symbols.  You may want to use functions <mod-create-reference> to
create fake undefined symbols and load certain parts of the library before
actually using them.
.IP
Shared libraries (usually a file with extension <".so">)
providing support functions for a SN3 style module.
.PP


#? (mod-create-reference <...strings...>)

Creates a fake undefined symbol that will be considered when loading libraries
(archive files like <"foo.a">). The loader indeed only loads the library
components which define symbols currently undefined. You may want to use
functions <mod-create-reference> to create fake undefined symbols and load
certain parts of the library before actually using them.

#? (mod-compatibility-flag <boolean>)

The old loaded was based on the DLD-3.2.3 library. This library had
significant bugs in the code checking the executability of a module. 
The new loader implements these checks properly. This righful code
may prevent you to load your old files. You can use function
<mod-compatibility-flag> with a non nil argument to loosen the checks
until the new system is almost as buggy as the old one.


#? (mod-unload <filename>)
This function removes a piece of binary code previously loaded with
<mod-load>.  Only object files (extension <".o">) and library archives
(extension <".a">) can be safely removed.  It is currently not possible to
unload a shared library module (usually a file with extension <".so">) because
these files are dealt with using operating system facilities that seldom
provide unloading support.

This operations has three steps:
.IP
Destroying all lisp functions previously defined by the module.
Calling such functions will cause an error in the future.
.IP
Relinquishing the memory utilized by the module.
.IP
Checking the executability of all loaded modules, and mark the lisp
functions defined by a module as partially linked, if this modules is
no longer executable.

#? (mod-dlopen <sofilename>) 
Obsolete function.
Use <mod-load> instead.


#? * Low level module functions.

Most of the above functions are in fact written in Lisp 
using a set of lower level functions.   LUSH modules
are represented by lisp object of class <|MODULE|>.
The following functions manipulate these objects.

#? (module-list)
Returns the list of all currently loaded modules.
Unlike <mod-list> this function returns the module objects
instead of the module filenames.

#? (module-filename <m>)
Returns the filename associated with module object <m>.

#? (module-executable-p <m>)
Test if the code for module <m> is executable.

#? (module-unloadable-p <m>)
Test if module <m> can be removed from memory.

#? (module-initname <m>)
Returns the name of the C initialization function for module <m>.

#? (module-depends <m>)
Returns the list of all the initialized modules that 
depends on module <m>.  This function is useful to evaluate
the consequences of a call to <module-unload>.

#? (module-defs <m>)
Returns an alist describing all the primitives defined by module <m>.
This alist is populated the first time the module becomes executable.
It is the user's responsibility to make this primitives available
for general use by defining conveniently named variables.

#? (module-load <filename> [<hookfunction>])
Loads the binary code file <filename> and returns a module object.

Function <hookfunction> is called with two arguments when the state of the
module changes.  The first argument is a selector symbol representing the
nature of the state change.  The second arguments is the module object itself.

The selector symbol can take the following values:
.IP <init>
The hook function is called with selector <init> 
just after calling the initialization function of the module.
Most useful hook functions will scan the list of definitions
returned by <module-defs> and define global symbols
to access the newly defined primitives.
.IP <exec>
The hook function is called with selector <exec>
whenever the executability of the module changes
because of loading/unloading another module.
.IP <unlink>
The hook function is called with selector <unlink>
just before unloading the module.  This is a good
time to revert the changes made during the module
initialization.
.PP

#? (module-unload <m>)
Unloads the binary module <m>.





#? * Debugging modules with gdb.

Although GDB is unaware of LUSH dynamic linking capabilities, it contains
decent support to debug code contained in shared libraries 
(i.e. files with extension <".so">).  The best way to debug modules
hence consists in building them as shared libraries.

Example:
.VP
globina% gcc -shared -o essai.so -I/home/leonb/lush/include  essai.c

globina% gdb lush
... GDB starts
(gdb) run
... LUSH starts
? (mod-load "essai.so")
= "/home/leonb/essai.so"
<CTRL-C>
(gdb) br xhypotenuse
Break in xhypotenuse
(gdb) cont
? (hypotenuse 3 4)
Breakpoint 1, 0x4001a8c1 in xhypotenuse () from /home/leonb/essai.so
(gdb) ....
.PP

There are two limitations:
.IP
Shared libraries must be completely linked.
They can only reference symbols contained in the main LUSH executable
and its libraries.
.IP
Shared libraries cannot be unloaded and replaced
by another version.



        


