
fileio.c
        Add support from file-to-string exchange.

function.c:
        Interface with module.c  (xxx_define)

oostruct.c:
        Interface with module.c  (class_define)
        Implement typed version of defclass.

unix.c:
        Lack of ALARM support
        Move DLOPEN support elsewhere

x11_driver.c:
        Lack of OPENGL support

idx-base.lsh:
        Add TL3 compat matrix functions.
        Check SN2/TL3 matrix emulation.

module.c:
        Test
        Document.
        module_serialize.

type.c:

dh.c:



----------------------------------------------
Documentation update
----------------------------------------------

TL3 * import_raw_matrix
TL3 * import_text_matrix
TL3 * export_raw_matrix
TL3 * export_text_matrix
TL3 * save_matrix
TL3 * save_ascii_matrix
TL3 * load_matrix
TL3 * map_matrix          
DELETED * save_flt_matrix
DELETED * save_packed_matrix
DELETED * map_pmatrix
SN3 * putmethod, defmethod, demethod, dfmethod, dmmethod
TL3 * mapfor mapwhile
TL3 * nfirst
LUSH * (makeclass <classname> <superclass> <slotnamelist> <slotdefaultlist>)
LUSH * (defclass <classname> <superclass> <...slots...> )    [DM]
SN3 * new_unode, unode_val, unode_uid, unode_eq, unode_unify
TL3 * alist_add, alist_get
LUSH * getp, putp
LUSH * defvar
LUSH * package private


----------------------------------------------
LUSH Specific doc
----------------------------------------------

#? (defvar name val)

Defines a new variable named <name> (a symbol) and initialized with value
<val>.  Traditionally function <setq> was used for that purpose in SN/TLisp.
There are cases however when <setq> refuses to create a new global variable.
Eventually we will completely disallow creating global variables with <setq>
and require the use of <defvar> for that purpose.

#? (private <..symbols..>

This function must be used inside a package definition.
It indicates that the symbols <..symbols..> must be considered
private to the package.
.SEE (package <name> <..expressions..>)

#? (package <name> <..expressions..>) 

This function provides a simple way to identify symbols that should remain
private to a group of functions.  Symbol <name> is used to identify the group
of functions.  Function <package> maintains a list of hidden symbols declared
with function <private>.  Each expression is first transformed to replace all
occurences of a hidden symbol by a new symbol whose name is composed by
prepending the package name <name>, then evaluated as usual.

Example:
.VP
   (package foobar
      (private foo)   
      (de foo(x) (print x)) 
      (de bar(x) (foo x)) )
.PP
defines a global symbol <bar>.
Symbol <foo> however was renamed as <foobar.foo> in all 
expressions occuring after <(private foo)>.  Hence the
actual definition of the two above functions read as:
.VP
(de bar (x)
  (toto.foo x) )
(de toto.foo (x)
  (print x) )


#? (makeclass <classname> <superclass> <slotnamelist> <slotdefaultlist>)

Creates and return a new class named <classname>.  The new class inherits
class <superclass>.  List <slotnamelist> contains the names of the additional
slots defined by the new class.  List <slotdefaultlist> contains the default
values for these slots.  Both lists are in reverse order (i.e. the first slot
in the list appears last when pretty-printing the class).  This function does
not set the value of symbol <classname>.  Use the macro function <defclass>
for that.


#? (putp <anything> <name> <value>)

Every Lush object (atoms, cons, etc.) may be enriched by defining properties
identified by a symbolic name.  Function <putp> is used to define such 
properties.  Its first argument is an arbitrary Lush object <anything>.
Function <putp> sets the property named by symbol <name> to value <value>.
Properties can be later retrieved using <getp>.

#? (getp <anything> <name>

Retrieves the property <name> for the Lush object <anything>.


----------------------------------------------
Not for lush-1.0
----------------------------------------------

- win32 port (cygwin)

        


