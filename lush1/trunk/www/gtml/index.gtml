
#define thebanner <img src="[[IMAGES]]/front-banner.png" height=78 width=500 border=2>

#include "[[HEADER_INC]]"

<div align=justify>
<img src="[[IMAGES]]/grenouille-400.jpg" align=right width=200 height=132 border=2>
Lush is an <b>object-oriented programming language</b> with features designed
to please researchers, experimenters, and engineers interested in
<b>large-scale numerical and graphic applications</b>.  Lush is designed to
be used in situations where one would want to combine the flexibility
of a high-level, loosely-typed interpreted language, with the
efficiency of a strongly-typed, natively-compiled language, and with
the easy integration of code written in C, C++, or other languages.
<p>
Lush can be used advantageously for projects where one would otherwise
use a combination of an interpreted language like Matlab, Python, Perl, 
S+, or even (gasp!) BASIC, and a compiled language like C.  Lush
brings the best of both worlds by wrapping three languages into one:
(1) a loosely-typed, garbage-collected, dynamically scoped,
interpreted language with a simple Lisp-like syntax, (2) a
strongly-typed, lexically-scoped compiled language that uses the same
Lisp-like syntax, and (3) the C language, which can be freely mixed
with Lush code within a single program, even within a single function.
It sounds complicated, but it is not. In fact, Lush is designed to
be very simple to learn and easy to use.
<p>
<b>If you do resarch and development in signal processing, image
processing, machine learning, computer vision, bio-informatics, data
mining, statistics, or artificial intelligence, and feel limited by
Matlab and other existing tools, Lush is for you. If you want a simple
environment to experiment with graphics, video, and sounds, Lush is
for you.</b>
<p>
Lush's main features includes:
<ul>
 <li> A very clean, simple, and easy to learn Lisp-like syntax.
 <li> A compiler that produces very efficient C code and relies
      on the C compiler to produce efficient native code  
      (no inefficient bytecode or virtual machine).
 <li> An <b>easy way to interface C functions and libraries</b>,
       and a powerful dynamic linker/loader for object files or libraries
       (.o, .a and .so files) written in other compiled languages.
 <li> The ability to <b>freely mix Lisp and C in a single function</b>.
 <li> A powerful set of vector/matrix/tensor operations.
 <li> A huge library of numerical routines, including
       full interfaces to GSL, LAPACK, and BLAS.
 <li> A library of image and signal processing routines.
 <li> An extensive set of graphic routines, including
       an object-oriented GUI toolkit, an interface to 
       OpenGL/GLU/GLUT, and an interface to the OpenRM scene
       rendering engine.
 <li> An interface to the Simple Directmedia Layer (SDL)
      multimedia library, including a sprite class with
      pixel-accurate collision detection.
 <li> Sound and video grabbing (using ALSA and Video4Linux).
 <li> Several libraries for machine learning, neural net,
      statistical estimation, Hidden Markov Models
      (gblearning, Torch, HTK).
 <li> libraries for computer vision (Intel Vision Library),
      and 3D scene rendering (OpenRM). 
 <li> bindings to the JavaVM API and to the Python C API.
</ul>
This combination of flexibility, efficiency, and extensive libraries
makes Lush an ideal platform for research and development in signal
processing, image processing, machine learning, computer vision,
bio-informatics, data mining, statistics, and artificial
intelligence. Its speed and extensive libraries allow such things as
real-time sound, image, and video processing.  Most users use Lush as
a research tool, but many use it as a general purpose script
language, or as a general language for application development. Some
have been known to use Lush to develop 2D and 3D games. A few have
even used Lush to develop commercial software for embedded processors.
<p> </div>

[[sectionbanner(dwnld,Download the Latest Version)]]
<p>
<div>
<table border="1" cellspacing="0" cellpadding="2">
<tr><td>
<center><b>Latest Release:</b></center>
<ul>
<li>version <b>[[LATEST_VERSION]]</b>
<li>released [[LATEST_DATE]].
for installation instructions
<li>Check out the full <a href="[[RELEASED]]">download page</a> for previous versions.
</ul>
</td>
<td>
<table border="1" cellspacing="0" cellpadding="2">
<tr><th colspan=2>Binaries</th></tr>
<tr><th colspan=2>Source Packages</th></tr>
<tr><td>Source TAR.GZ</td><td>[[latest-download(".tar.gz")]]</td></tr>
</table>
</td></tr></table>
<br>
<p>

[[sectionbanner(wid,What is Lush?)]]

<table border=0 cellpadding=4>
<tr><td>
<div align=justify>
Many software projects, particularly research projects, require two languages:
an efficient compiled language such as C or C++ for implementing the low-level
or computationally expensive function, and a flexible, possibly interpreted
language for high-level control, scripting, experimentation, and tinkering.  
Popular research-oriented interpreters such as Matlab are somewhat 
inefficient, lack support for complex data structures, lack the 
power of a full-fledged object-oriented programming language, and lack
simple interfacing to C and other compiled languages.
<p>
Lush uses a very simple Lisp syntax. If the word "Lisp" sends shivers
down your spine, be advised that the dialect of Lisp that Lush
implements is extremely simple to learn, with possibly one the
simplest syntax around.  Most scientists, engineers, and
software developers who have learned Lush have become proficient at it
in a few days, even if they had no prior exposure to Lisp. It's very
simple. Really. In fact, Lush has been used to teach programming to kids.
<p>
The Lush compiler has several interesting properties, and a few limitations.  
Its main advantage is that it generate very efficient C code which is then
compiled with the best available C compiler for the machine considered and
loaded dynamically. The C code produced does not simulate a virtual machine,
it is real, low-level, bang-the-metal, no-runtime-check,
don't-break-for-animals, C code, just like what you would write by hand.
Its main disadvantage is that, although it compiles a Lisp-like language,
it does no more for you than what a C compiler would (no automagic
memory management, no garbage collection, no functional programming).
</div>
</td>
<td>
<a href="screenshot.html#edges">
<img src="[[IMAGES]]/screendumps/edges.png" align=right width=240 height=180 border=1>
</a>
<br>
<a href="screenshot.html#teapot">
<img src="[[IMAGES]]/screendumps/teapot.png" align=right width=204 height=214 border=1></a>
</td></tr></table>

<p>

[[sectionbanner(features,A tour of the features)]]

<div align=justify>
The Lush interpreter is written in C and features all the usual
functionalities and constructs found in every decent object-oriented
programming language such as conditional statements, loops, local
variables, functions, macros, objects, classes, methods, and
inheritance, but it also provides a large number of functions for
manipulating lists, strings, vectors, matrices, and tensors. String
functions include such things as regular expression matching and
substitutions.
<p>
<a href="screenshot.html#lander04">
<img src="[[IMAGES]]/screendumps/lander04.png" align=right width=240 height=180 border=1>
</a>
The Lush interpreter is quite similar to some lisps of the mid 80's
like "Le_Lisp" and "UCI-Lisp". It is significantly simpler than
"Common Lisp" and quite different from Scheme.
<p>
An unusual feature of Lush is its compiler to C, its dynamic linker/loader,
and the ease with which one can interface existing C functions and
libraries. En even more unusual feature is the ability to intermix
Lisp and C source code within a single function. 
<p>
The vector and matrix manipulation engine is quite powerful and efficient,
making Lush ideal for heavy numerical applications and applications such as
signal and image processing. It includes functions to create, resize, and
convert vectors, matrices, and tensors with up to eight dimensions.  It also
includes basic matrix operations such as scalar operations on all elements of
a matrix, dot products, outer products, transposition, highly optimized 1D and
2D convolutions. A set of vector/matrix iterators is also provided.
<p>
Lush is an object-oriented language. Classes with slots and methods 
can be defined and compiled. Derived classes inherit the slots and 
methods of their parent class (similar to the C++ semantics).
<p>
Lush includes all the functions familiar to Lisp aficionados, such as list
functions, list iterators, physical list manipulation, macros, splicing
macros, symbol manipulation, etc, but most casual users will probably
prefer to stay away from those.
<p>
Lush provides a set of simple-to-use low-level graphic functions to draw 
lines, polygons, rectangles, pictures, and text in color, with automatic 
refresh and double-buffering capability (for simple animations). Graphics 
can be drawn in an X-windows window (on Unix), or sent to a PostScript file.
<p>
Lush also contains a very compact and easy-to-use object-oriented 
graphical user interface generator called ``Ogre''. Ogre is entirely 
written in Lisp on top of the low-level graphic functions mentioned
above. It contains predefined classes for buttons, sliders, radio buttons,
menus, string editors, etc... Ogre includes an automatic mechanism for placing
objects in the window, thereby greatly simplifying the design and
implementation of GUIs. Simple GUIs can be written in extremely short 
times and are very compact.
<p>
Lush provides two models for Input/Output. One is a set of ``Lispy'' I/O
functions that allow easy input and output of ASCII data, lisp expressions,
lisp objects, and matrices. It includes such goodies as pipes and
sockets. The other model essentially provides access to the standard C I/O
library, including fopen, popen, fprintf, fscanf, fgetc, fputc fgets, and
various functions for reading and writing matrices.
Large matrices can be mapped in the virtual addressing space, instead of
explicitely loaded in memory. This allows to access very large datasets
efficiently. 
<p>
<a href="[[IMAGES]]/screendumps/helptool01.png">
<img src="[[IMAGES]]/screendumps/helptool02.png" width=600 height=239 border=1>
</a>
</div>
<p>

[[sectionbanner(inside,A tour of the Lush Libraries)]]

<div align=justify>
Lush has a huge collection of libraries and utilities available to the
user.  Some are written in Lisp, some are written in C and interfaced
to Lush, others are pre-existing libraries that have been interfaced to
Lush.
<p>
For our numerically enclined friends, Lush has a full interface to the
GNU Scientific Library (GSL, 3500 function), and to the LAPACK and
BLAS Linear Algebra libraries. This gives access to an extensive set
of numerical and statistical functions (several thousand in fact).
<p>
Lush includes a full interface to the industry-standard OpenGL library that
allows the creation of 3D graphics and animations. This interface
include an interface to GLUT, OpenGLU, and OpenRM (scene graph
rendering engine). This makes Lush an excellent platform to write
interactive VR applications and computer games.
<p>
Another popular library interfaced to Lush is the multimedia
and game API Simple Directmedia Layer (SDL). It is enhanced by a high-level
library that allows the easy manipulation of sprites and movable
screen objects with pixel-accurate collision detection. This library,
combined with Lush's simple syntax, makes it ideal for developing 
simple video games and for teaching programming to children.
<p>
Lush contains a library of image processing functions to load, save,
resize and resample, warp, filter, and analyze images. Mathematical 
morphology operations such as connected component analysis, distance 
transform, erosion, and dilation, are also available for bitonal images.
It also includes classes and functions for easily grabbing video using 
the Video4Linux API. It also includes an interface to the Intel
Computer Vision library (OpenCV).
<p>
Lush includes a graph library that allows grammar and finite state machine 
construction, graph transduction and composition, and viterbi search
algorithm.
<p>
Lush offers an extensive library for gradient-based machine
learning. The list includes: neural networks (including convolutional 
neural networks), radial basis functions, support vector machines, and many
others. This library is based on an innovative object-oriented design
that allows to build large learning machines out of multiple learning
modules and to train them cooperatively. Commercially used optical
recognition systems have been built with this library. Lush also 
provides an interface to the popular 
<a href="http://www.torch.ch">Torch</a> package which includes 
even more machine learning paradigms.
<p>
In addition, Lush provides various interfaces to multimedia libraries,
including Video4Linux (video grabbing) and ALSA (audio recording/playing).
</div>

[[sectionbanner(inside,Frequently Asked Questions)]]

<div align=justify>
<img src="[[IMAGES]]/grenouille-400.jpg" align=right width=400 height=265 border=1>

<h2>What's with all the frogs?</h2>

Well, [[YANN]] and [[LEON]] are both French, and many of the past 
contributors have been French or French-speaking (Patrice Simard, 
Yoshua Bengio, Patrick Haffner, Pascal Vincent).
<p>
Years of extensive focus groups studies and consultation with top market 
analysts showed that using escargots would send the wrong message for 
an allegedly fast language. 
<p>
Cute penguins and gnus were already taken, as well as the
numerous species found on the covers of O'Reilly books.
<p>
We like frogs. Really. Some of our best friends are frogs.
Particularly those accompanied by garlic and butter.

<h2>This site looks like a rip-off of the <a href="http://djvu.sourceforge.net">DjVuLibre</a> site</h2>

Lush and <a href="http://djvu.sourceforge.net">DjVu</a> were produced by 
the same people (in fact Lush was used to prototype the first version
of DjVu). So, no rip-off, just laziness.
</div>

#include "[[FOOTER_INC]]"
