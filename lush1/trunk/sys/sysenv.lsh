;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; LUSH Lisp Universal Shell
;;;   Copyright (C) 2002 Leon Bottou, Yann Le Cun, AT&T Corp, NECI.
;;; Includes parts of TL3:
;;;   Copyright (C) 1987-1999 Leon Bottou and Neuristique.
;;; Includes selected parts of SN3.2:
;;;   Copyright (C) 1991-2001 AT&T Corp.
;;;
;;; This program is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 2 of the License, or
;;; (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program; if not, write to the Free Software
;;; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;  $Id: sysenv.lsh,v 1.10 2002-05-02 21:19:19 leonb Exp $
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;; --------- Miscellaneous macro-chars ---------

(dmc |'|                                   ;; the QUOTE macro
     (list (quote quote) (read)))

(dmc |~|                                   ;; the NULL macro
     (list 'null (read)))

(dmc |!|                                   ;; the SYS macro
     (list 'sys (read_string)))

(dmc |:|                                   ;; the SCOPE macro
     (when (= (skip-char) ":")
           (error 'load "Names beginning by :: are reserved" ()) )
     (let ((ans (list 'scope (read))))
       (while (= (skip-char "") ":")
	 (read-string 1)
	 (setq ans (nconc1 ans (read))) )
       ans ) )

(dmc |#!|                                  ;; the SCRIPT macro
     (read-string)
     () )

(lock_symbol |'| |~| |!| |:| |#!|)




;;; --------- Historical spelling mistakes  ---------

(setq not null)
(setq nil ())
(lock_symbol not nil)

;;; --------- toplevel, break, and debug  ---------

(de startup argv
    ;; no command line argument: set default library to lushenv-path
    (when (not argv) (when lushenv-path (setq argv (list lushenv-path))))
    (if (= (car argv) "@@")
        ;; script mode
        (progn
          (setq startup ())
          (setq argv (cdr argv))
          (when argv (load (car argv))) )
      ;; interactive mode
      (each ((file argv))
        (if (and mod-load (= (left file 1) "+"))
            (progn
              (printf "... loading extension file \"%s\"\n" file)
              (mod-load (mid file 2)) )
          (setq file (or (filepath file) file))
          (printf "... loading library file \"%s\"\n" file)
          (load file) ) ) )
    (de startup argv
        (when argv
          (printf "... command line arguments: ")
          (print argv) ) ) )

(de toplevel()
    (let ((break-hook :nice-break-hook)
	  (debug-hook :nice-debug-hook) )
      (if (isatty "$stdin")
	  (load "$stdin" "$stdout" "? ")
	(load "$stdin") ) ) )

(setq debug-action ())
(setq break-action ())

(dm on-error (f p . l)
  (cons 'let
	(cons
	  (list (list 'debug-action
		      (list 'cons (list 'quote p) 'debug-action) ))
	  l )) )

(dm on-error-macro (n onem . r)
    `(eval (cons 'on-error (cons ,onem (quote ,r))))
    )

(dm on-break(f p . l)
  (cons 'let
	(cons
	  (list (list 'break-action
		      (list 'cons (list 'quote p) 'break-action) ))
	  l )) )

(dm on-break-macro (n onbm . r)
    `(eval (cons 'on-break (cons ,onem (quote ,r))))
    )

(de simple-break-hook()
    (each ((action break-action)) (eval action))
    (writing "$stderr" (printf "\n\x07*** %s\n" (errname))) 
    t )

(de simple-debug-hook()
    (each ((action debug-action)) (eval action))
    (writing "$stderr" (printf "\n\x07*** %s\n" (errname)))
    t )

(de nice-break-hook()
    (each ((action break-action)) (eval action))
    (writing "$stderr" (printf "\n\x07*** %s" (errname)))
    (if (and (isatty "$stdin") (ask "Break toplevel"))
	(progn
	  (writing "$stderr" (where 7))
	  (load "$stdin" "$stdout" "[Break] ? ")
	  (not (ask "Resume execution")) )
      t ) )

(de nice-debug-hook()
    (each ((action debug-action)) (eval action))
    (writing "$stderr" (printf "\n\x07*** %s" (errname)))
    (if (and (isatty "$stdin") (ask "Debug toplevel"))
	(progn
	  (writing "$stderr" (where 7))
	  (load "$stdin" "$stdout" "[Debug] ? ") )
      t ) )

(setq break-hook simple-break-hook)
(setq debug-hook simple-debug-hook)


(lock-symbol toplevel 
	     break-hook debug-hook
	     nice-break-hook nice-debug-hook 
	     break-action debug-action
	     on-error on-break
	     on-error-macro on-break-macro
	     )






;;; --------- Trace-Hook  ---------

(de trace-hook(level line expr info)
    (writing "$stderr"
      (for (i 1 (abs level)) (printf "-"))
      (printf "%s %s\n" (if (>= level 0) ">" "<") line)
      t ) ) 

(lock-symbol trace-hook)






;;; --------- Tokenise  ---------

(de tokenize(fin &optional fout)
    (when (not fout)
      (setq fout (filepath fin ".lsh|.tl|"))
      (when (or (not fout) (not (regex-match ".*\\.(sn|tl)" fout)))
	(error 'tokenize "Cannot find library file named" fin) )
      (setq fin fout)
      (setq fout (concat fout "c")) )
    (let ((tokens (list 'progn)))
      (reading (open-read fin ".lsh|.tl|")
	       (while (<> (skip-char) "\e")
		 (if (= (skip-char) ";")
		     (read-string)
		   (nconc1 tokens (read)) ) ) )
      (writing (open-write fout)
	       (bwrite tokens) ) )  
    fout)




;;; --------- Backquote macro ---------

(de backquote-macro()
    (let ((|,| (lambda() 
		 (error "Nested comma in a backquoted expression"))))
      (if (<> (skip-char) "@")
	  (cons '|,| (read))
	(read-string 1)
	(cons '|,@| (read)) ) ) )

(de backquote-subst(l) 
    (let ((na ())
	  (nl ())
	  (nq ()) )
      
      (while l
	(when (consp l)
	      (when (= (car l) '|,@|)
		    (error 'read "Misplaced ,@ inside a backquote") )
	      (when (= (car l) '|,|)
		    (setq l (list (cons '|,@| (cdr l)))) ) )
	(cond
	 ((atomp l)
	  (setq nq (nconc nq l)) 
	  (setq l ()) )
	 ((null (consp (car l)))
	   (setq nq (nconc1 nq (car l))))
	 ((= (caar l) '|,|)
	  (setq nl (append nl 
			   (all ((i nq)) 
				(list 'quote i))
			   (list (cdar l)) ))
	  (setq nq ()) )
	 ((= (caar l) '|,@|)
	  (setq na (append na
			   (when nl (list (cons 'list nl)))
			   (when nq (list (list 'quote nq)))
			   (list (cdar l)) ))
	  (setq nl ())
	  (setq nq ()) )
	 (t
	  (let ((m (backquote-subst (car l))))
	    (if (and (consp m) (= (car m) 'quote))
		(setq nq (nconc1 nq (cadr m)))
	      (setq nl (nconc nl 
			      (all ((i nq)) 
				   (list 'quote i))
			      (list m) ))
	      (setq nq ()) ) ) ) )
	
	(setq l (cdr l)) )

      (if (null na)
	  (backquote-list nl nq)
	(append 
	 (list 'append)
	 na
	 (let ((m (backquote-list nl nq)))
	   (when m (list m)) ) ) ) ) )

(de backquote-list(nl nq)
    (cond
     ((null (or nl nq) )
      ())
     ((null nl)
      (list 'quote nq))
     ((null nq)
      (cons 'list nl))
     ((= (length nl) 1)
      (list 'cons (car nl) (list 'quote nq)) )
     ((= (length nl) 2)
      (list 'cons (car nl) (list 'cons (cadr nl) (list 'quote nq))) )
     (t
      (list 'nconc (cons 'list nl) (list 'quote nq)) ) ) )
     

(dmc |,| 
     (error 'read "Comma outside backquote") )

(dmc |`|
     (backquote-subst
      (let* ((|,| backquote-macro))
	(read) ) ) )

(lock-symbol |`| |,| backquote-subst backquote-list backquote-macro)



;;; --------- Usual functions ---------

(de caddr(l) (car (cddr l)))
(de cdddr(l) (cdr (cddr l)))
(de cdadr(l) (cdr (cadr l)))
(de caadr(l) (car (cadr l)))
(de cadar(l) (car (cdar l)))
(de cddar(l) (cdr (cdar l)))
(de cdaar(l) (cdr (caar l)))
(de caaar(l) (car (caar l)))

(de nconc (f . l)
  (cond
    (f
       (prog1 f
	 (each ((i l))
	       (setq f (lastcdr f))
	       (rplacd f i) ) ) )
    (l
       (nconc . l) ) ) )

(de nconc1(l s)
  (if l
      (rplacd (lastcdr l) (list s))
    (setq l (list s)) )
  l )

(de alist-add (key value alist)
  (let ((pair (assoc key alist)))
    (if pair
        (rplacd pair value)
      (setq alist (cons (cons key value) alist)) )
    alist ) )

(de alist-get(key alist)
  (let ((pair (assoc key alist)))
    (when pair
      (cdr pair) ) ) )

(de classp(q)
  (= (classof q) class) )

(dm dmd(f n a . p)
    `(dm ,n |DMD| (displace |DMD| (let ((,a (cdr |DMD|))) ,@p))) )

(setq |*PROPERTIES| (htable))

(de getp(obj key)
  (let ((data (|*PROPERTIES| key)))
    (when data (data obj)) ) )

(de putp(obj key val)
  (let ((data (|*PROPERTIES| key)))
    (when (not data)
      (when (symbolp key)
        (|*PROPERTIES| key (setq data (htable 17 t))) )
      (when (not data)
        (error 'putp "not a symbol" key) ) )
    (data obj val)
    key ) )

(dm defclass(f name super . body)
    (let ((k ())
          (d ()) )
      (each ((slot body))
        (cond
         ((symbolp slot)  
          (setq k (cons slot k))
          (setq d (cons () d)) )
         ((and (consp slot) (symbolp (car slot)) (null (cddr slot)))
          (setq k (cons (car slot) k))
          (setq d (cons (cadr slot) d)) )
         (t
          (error 'defclass "Illegal slot specification" slot) ) ) )
      `(progn (setq ,name (makeclass ',name ,super ',k (list ,@d))) 
              ',name) ) )

(dm defmethod(f class name . body)
    `(putmethod ,class ',name (lambda ,@body)) )

(dm demethod(f class name . body)
    `(putmethod ,class ',name (lambda ,@body)) )

(dm dfmethod(f class name . body)
    `(putmethod ,class ',name (flambda ,@body)) )

(dm dmmethod(f class name . body)
    `(putmethod ,class ',name (mlambda ,@body)) )

(dmd mapfor ((var lo hi . step) . body)
     `(let ((|MAP| ()))
        (for (,var ,lo ,hi ,@step) (setq |MAP| (cons (progn ,@body) |MAP|)))
        (reverse |MAP|) ) )

(dmd mapwhile (expr . body)
     `(let ((|MAP| ()))
        (while ,expr (setq |MAP| (cons (progn ,@body) |MAP|)))
        (reverse |MAP|) ) )

(de sort-list (l comp)
    (if (cdr l)
	(let* ((piv ())
	       (pl ())
	       (ll ())
	       (rl ()) )
	  ;; Choose pivot
	  (let* ((n (length l))
		 (p1 (car l))
		 (lc (nthcdr (div n 2) l))
		 (p3 (last lc)) )
	    (setq piv (car lc))
	    (if (comp p1 piv)
		(setq piv p1 p1 piv) )
	    (if (comp piv p3)
		(setq piv p3 p3 piv) )
	    (if (comp p1 piv)
		(setq piv p1 p1 piv) ) )
	  ;; Go pivoting for quicksort
	  (each ((i l))
		(cond 
		 ((= i piv)
		  (setq pl (cons i pl)) )
		 ((comp i piv)
		  (setq rl (cons i rl)) )
		 (t 
		  (setq ll (cons i ll)) ) ) )
	  (nconc (sort-list ll comp) (nconc pl (sort-list rl comp))) )
      l ) )

(de hset(l)
  (let ((r (htable)))
    (each ((x l))
      (r x t) )
    r ) )

(de hset-and(ht1 ht2)
  (let ((r (htable)))
    (when (< (htable-size ht2) (htable-size ht1))
      (setq ht1 ht2 ht2 ht1) )
    (each ((key (htable-keys ht1)))
      (when (ht2 key)
	(r key t) ) )
    r ) )

(de hset-or(ht1 ht2)
  (let ((r (htable)))
    (each ((key (htable-keys ht1)))
      (r key t) )
    (each ((key (htable-keys ht2)))
      (r key t) ) 
    r ) )

(lock_symbol caddr cdddr cdadr caadr cadar cddar cdaar caaar
             nconc nconc1 classp dmd alist-get alist-add
             |*PROPERTIES| putp getp 
             defclass defmethod demethod dfmethod dmmethod
             mapfor mapwhile sort-list 
             hset hset-and hset-or)



;;; -------- Statistics on lists of numbers ---------

(de y_estimate((a b r) x)
    (+ (* x a) b) )

(de x_estimate((a b r) y)
    (/ (- y b) a) )

(dm mean_sup_dist (f r1 . r2)
    `(let ((r ,r1)) (/ (sup_dist r ,@r2) (length r))) )

(dm mean_abs_dist (f r1 . r2)
    `(let ((r ,r1)) (/ (abs_dist r ,@r2) (length r))) )

(dm mean_sqr_dist (f r1 . r2)
    `(let ((r ,r1)) (/ (sqr_dist r ,@r2) (length r))) )

(dm mean_hamming_dist (f r1 . r2)
    `(let ((r ,r1)) (/ (hamming_dist r ,@r2) (length r))) )

(dm mean_quadrant_dist (f r1 . r2)
    `(let ((r ,r1)) (/ (quadrant_dist r ,@r2) (length r))) )

(lock_symbol x_estimate y_estimate
             mean_sup_dist mean_abs_dist mean_sqr_dist 
             mean_hamming_dist  mean_quadrant_dist )

(setq diff-lists diff-listes)
(setq add-lists add-listes)
(lock-symbol diff-lists add-lists)





;;;; --------- Arrays & Matrix utilities ---------

(de index-print(this)
    (let ((begin "[")
	  (end "]"))
      (when (arrayp this)
	    (setq begin "{")
	    (setq end "}"))
      
      (if (or (not (idx-ndim this)) (0= (idx-ndim this)))
	  (printf "%s" (pname this))
	
	(printf begin)
	(let ((tabnow (tab))
	      (len (idx-bound this 0)) )
	  (if (= 1 (idx-ndim this))
	      (if (not (member (classof (idx-storage this))
			       (list |ATSTORAGE| |GPTRSTORAGE|) ) )
                  (for (i 0 len)
                       (printf "%5.2f " (this i))) 
		(printf " ")
		(for (i 0 len)
		     (prin (this i))
		     (printf " ")) )
	    (for (i 0 len)
		 (index-print (new-index this 
					 (cons 0 (cdr (idx-dim this)))
					 (list i) ))
		 (when (< i len)
		       (print)
		       (tab tabnow) ) ) ) )
	(printf end) ) ) )

(demethod |INDEX| print()
  (if (and (matrixp this)
	   (< (apply * (idx-dim this)) 100))
      (index-print this)
    (printf "%s" (pname this)) ) )

(de list-to-index(l matrix)
    (if (= (car l) 'quote)
	;; this is a list of literal
	(let ((m (matrix (1- (length l)))))
	  (m () (cdr l)) )
      ;; this is a list of matrices
      (let ((m (apply matrix (cons (length l) (idx-dim (car l))))))
	(for (i 0 (idx-bound m 0))
	     (copy-matrix (car l)
			  (new-index m
				     (cons 0 (cdr (idx-dim m)))
				     (list i) ) ) 
	     (setq l (cdr l)) )
	m ) ) )

(dmc |]| (error 'read "extra ']' found"))

(dmc |}| (error 'read "extra '}' found"))

(dmc |[| 
     (on-error (error 'list-to-index "Illegal matrix syntax")
       (let ((l (when (<> (skip-char) "[") (list 'quote)))
             (|]| (lambda() (setq m (list-to-index l f-matrix))))
             (m ()) )
         (while ~m
           (setq l (nconc1 l (read))) )
         m ) ) )

(dmc |{| 
     (on-error (error 'list-to-index "Illegal matrix syntax")
       (let ((l (when (<> (skip-char) "{") (list 'quote)))
             (|}| (lambda() (setq m (list-to-index l at-matrix))))
             (m ()) )
         (while ~m
           (setq l (nconc1 l (read))) )
         m ) ) )

(lock_symbol index-print list-to-matrix |[| |]| |{| |}|)

;; Compat

(setq map-pmatrix map-matrix)
(setq save-flt-matrix save-matrix)
(setq save-packed-matrix save-matrix)
(lock-symbol map-pmatrix save-flt-matrix save-packed-matrix)




	     
;;; --------- Path functions ---------

(de addpath(dir)
    (setq dir (concat-fname dir))
    (let ((oldpath (path))
	  (newpath (list dir)) )
      (while oldpath
	(when (<> dir (car oldpath))
	      (setq newpath (nconc1 newpath (car oldpath))) )
	(setq oldpath (cdr oldpath)) )
      (apply path newpath) ) )

(dmc |^L| (let ((_f_ (read_string)))
	    (if (= _f_ "")
		(setq _f_ (or last-loaded-file edit-buffer))
	      (setq last-loaded-file _f_) )
	    `(load ,_f_) ))

(de libload(s &optional (c ""))
  (when (not (setq s (filepath s)))
    (error 'libload "File not found" ()) )
  (let ((loaded '(())))  ;; self modifying code
    (when (not (member (basename s) loaded))
      (when startup (printf " [%s]%s\n" (basename s) c))
      (nconc1 loaded (basename s))
      (load s) ) ) )

(dm autoload(autoload l . s)
  (let  ((f  (eval `(mlambda f
		      (set (car f) ())
		      (libload ,l " (autoload)")
		      f) )))
    `(progn ,@(all ((i s)) `(setq ,i ,f))) ) )

(lock-symbol addpath |^L| libload autoload)






;;; --------- pprin, pprint ----------

(each ((sym '( progn graphics-batch debug nodebug )))
  (putp sym 'pprint-type 0) )
(each ((sym '( when while do-while for mapfor mapwhile repeat )))
  (putp sym 'pprint-type 1) )
(each ((sym '( lambda flambda mlambda zlambda writing reading )))
  (putp sym 'pprint-type 1) )  
(each ((sym '( de df dm dz dmd defclass dhm-t dhm-c )))
  (putp sym 'pprint-type 2) )
(each ((sym '( defmethod demethod dfmethod dmmethod )))
  (putp sym 'pprint-type 3) )

(putp 'if        'pprint-type '(1 indent))
(putp 'prog1     'pprint-type '(0 indent))
(putp 'cond      'pprint-type '(0 cond))
(putp 'selectq   'pprint-type '(1 cond))
(putp 'let       'pprint-type '(0 let))
(putp 'let*      'pprint-type '(0 let))
(putp 'all       'pprint-type '(0 let))
(putp 'each      'pprint-type '(0 let))
(putp 'idx-bloop 'pprint-type '(0 let))
(putp 'idx-eloop 'pprint-type '(0 let))


(de pprin--v(l tb)
    (let ((nl ()))
      (while (consp l)
	(setq nl t)
	(print)
	(tab tb)
	(pprin (car l))
	(setq l (cdr l)) )
      (when l
	    (print)
	    (setq nl t)
	    (tab (+ tb 2))
	    (printf ". ")
	    (pprin l) )
      (if nl
	  (printf " )")
	(printf ")") )
      nl ) )
    
(de pprin--h(l tb)
    (let ((ok t)
	  (nl ()) )
      (while (and ok (consp l))
	(if (or (<= (tab) tb)
		(< (+ (tab) (len (pname (car l)))) 78) )
	    (printf " ")
	  (print)
	  (tab tb)
	  (setq nl t) )
	(if (not (pprin (car l)))
	    (setq l (cdr l))
	  (setq ok ())
	  (setq nl t)
	  (pprin--v (cdr l) tb) ) )
      (when ok
	    (when l
		  (if (< (+ (tab) (len (pname l))) 76)
		      (printf " . ")
		    (print)
		    (tab tb)
		    (setq nl t)
		    (printf ". ") )
		  (pprin l) )
	    (if nl
		(printf " )")
	      (printf ")") ) )
      nl ) )

(de pprin--n(l n)
  (let ((c ""))
    (while (and (consp l) (>= n 0))
      (printf "%s" c)
      (setq c " ")
      (pprin (car l))
      (setq l (cdr l))
      (setq n (1- n)) )
    l ) )

(de pprin(l)
  (let ((tb (tab))
        (type (and (consp l) (getp (car l) 'pprint-type))) )
    (when (numberp type)
      (setq type (cons type ())) )
    (cond
     ;; nil
     ((not l) (prin l) ())
     ;; method 'pprint' is defined
     ((and (classof l) (check==> (classof l) 'pprint))
      (==> l pprint) )
     ;; not a list
     ((not (consp l)) (prin l) ())
     ;; type is a pair
     ((consp type)
      (printf "(")
      (setq l (pprin--n l (car type)))  ; first arguments in line
      (when (consp l)
        (cond                          ; next argument special
         ((= (cadr type) 'indent)
            (print)
            (tab (+ tb 4))
            (pprin (car l)) 
            (setq l (cdr l)) )
         ((= (cadr type) 'cond)
           (while (consp l)
             (print)
             (tab (+ tb 2))
             (if (not (consp (car l)))
                 (pprin l)
               (printf "(")
               (pprin (caar l))
               (pprin--v (cdar l) (+ tb 4)) )
             (setq l (cdr l)) ) )
         ((= (cadr type) 'let)
           (printf " ");
           (if (not (consp (car l)))
               (pprin (car l))
             (printf "(")
             (let ((tb (tab)))
               (pprin (caar l))
               (pprin--v (cdar l) tb) ) )
           (setq l (cdr l)) ) ) )
      (pprin--v l (+ tb 2)) )
     ;; macro quote
     ((and (= (car l) 'quote) ~(cddr l))
      (printf "'")
      (pprin (cadr l)) )
     ;; macro scope
     ((and (= (car l) 'scope) (consp (cdr l)) ~(cdr (lastcdr l)))
      (while (setq l (cdr l))
        (printf ":")
        (pprin (car l)) ) )
     ;; start with symbol
     ((symbolp (car l))
      (printf "(")
      (setq l (pprin--n l 0))
      (pprin--h l (+ tb 2)) )
     ;; default
     (t
      (printf "(")
      (setq l (pprin--n l 0))
      (pprin--h l (+ tb 2)) ) ) ) )

(de pprint(l)
    (pprin l)
    (print)
    t )

(lock-symbol pprin--h pprin--v pprin--n pprin pprint)





;;; --------- Pretty printer ---------

(de prettyflags(l n) l) ;; compatibility only

(de pretty-print(f &optional name)
  (when (and (consp f) (consp (cdr f)) (consp (cddr f)))
    (when (and name (= (car f) 'lambda))
      (setq f `(de ,name ,@(cdr f))) )
    (when (and name (= (car f) 'flambda))
      (setq f `(df ,name ,@(cdr f))) )
    (when (and name (= (car f) 'mlambda))
      (setq f `(dm ,name ,@(cdr f))) )
    (when (and name (= (car f) 'zlambda))
      (setq f `(dz ,name ,@(cdr f))) )
    (when (and (= (car f) 'dm) (= (caddr f) '|DMD|))
      (let ((body (cdr (cdar (cddr (cadr (cddr f))))))
            (args (caaar (cdadr (cdadr (cddr f))))) )
        (setq f `(dmd ,(cadr f) ,args ,@body)) ) )
    (when (and (= (car f) 'de) (macrochp (cadr f)) (null (caddr f)))
      (let ((body (cdddr f)))
        (setq f `(dmc ,(cadr f) ,@body)) ) ) )
  (pprint f) )

(de pretty-slots(this)
    (let ((cl (classof this)))
      (while cl
	(printf ";; from class %l:\n" (classname cl))
	(each ((i (slots cl)))
	      (if (consp i)
		  (setq i (car i)))
	      (printf ";;\t%l=%l\n" i (apply letslot (list this i))) )
	(setq cl (super cl)) ) ) )

(de pretty-method(class method)
  (let* ((j (check==> class method))
         (cj (classof j)) )
    (pretty-print
     (cond
      ((= cj |DE|) 
       `(demethod ,(classname class) ,method ,@(cdr (funcdef j))))
      ((= cj |DF|) 
       `(dfmethod ,(classname class) ,method ,@(cdr (funcdef j))))
      ((= cj |DM|) 
       `(dmmethod ,(classname class) ,method ,@(cdr (funcdef j))))
      (t 
       `(putmethod ,(classname class) ',method ',j)) ) ) ) )

(demethod object pretty()
  ;; default pretty function
  (printf "%l ; lisp object with:\n" this (classof this))
  (pretty-slots this) )

(demethod class pretty()
  (printf "(defclass %l %l" (classname this) (classname (super this)))
  (each ((i (slots this)))
    (if (listp i)
        (printf "\n  (%l '%l)" (car i) (cadr i))
      (printf "\n   %l" i) ) )
  (printf " )\n")
  (each ((i (methods this)))
    (print)
    (pretty-method this i) ) )

(demethod |SYMB| pretty()
  (if (== this 'this)
      (printf "'%l\n" this)
    (let* ((e (eval this))
           (c (classof e))
           (x (and e (getp e 'source))) )
      (cond
       ;; compiled from source
       ((and c (setq x (getp e 'source)))
        (printf ";; compiled from:\n")
        (pretty-print x this) )
       ;; custom funcdef
       ((and c (check==> c 'funcdef))
        (pretty-print (==> e funcdef) this) )
       ;; lisp function
       ((and (functionp e) (setq x (funcdef e)))
        (pretty-print x this) )
       ;; custom pretty printer
       ((and c (check==> c 'pretty))
        (==> e pretty) )
       ;; default
       (t
        (pretty-print e) ) ) ) ) )

(demethod |DE| pretty()
  (pretty-print (funcdef this)) )

(demethod |DF| pretty()
  (pretty-print (funcdef this)) )

(demethod |DM| pretty()
  (pretty-print (funcdef this)) )

(demethod |DX| pretty()
  (printf "%l ; DX-type intrinsic function\n" this) )

(demethod |DY| pretty()
  (printf "%l ; DY-type intrinsic function\n" this) )

(demethod |INDEX| pretty()
  (index-print this) (print) )

(dm pretty(pretty f)
    (nodebug
     (if (symbolp f) 
	 `(nodebug (==> ',f pretty))
       `(let* ((x ,f)(c (classof x)))
          (if (and c (check==> c 'pretty))
              (==> x pretty)
            (pretty-print x) ) ) ) ) )

(dmc |^P| `(pretty ,(read)))  

(dm save(save f . l)
  (when l
    `(nodebug (writing (open-write ,f "lsh")
		,@(all ((i l)) (list 'pretty i)) ) ) ) )

(lock-symbol pretty-slots pretty-method pretty-print pretty save |^P|)





;;; --------- Edition Functions ---------

(setq edit-call ())
(setq edit_buffer (tmpname () "lush"))
(cond
  ((not wintl3p)
   ;; unix
   (setq edit-call (getenv "EDITOR"))
   (when (= edit-call "")
     (setq edit_call "vi") ) 
   (when (= edit-call "dm")
     (setq edit-call ()) ) )
  ((winlushp)
   ;; windows GUI
   (setq edit-call ()) )
  (t
    ; windows Console
    (setq edit-call "edit") ) )

(de edit(_s_)
  (cond
    (edit_call   (sys (concat edit_call " " _s_)))
    (xdmc        (xdmc (concat "ce " _s_)))
    (winedit     (winedit _s_)) ) )

(de fedit(_s_)
   (if _s_ 
        (eval (list 'save edit_buffer _s_)))
   (edit edit_buffer)
   (when edit-call
     (load edit_buffer) ) )

(dmc |^E| `(edit ,(read-string)))

(dmc |^F| `(fedit ',(named (read-string))))

(lock_symbol edit fedit |^E| |^F|)
                       






;;; --------- List of symbols ---------

(de symbols p 
   (if p 
      (setq p (car p)) 
      (setq p "") ) 
   (let ((pos 0)) 
        (each ((i (symblist))) 
           (when (index p i) 
              (printf "%s" (left i 17)) 
              (setq pos (if (< pos 50) 
                              (+ pos 19) 
                              (printf "\n") 
                              0 )) 
              (tab pos) ) ) ) 
   (print) )
	
(dmc |^S| (list 'symbols (read_string)))

(lock_symbol |^S| symbols )






;;; --------- Online Help Support ---------

(setq help-root ())

(dmc |^A| (list 'apropos (read-string)))

(dmc |#?|
     (when (and file-being-loaded (<> file-being-loaded "$stdin"))
	   (let ((hroot (assoc file-being-loaded help-root)))
	     (if hroot
		 (rplacd hroot ())
	       (setq hroot (list file-being-loaded))
	       (setq help-root (cons hroot help-root)) ) ) )
     (skip-char "~\n\r")
     () )





;;; --------- Standard Aliases -----------

;; some may find themselves more familiar with these names

(setq defun de)
(setq += incr)
(setq << setq)

;; consistent naming for storages and matrices

(setq float-matrix f-matrix)
(setq double-matrix d-matrix)
(setq int-matrix i32-matrix)
(setq short-matrix i16-matrix)
(setq byte-matrix i8-matrix)
(setq ubyte-matrix u8-matrix)
(setq packed-matrix p-matrix)
(setq atom-matrix at-matrix)
(setq float-storage new-f-storage)
(setq double-storage new-d-storage)
(setq int-storage new-i32-storage)
(setq short-storage new-i16-storage)
(setq byte-storage new-i8-storage)
(setq ubyte-storage new-u8-storage)
(setq gptr-storage new-gptr-storage)
(setq packed-storage new-p-storage)
(setq atom-storage new-at-storage)

(lock-symbol
        float-matrix double-matrix int-matrix short-matrix 
        byte-matrix ubyte-matrix packed-matrix atom-matrix
        float-storage double-storage int-storage short-storage 
        byte-storage ubyte-storage gptr-storage packed-storage 
        atom-storage)

;; backward compatibility with SN1, SN2

(dm dim(f v . l)
  (list 'setq v (list 'f-matrix . l)) )

;; backward compat with SN3

(setq mload libload)
(lock_symbol mload)




;;; --------- Search Startup File -----------

;; find the first file that exists fo the form
;; <dir>/<file>.<ext> where <dir> is on of the
;; directories in list <dirlist> and <ext> is
;; one of the suffixes in <extlist>.
;; example: (find-file '("local" "lsh") "lushenv" '(".lshc" ".lsh"))
;; this is somewhat redundant with the DX <filepath>,
;; but we can't set the standard path here.

(de find-file (dirlist file extlist)
    (let ((keepgoing t) (e ()) (d ()) (f ()) (r ()))
      (while (and keepgoing dirlist)
        (setq d (car dirlist))
        (setq e extlist)
        (while (and keepgoing e)
          (setq f (concat-fname d (concat file (car e))))
          (when (filep f)
            (setq r f) (setq keepgoing ()))
          (setq e (cdr e)))
        (setq dirlist (cdr dirlist)))
      r))

;; find the default lushenv.[dump,lshc,lsh] in
;; curent dir, local, packages, and lsh and set 
;; lushenv-path to it

(setq lushenv-path 
      (let* ((dlist (cons "." (all ((x '("local" "packages" "lsh"))) 
                                (concat-fname lushdir x))))
             (elist '(".dump" ".lshc" ".lsh")))
        (find-file dlist "lushenv" elist)))


