;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; LUSH Lisp Universal Shell
;;;   Copyright (C) 2002 Leon Bottou, Yann Le Cun, AT&T Corp, NECI.
;;; Includes parts of TL3:
;;;   Copyright (C) 1987-1999 Leon Bottou and Neuristique.
;;; Includes selected parts of SN3.2:
;;;   Copyright (C) 1991-2001 AT&T Corp.
;;;
;;; This program is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 2 of the License, or
;;; (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program; if not, write to the Free Software
;;; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; $Id: dh-macro.lsh,v 1.5 2002-07-22 16:17:05 leonb Exp $
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;;; ------------------------------------------------------------------------
;;; ------------------------------------------------------------------------
;;;                  D   H   M       S   E   C   T   I   O  N
;;; ------------------------------------------------------------------------
;;; ------------------------------------------------------------------------


(libload "dh-util")



;;; ------------------------------------------------------------------------
;;; ERASE PREVIOUS DHMS
;;; ------------------------------------------------------------------------

(when dhc-debug-flag
  (when (is-of-class |*PROPERTIES| |HTABLE|)
    (let ((lambda-t (get-dhm-t lambda))
          (lambda-c (get-dhm-c lambda)) )
      (|*PROPERTIES| 'dhm-t ())
      (|*PROPERTIES| 'dhm-c ())
      (|*PROPERTIES| 'dhm-p ()) 
      (putp lambda 'dhm-t lambda-t)
      (putp lambda 'dhm-c lambda-c) ) ) )


;;; ------------------------------------------------------------------------
;;; DHM FOR TYPE DECLARATIONS AND CONVERSIONS
;;; ------------------------------------------------------------------------

(defvar dhc-type-to-dht-alist
  (append (mapfor (i 0 15)
            (list (eval `:,(named (sprintf "-idx%d-" i))) 'dht-idx i) )
          (list (list -bool-   'dht-bool)
                (list -ubyte-  'dht-ubyte)
                (list -byte-   'dht-byte)
                (list -int-    'dht-int)
                (list -short-  'dht-short)
                (list -flt-    'dht-flt)
                (list -real-   'dht-real)  
                (list -str-    'dht-str)
                (list -obj-    'dht-obj)
                (list -list-   'dht-list)
                (list -gptr-   'dht-gptr) ) ) )

(de dhc-format-to-t-node(source)
  (let* ((target (get-dhm-target source))
         (dhassoc (assoc target dhc-type-to-dht-alist))
         (dhtype (when dhassoc (cadr dhassoc)))
         (resultant ()) )
    (when (not dhtype)
      (dhc-error "Unrecognized type specifier" source) )
    (cond
     ;; SIMPLE
     ((member dhtype dhc-simple-types)
      (setq resultant
            (new t-node () 
                 (new dhc-type dhtype)
                 (car source)))
      (new t-node (list resultant)
           (==> :resultant:type copy) ()))
     ;; GPTR
     ((= dhtype 'dht-gptr)
      (setq resultant
            (new t-node () 
                 (new dhc-type dhtype
                      (cond
                       ((stringp (cadr source))
                        (cadr source) )
                       ((cadr source)
                        (sprintf "struct CClass_%s*"
                                 (dhc-lisp-to-c-name (pname (caadr source))) ) ) ) )
                 (car source)))
      (new t-node (list resultant)
           (==> :resultant:type copy) ()))
     ;; IDX
     ((= dhtype 'dht-idx)
      (let* ((ndim (caddr dhassoc))
             (type-t-node (dhc-format-to-t-node (cadr source)))
             (idx-type (new dhc-type 'dht-ptr
                            (new dhc-type 'dht-idx ndim
                                 (new dhc-type 'dht-srg
                                      (==> :type-t-node:type copy))))))
        (new t-node (list (new t-node () (==> idx-type copy) (car source))
                          type-t-node) (==> idx-type copy) ())))
     ;; LIST
     ((= dhtype 'dht-list)
      (let* ((types-t-nodes (all ((arg (cdr source))) (dhc-format-to-t-node arg)))
             (types (all ((tn types-t-nodes)) :tn:type))
             (list-type (new dhc-type 'dht-list types)))
        (new t-node (cons (new t-node () (==> list-type copy) (car source))
                          types-t-nodes) (==> list-type copy) ())))
     ;; OBJECT
     ((= dhtype 'dht-obj)
      (new t-node ()
           (new dhc-type 'dht-ptr
                (dhc-obj-type-from-class 
                 (dhc-lisp-to-c-name (caadr source))) source)))
     ;; ERROR 
     (t 
      (dhc-error "declaration type not implemented" (car source)) ) ) ) )


(dhm-t declare(source)
  (let ((format (cadr source))
        (args (cddr source))
        (args-t-nodes ())
        (format-t-node ())
        (format-dhc-type ())
        (dhc-declaration-mode t))
    (each ((arg args))
      (when ~(symbolp arg) (dhc-error "Not a symbol" arg)))
    (on-error
        (dhc-error "declaration format error" source)
      (verify-type-decl-format format))
    (setq format-t-node (dhc-format-to-t-node format))
    (setq format-dhc-type :format-t-node:type)
    (setq args-t-nodes (dhc-parse-progn-t args))
    (setq rst (all ((rn :args-t-nodes:tn-list))
                (dhc-unify-types :rn:type (==> format-dhc-type copy))))
    (new t-node (cons format-t-node (all ((a :args-t-nodes:tn-list)) a))
         (==> format-dhc-type copy) source)))

(dhm-c declare (source treetype retplace)
       (dhc-parse-progn-c (cddr source) (cddr :treetype:tn-list) retplace) )



;;; ------------------------------------------------------------------------

(de dhc-cast-t (source type allowed)
  (if (<> (length source) 2)
      (dhc-error "takes one arg" (car source)))
  (let* ((tn (dhc-parse-expr-t (cadr source) ignore))
         (typename (unode-val (scope :tn:type u-tclass))))
    (if ~(member typename allowed)
      (dhc-error (sprintf "Casting to %s.  One of %s expected: %s found"
                          (pname (dht-short type))
                          (pname allowed)
                          (pname (dht-short typename))))
      (new t-node (list tn) (new dhc-type type) ()))))

(de dhc-cast-c (source stype treetype retplace)
  (concat "(" stype ")(" 
          (dhc-parse-expr-c (cadr source) (cadr :treetype:tn-list) ())
          ")" ))

(dhm-t to-number(source)
  (dhc-cast-t source 'dht-number (cons 'dht-dc dhc-number-types)))
(dhm-c to-number(source treetype retplace)
  (dhc-parse-expr-c (cadr source) (cadr :treetype:tn-list) retplace) )

(dhm-t to-flt(source)
  (dhc-cast-t source 'dht-flt (cons 'dht-dc dhc-number-types)))
(dhm-c to-flt(source treetype retplace)
  (dhc-cast-c source "flt" treetype retplace))

(dhm-t to-int(source)
  (dhc-cast-t source 'dht-int (cons 'dht-dc dhc-number-types)))
(dhm-c to-int(source treetype retplace)
  (dhc-cast-c source "int" treetype retplace))

(dhm-t to-real(source)
  (dhc-cast-t source 'dht-real (cons 'dht-dc dhc-number-types)))
(dhm-c to-real(source treetype retplace)
  (dhc-cast-c source "real" treetype retplace))

(dhm-t to-bool(source)
  (dhc-cast-t source 'dht-bool (cons 'dht-dc dhc-number-types)))
(dhm-c to-bool(source treetype retplace)
  (dhc-cast-c source "char" treetype retplace))


(dhm-t int(source)
  (dhc-cast-t source 'dht-int (cons 'dht-dc dhc-number-types)))
(dhm-c int(source treetype retplace)
  (concat "((int)floor((double)"
          (dhc-parse-expr-c (cadr source) (cadr :treetype:tn-list) retplace)
          "))" ) )

(dhm-t to-gptr(source)
  (dhc-cast-t source 'dht-gptr '(dht-gptr dht-ptr dht-nil dht-func dht-dc)) )

(dhm-c to-gptr(source treetype retplace)
  (let ((argtype :(cadr :treetype:tn-list):type))
    (if (<> (dhu-tclass argtype) 'dht-func)
        ;; simple cast
        (dhc-cast-c source "gptr" treetype retplace)
      ;; function cast
      (let* ((name (cadr source))
             (symbol (dhc-search-symtable name global-table))
             (cfunc ()) )
        (cond
         (symbol
          (setq cfunc (concat "C_" :symbol:c-name)) )
         ((symbolp name)
          (setq cfunc (car (dhinfo-c (eval `:,name)))) )
         (t
          (setq cfunc (car (dhinfo-c name))) ) )
        ;; extern
        (dhc-add-c-externs
         (sprintf "extern %s;" (dhc-compose-prototype argtype cfunc)) )
        (sprintf "(gptr)&(%s)" cfunc) ) ) ) )



;;; ------------------------------------------------------------------------
;;; DHM FOR PARSING SPECIAL STRUCTURES
;;; ------------------------------------------------------------------------

(dhm-t progn(source)
  (dhc-parse-progn-t (cdr source)))

(dhm-c progn(source treetype retplace)
  (dhc-parse-progn-c (cdr source) (cdr :treetype:tn-list) retplace))

(dhm-t prog1(source)
  (setq source (cdr source))
  (if (consp source)
      (let ((treetype-list 
             (append (list (dhc-parse-expr-t (car source) ignore))
                     (all ((so (cdr source)))
                       (dhc-parse-expr-t so t)))))
        (new t-node treetype-list :(car treetype-list):type () ()))
    ;; empty prog1
    (new t-node () (new dhc-type 'dht-nil) ())))

(dhm-c prog1(source treetype retplace)
  (let ((source (cdr source))
        (treetype-list (cdr :treetype:tn-list))
        (ret ()))
    (if ~(consp source)
      "0"
      (when (and ~retplace ~:treetype:ignore)
        (setq retplace (dhc-declare-temp-var :treetype:type "_prog1ret")))
      (setq ret (dhc-parse-expr-c (car source) (car treetype-list)
                                  retplace))
      (each ((so (cdr source)) (ty (cdr treetype-list)))
        (dhc-parse-expr-c so ty ()))
      ret)))

(dhm-t setq(source)
  (setq source (cdr source))
  (when ~(and (consp source) (consp (cdr source)) (not (cddr source)))
        (dhc-error "Setq takes two arguments" ) )
  (if (and (consp (car source))
           (= 'scope (car (car source))))
      (let ((sym (dhc-parse-expr-t (car source)))
            (expr (dhc-parse-expr-t (cadr source))))
        (let ((objtype (dhu-type :(last :sym:tn-list):type)))
          (==> objtype access 'write) )
        (dhc-assign-unify :sym:type :expr:type)
        (new t-node (list sym expr) :sym:type ()))
    (let* ((sym (dhc-check-symbol (car source)))
           (expr (dhc-parse-expr-t (cadr source))))
      (dhc-assign-unify :sym:type :expr:type)
      (new t-node (list (new t-node () :sym:type (car source) sym)
                        expr)
           :sym:type))))

(dhm-c setq(source treetype retplace)
  (if (and (consp (cadr source))
           (= 'scope (car (cadr source))))
      (let ((src (dhc-parse-expr-c (cadr source)
                                   (cadr :treetype:tn-list) ()))
            (expr (dhc-parse-expr-c (caddr source)
                                    (caddr :treetype:tn-list) ())))
        (dhc-add-c-statements (sprintf "%s = %s;" src expr))
        src)  
    (dhc-parse-expr-c (caddr source) (caddr :treetype:tn-list)
                      (scope :(cadr :treetype:tn-list):symbol c-name))))

(dhm-t print(source)
  (if (consp source)
      (let ((treetype-list
             (all ((so (cdr source)))
               (if ~(stringp so)
                 (dhc-parse-expr-t so)
                 (new t-node () (new dhc-type 'dht-str) so ())))))
        (if ~(==> :(last treetype-list):type is-a-str)
          (new t-node treetype-list :(last treetype-list):type () ())
          (let* ((rettype (new dhc-type 'dht-str))
                 (srg-type (dhu-type rettype))
                 (symbol-srg (new dhc-symbol 
                                  (named (sprintf "%d_srg" tmpnames-seed))
                                  lex-level))
                 (tret (new t-node treetype-list rettype ())))
            (setq :srg-type:u-extra (new-unode rettype))
            (incr tmpnames-seed)
            (dhc-unify-types :symbol-srg:type srg-type)
            (setq bump-list (append bump-list (list symbol-srg)))
            (setq :symbol-srg:no-declare (cons 'no-declare tret))
            (setq :tret:transfer (list symbol-srg))
            tret)))
    (new t-node () (new dhc-type 'dht-nil) () ())))

;; should be expanded to matrices, etc.
(de dhc-print-c(item treetype)
  (let ((type :treetype:type))
    (dhc-add-c-statements
     (cond ((or (==> type is-a-flt)
                (==> type is-a-real))
            (sprintf "printf(\"%%g \", (%s) %s);"
                     (dhc-type-to-c-decl type) item))
           ((==> type is-a-bool)
            (sprintf "printf(\"%%s \", (%s==0) ? \"()\" : \"t\");"
                     item))
           ((==> type is-an-integer)
            (sprintf "printf(\"%%d \", %s);" item))
           ((==> type is-a-ptr)
            (sprintf "printf(\"%%x \", %s);" retplace))
           (t
            (dhc-error "can't print this this object's type"
                       (scope :treetype:symbol lisp-name)))
           ))
    ()))

(dhm-c print(source treetype retplace)
  (if ~(consp (cdr source))
    "0"
    (each ((ty (dhc-nolast (cdr :treetype:tn-list)))
           (so (dhc-nolast (cdr source))))
      (if (stringp so)
          (dhc-add-c-statements
           (sprintf "printf(\"\\\"%s\\\" \");"
                    (dhc-printf-to-c so)))
        (dhc-print-c (dhc-parse-expr-c so ty ()) ty)))
    ;; in case the expr being printed returns "inline".
    (let ((ret ()))
      ;; HACK for STRINGS
      (if (stringp (last source))
          (progn (dhc-add-c-statements
                  (sprintf "printf(\"\\\"%s\\\"\");"
                           (dhc-printf-to-c (last source))))
                 (when ~:treetype:ignore
                   (dhc-add-c-statements
                    (sprintf "Msrg_resize(%s,strlen(\"%s\"));"
                             :(last :treetype:transfer):c-name
                             (dhc-printf-to-c (last source))))
                   (dhc-add-c-statements 
                    (sprintf "strcpy(%s->data,\"%s\");"
                             :(last :treetype:transfer):c-name
                             (dhc-printf-to-c (last source))))
                   (setq ret :(last :treetype:transfer):c-name))
                 "0")
        (setq ret (dhc-parse-expr-for-multi-use-c 
                   (last source) (last :treetype:tn-list) retplace))
        (dhc-print-c ret (last :treetype:tn-list)))
      (when (getp (get-dhm-target source) 'dharg)
        (dhc-add-c-statements "printf(\"\\n\");"))
      ret)))

(putp print 'dharg t)
(dhm-t-declare print prin)
(dhm-c-declare print prin)


(dhm-t error(source)
  (when (or (cddr source) (not (stringp (cadr source))))
    (dhc-error "bad error statement"))
  ;; can't parse string arg
  ;; don't know what will be returned
  (new t-node (list (new t-node () (new dhc-type 'dht-unk) (cadr source)))
       (new dhc-type 'dht-dc)))

(dhm-c error(source treetype retplace)
  (dhc-add-c-statements (sprintf "run_time_error(\"%s\");" (cadr source)))
  (if (and (==> :treetype:type is-a-simple)
           ~(==> :treetype:type is-a-dhm))
      "0" ;; good for numbers, bools, etc
    (dhc-error "error statement's return value conflicts" source)))


(de dhc-for-declare-var-t(dcl)
  (when (or (> (length dcl) 4) (< (length dcl) 3))
    (dhc-error "Bad 'for' arguments" dcl) )
  (when ~(symbolp (car dcl))
        (dhc-error "Not a symbol" (car dcl)))
  (let* ((loop (new dhc-symbol (car dcl) lex-level))
         (start (dhc-parse-expr-t (cadr dcl)))
         (end (dhc-parse-expr-t (caddr dcl)))
         (step (when (= (length dcl) 4) (dhc-parse-expr-t (nth 3 dcl))))
         (tlist (if step (list start end step) (list start end)))
         (treetype (new t-node
                        (cons (new t-node () :loop:type (car dcl) loop)
                              tlist)
                        (new dhc-type 'dht-unk))))
    (dhc-unify-types :start:type :end:type)
    (when step (dhc-unify-types :start:type :step:type))
    (dhc-assign-unify :loop:type :start:type)
    (setq bump-list (append bump-list (list loop)))
    (setq :treetype:ignore t)
    (setq new-symbol-table 
          (dhc-add-to-symtable new-symbol-table loop))
    treetype))

(dhm-t for(source)
  (when (or (< (length source) 2)
            ~(consp (cadr source)))
    (dhc-error "for : Bad 'for' construction"))
  (let ((tn ())
        (tn2 ()))
    (dhc-push-scope-t
     (setq tn2 (dhc-for-declare-var-t (cadr source)))
     (setq symbol-table new-symbol-table)
     (setq tn (dhc-parse-progn-t (cddr source)))
     (setq :tn:tn-list (cons tn2 :tn:tn-list))
     (setq :tn:transfer ignore)
     tn)))

(dhm-c for(source treetype retplace)
  (let (( (loop start end &optional step) (cadr source))
        ( (loopT startT endT &optional stepT)
          :(cadr :treetype:tn-list):tn-list)
        (loopN ())
        (endN ())
        (stepN ()))
    (when ~step
      (setq step 1)
      (setq stepT (dhc-parse-expr-t 1)))
    
    (dhc-push-scope-c 
     treetype retplace
     (setq endN (dhc-parse-expr-for-multi-use-c end endT ()))
     (setq stepN (dhc-parse-expr-for-multi-use-c step stepT ()))
     (setq loopN (scope :loopT:symbol c-name))
     (dhc-parse-expr-for-multi-use-c start startT loopN)
     (if (not (or dhc-unprotect :treetype:transfer))
         (dhc-add-c-statements
          (sprintf "RTERR_RTYPE(!((%s>0)?(%s<=%s):(%s>=%s)));\n"
                   stepN loopN endN loopN endN)))
     (dhc-add-c-statements
      (sprintf "for(;")
      (sprintf "((%s>0)?(%s<=%s):(%s>=%s));"
               stepN loopN endN loopN endN )
      (sprintf "(%s)+=%s ) {" loopN stepN )
      )
     (setq retplace (dhc-parse-progn-c (cddr source)
                                       (cddr :treetype:tn-list)
                                       retplace))
     (dhc-add-c-statements "}")
     retplace )))

(dhm-t-declare progn protect unprotect)

(dhm-c protect(source treetype retplace)
       (let ((dhc-unprotect ()))
	 (dhc-parse-progn-c (cdr source)
			    (cdr :treetype:tn-list) retplace)))

(dhm-c unprotect(source treetype retplace)
       (let ((dhc-unprotect t))
	 (dhc-parse-progn-c (cdr source)
			    (cdr :treetype:tn-list) retplace)))

(dhm-t breakp(source)
  (when (<> 1 (length source))
    (dhc-error "breakp takes no arguments!"))
  (new t-node () (new dhc-type 'dht_nil)))

(dhm-c breakp(source treetype retplace)
  (dhc-add-c-statements 
   "if(break_attempt) run_time_error(\"breakp in compiled code\");")
  "0")


;;; ------------------------------------------------------------------------
;;; DHM FOR DIRECT CALL OF C FUNCTION
;;; ------------------------------------------------------------------------

(dhm-t ccall(source)
  (when (< (length source) 2)
    (dhc-error "one or more args expected"))
  (new t-node (append (list (new t-node () (new dhc-type 'dht-unk) (cadr source)))
                      (all ((so (cddr source))) (dhc-parse-expr-t so)))
       (new dhc-type 'dht-dc)))

(dhm-c ccall(source treetype retplace)
  (let ((name (cadr source))
        (args (all ((so (cddr source)) (tn (cddr :treetype:tn-list)))
                (dhc-parse-expr-for-multi-use-c so tn ()))))
    ;; is not typed, so we can't create a retplace
    ;; if return value is not ignored, we must return inline
    (if ~:treetype:ignore
        (sprintf "%s(%s)" name (dhc-insert-op args ","))
      (dhc-add-c-statements
       (sprintf "%s(%s);" name (dhc-insert-op args ",")))
      "" )))

(dhm-t cinline(source)
  (when (< (length source) 2)
    (dhc-error "one or more args expected"))
  (new t-node (append (list (new t-node () (new dhc-type 'dht-unk) (cadr source)))
                      (all ((so (cddr source))) (dhc-parse-expr-t so)))
       (new dhc-type 'dht-dc)))

(dhm-c cinline(source treetype retplace)
  (let ((fmt (cadr source))
        (args (all ((so (cddr source)) (tn (cddr :treetype:tn-list)))
                (dhc-parse-expr-for-multi-use-c so tn ())))
        (line ()))
    (setq line (apply 'sprintf (cons fmt args)))
    ;; is not typed, so we can't create a retplace
    ;; if return value is not ignored, we must return inline
    (if ~:treetype:ignore
        line
      (dhc-add-c-statements 
       (concat line (if (= (right line 1) ";") "" ";")))
      "" )))

(dhm-t cheader (source)
  (when (< (length source) 2)
    (dhc-error "one or more args expected"))
  (each ((s (cdr source)))
    (if ~(stringp s)
      (dh-error "string expected" s)))
  (new t-node (all ((so (cdr source))) 
                (new t-node () (new dhc-type 'dht-unk)))
       (new dhc-type 'dht-dc)))

(dhm-c cheader (source treetype-list retplace)
  (dhc-add-c-header (cdr source)))

(de cpheader (name . args)
  (error NIL "cpheader can only be called in a compiled function"))

(dhm-t cpheader (source)
  (when (< (length source) 2)
    (dhc-error "one or more args expected"))
  (each ((s (cdr source)))
    (if ~(stringp s)
      (dh-error "string expected" s)))
  (new t-node (all ((so (cdr source))) 
                (new t-node () (new dhc-type 'dht-unk)))
       (new dhc-type 'dht-dc)))

(dhm-c cpheader (source treetype-list retplace)
  (dhc-add-c-pheader (cdr source)))

(dhm-t cidx-bloop(source)
  (when ~(cddr source)
        (dhc-error "cidx-bloop syntax error"))
  (let ((vars ())
        (ignore t)
        (vars-t ())
        (inds ())
        (inds-t ())
        (tn ())
        (ret ()))
    (each ((truc (cadr source)))
      (if ~(stringp truc)
        (progn
          (if (or (<> (length truc) 2) ~(stringp (car truc)))
              (dhc-error
               (sprintf 
                "syntax error in decls: expecting (\"cvar\" lvar)%l"
                truc)))
          (setq inds (nconc1 inds truc)))
        (if inds
            (dhc-error
             (sprintf 
              "syntax error in decls: expecting (\"cvar\" lvar): %l" 
              truc)))
        (setq vars (nconc1 vars truc))))
    ;; parse loop indices
    (if ~vars
        (dhc-error
         "syntax error in decls: no looping string integer index found"))
    (setq vars-t (all ((var vars)) (new t-node () 
                                        (new dhc-type 'dht-str) var)))
    (when (> (length vars) 8)
      (dhc-error "Cannot loop on idx with more than 8 dimensions"))
    ;; parse idxes
    (if ~inds
        (dhc-error
         "syntax error in decls: no idx to loop on found"))
    (setq inds-t 
          (all ((ind inds))
            (let ((cname (new t-node () (new dhc-type 'dht-str) (car ind)))
                  (lvar (dhc-parse-expr-t (cadr ind))))
              (if ~(==> :lvar:type is-an-idxptr)
                (dhc-error
                 (sprintf "syntax error in decls: idx expected: %l"
                          (cadr ind))))
              (if (< (==> :lvar:type is-an-idxptr) (length vars))
                  (dhc-error
                   (sprintf "idx does not have enough dimensions: %l"
                            (cadr ind))))
              (new t-node (list cname lvar) (new dhc-type 'dht-nil)))))
    (setq tn (new t-node (append vars-t inds-t) (new dhc-type 'dht-nil)))
    (setq ret (dhc-parse-progn-t (cddr source)))
    (setq :ret:tn-list (cons tn :ret:tn-list))
    (setq :ret:type :(cadr :(last inds-t):tn-list):type)
    ret)))

(dhm-c cidx-bloop(source treetype retplace)
  (let ((inames ())
        (cnames ())
        (idxs ())
        (idxs-names ())
        (idxtypes ())
        (ret-expr ())
        (indices ())
        (matrices ())
        (idxi ())
        (n ()))
    (each ((so (cadr source)) (tn :(cadr :treetype:tn-list):tn-list))
      (if (==> :tn:type is-a-str)
          (setq inames (nconc1 inames so))
        (setq cnames (nconc1 cnames (car so)))
        (setq idxs (nconc1 idxs
                           (dhc-parse-expr-c (cadr so) 
                                             (cadr :tn:tn-list) ())))
        (setq idxtypes (nconc1 idxtypes (==> :(cadr :tn:tn-list):type
                                             get-element-decl)))))
    (setq idxi (length inames))
    (setq n (length cnames))
    (setq idxs-names (mapcar (lambda (x) (regex-subst "&|->" "_" x))
                             idxs))
    (dhc-add-c-statements "{")
    (for (i 0 (1- idxi))
         (dhc-add-c-statements (sprintf "int _%s_max = (%s)->dim[%d];"
                                        (nth i inames) (car idxs) i))
         (for (j 0 (1- n))
              (dhc-add-c-statements 
               (sprintf "int _%s_mod%d = (%s)->mod[%d];" 
                        (nth j idxs-names) i (nth j idxs) i))))
    
    (for (i 0 (1- idxi))
         (for (j 1 (1- n))
              (dhc-add-c-statements
               (sprintf "if(_%s_max != (%s)->dim[%d])"
                        (nth i inames) (nth j idxs) i)
               (sprintf 
                (concat "run_time_error(\"idx %s's dim %d "
                        "doesn't match idx %s's dim %d\");")
                (nth j idxs) i (car idxs) i))))
    (dhc-add-c-statements "{")
    (for (i 0 (1- idxi))
         (dhc-add-c-statements (sprintf "int %s;" (nth i inames)))
         (for (j 0 (1- n))
              (dhc-add-c-statements 
               (concat (sprintf "%s " (nth j idxtypes))
                       (if (= i (- idxi 1))
                           (sprintf "*%s = " (nth j cnames))
                         (sprintf "*_%s_loop_%s = " (nth j idxs-names)
                                  (nth i inames)))
                       (if (= i 0)
                           (sprintf "IDX_PTR((%s),%s);"
                                    (nth j idxs) (nth j idxtypes))
                         (sprintf "_%s_loop_%s;" (nth j idxs-names)
                                  (nth (1- i) inames))))))
         (dhc-add-c-statements (sprintf "for (%s=0; %s<_%s_max; %s++) {"
                                        (nth i inames) (nth i inames)
                                        (nth i inames) (nth i inames))))
    (dhc-parse-progn-c (cddr source) (cddr :treetype:tn-list) ())
    (for (i 0 (1- idxi))
         (for (j 0 (1- n))
              (dhc-add-c-statements
               (concat 
                (if (= i 0) 
                    (sprintf "%s" (nth j cnames))
                  (sprintf "_%s_loop_%s" (nth j idxs-names)
                           (nth (1- (- idxi i))
                                inames)))
                " += " (sprintf "_%s_mod%d;" (nth j idxs-names)
                                (1- (- idxi i))))))
         (dhc-add-c-statements "}"))
    (dhc-add-c-statements "}}")
    (last idxs)))


;;; ------------------------------------------------------------------------
;;; functions for parsing TESTS
;;; ------------------------------------------------------------------------

(dhm-t and(source)
  (let ((ands (reverse (cdr source)))
        (expr '(progn t)))
    (while ands    
      (setq expr `(if ,(car ands) ,expr ()))
      (setq ands (cdr ands)))
    (dhc-parse-replacement-source-t source expr)))

(dhm-t or(source)
  (let ((ors (reverse (cdr source)))
        (expr '(progn ())))
    (while ors    
      (setq expr `(if ,(car ors) t ,expr))
      (setq ors (cdr ors)))
    (dhc-parse-replacement-source-t source expr)))

(dhm-t not(source)
  (when (<> 2 (length source))
    (dhc-error "'not' takes one argument"))
  (let ((tn (dhc-parse-expr-t (cadr source))))
    (when (<> 'dht-gptr (dhu-tclass :tn:type))
      (dhc-unify-types :tn:type (new dhc-type 'dht-bool)) )
    (new t-node (list tn) (new dhc-type 'dht-bool))))

(dhm-c not(source treetype retplace)
  (sprintf  "!(%s)"
            (dhc-parse-expr-c (cadr source) (cadr :treetype:tn-list)
                              retplace)))

;; also uses source
(de dhc-comparison-t(cop)
  (when (<> 3 (length source))
    (dhc-error "this operator takes two arguments"))
  (let* ((r1 (dhc-parse-expr-t (cadr source)))
         (r2 (dhc-parse-expr-t (caddr source)))
         (t1 :r1:type)
         (t2 :r2:type))   
    (when (and ~(and (==> t1 is-a-number) (==> t2 is-a-number))
               ~(and (==> t1 is-a-bool) (==> t2 is-a-bool))
               ~(and (==> t1 is-a-gptr) (==> t2 is-a-gptr))
               ~(and (==> t1 is-a-str) (==> t2 is-a-str))
               ~(and (==> t1 is-an-objptr) (==> t2 is-an-objptr)
                     (or (= cop "==") (= cop "!="))) )
      (dhc-error "illegal type(s) for test expression" t1))
    ;; (dhc-unify-types (==> t1 copy) (==> t2 copy))
    (new t-node (list r1 r2) (new dhc-type 'dht-bool))))

;; also uses source treetype retplace
(de dhc-comparison-c(cop)
  ;; if ~ignore unify bool ??
  (let ((e1 (dhc-parse-expr-c (cadr source) (cadr :treetype:tn-list) ()))
        (e2 (dhc-parse-expr-c (caddr source) (caddr :treetype:tn-list) ())))
    (if (==> :(cadr :treetype:tn-list):type is-a-str)
        (sprintf "(strcmp((%s)->data, (%s)->data) %s 0)" e1 e2 cop)
      (concat "(" e1 cop e2 ")" ) )
    ))

(dhm-t =(source)                   (dhc-comparison-t "=="))
(dhm-c =(source treetype retplace) (dhc-comparison-c "=="))

(dhm-t <>(source)                   (dhc-comparison-t "!="))
(dhm-c <>(source treetype retplace) (dhc-comparison-c "!="))

(dhm-t <(source)                   (dhc-comparison-t "<"))
(dhm-c <(source treetype retplace) (dhc-comparison-c "<"))

(dhm-t >(source)                   (dhc-comparison-t ">"))
(dhm-c >(source treetype retplace) (dhc-comparison-c ">"))

(dhm-t <=(source)                   (dhc-comparison-t "<="))
(dhm-c <=(source treetype retplace) (dhc-comparison-c "<="))

(dhm-t >=(source)                   (dhc-comparison-t ">="))
(dhm-c >=(source treetype retplace) (dhc-comparison-c ">="))


;;; ------------------------------------------------------------------------
;;; DHM for parsing conditional structures if, when while....
;;; ------------------------------------------------------------------------

(dhm-t if(source)
  (when (< (length source) 3)
    (dhc-error (sprintf "bad '%l' construction:" (car source)) source))
  (let ((test (dhc-parse-expr-t (cadr source)))
        (true (dhc-parse-expr-t (caddr source) ignore))
        (false (when (> (length source) 3)
                 (dhc-parse-progn-t (nthcdr 3 source))))
        (rettype (new dhc-type 'dht-unk)))
    (when (<> 'dht-gptr (dhu-tclass :test:type))
      (dhc-unify-types :test:type (new dhc-type 'dht-bool)) )
    (when ~ignore
      (if false
          (progn 
            (dhc-assign-unify rettype :true:type)
            (dhc-assign-unify rettype :false:type))
        (dhc-unify-types :true:type (new dhc-type 'dht-bool))
        (dhc-unify-types rettype (new dhc-type 'dht-bool))))
    (new t-node (if false (cons test (cons true :false:tn-list))
                  (list test true))
         rettype () ())))

;; NOTE 'if' can produce empty 'then' and 'else' blocks if ignore is set
;; (progn (if t 1 2) 3)
;; this is true in sn3.0, if the user codes it...
(dhm-c if(source treetype retplace)
  (when (and ~retplace ~:treetype:ignore)
    (setq retplace (dhc-declare-temp-var :treetype:type)))
  (let (((ift testtn . bodytn) :treetype:tn-list)
        ((ifs testso . bodyso) source))
    (when (and ~:treetype:ignore
               (or (= ifs 'when) (= (length bodyso) 1)))
      (dhc-add-c-statements (sprintf "%s = 0;" retplace)))
    (let ((testc (dhc-parse-expr-c testso testtn () )))
      (dhc-add-c-statements (concat " if (" testc ") { " )))
    (when (= (get-dhm-target source) :if)
      (dhc-parse-expr-c (car bodyso) (car bodytn) retplace)
      (setq bodyso (cdr bodyso))
      (setq bodytn (cdr bodytn))
      (when (> (length bodyso) 0)
        (dhc-add-c-statements " } else { ")))
    (when (> (length bodyso) 0)
      (dhc-parse-progn-c bodyso bodytn retplace))
    (dhc-add-c-statements " } ")
    retplace ) )

(dhm-t when(source)
  (when (< (length source) 3)
    (dhc-error (sprintf "bad '%l' construction:" (car source)) source))
  (let ((test (dhc-parse-expr-t (cadr source)))
        (true (dhc-parse-progn-t (cddr source))))
    (when (<> 'dht-gptr (dhu-tclass :test:type))
      (dhc-unify-types :test:type (new dhc-type 'dht-bool)) )
    (when ~ignore
      (dhc-unify-types :true:type (new dhc-type 'dht-bool)))
    (new t-node (cons test :true:tn-list)
         :true:type () ())))

(dhm-c-declare if when)

(dhm-t cond(source)
  (if (or ~(cdr source) (apply or (mapcar null (cdr source))))
      (dhc-error "cond : Bad 'cond' construction"))
  (let ((conds (reverse (cdr source)))
        (expr (if ~ignore '(error "one condition of the cond must be true") ())))
    (while conds    
      (setq expr `(if ,(caar conds) ,(cons 'progn (cdar conds)) ,expr))
      (setq conds (cdr conds)))
    (dhc-parse-replacement-source-t source expr)))

(dhm-t selectq(source)
  (when (or ~(cdr source) ~(cddr source)
            (apply or (mapcar null (cddr source))))                     
    (dhc-error "selectq : Bad 'selectq' construction"))
  (let ((conds (reverse (cddr source)))
        (expr (if ~ignore '(error "one condition of the selectq must be true") ())) )
    (while conds  
      (setq expr `(if ,(if (= t (caar conds)) t
                         (if (or (numberp (caar conds))
                                 (stringp (caar conds)) )
                             `(= selectQTMP ,(caar conds))
                           (cons 'or (mapcar (lambda (x)
                                               `(= selectQTMP ,x))
                                             (caar conds)))))
                      ,(cons 'progn (cdar conds)) ,expr))
      (setq conds (cdr conds)))
    (setq expr `(let ((selectQTMP ,(cadr source))) ,expr))
    (dhc-parse-replacement-source-t source expr)))

(dhm-t while(source)
  (when (< (length source) 2)
    (dhc-error "while : Bad 'while' construction"))
  (let ((tn (dhc-parse-progn-t (cddr source)))
        (tn2 (dhc-parse-expr-t (cadr source))))
    (when (<> 'dht-gptr (dhu-tclass :tn2:type))
      (dhc-unify-types :tn2:type (new dhc-type 'dht-bool)) )
    (setq :tn:tn-list (cons tn2 :tn:tn-list))
    tn))

(dhm-c while(source treetype retplace)
  (when ~:treetype:ignore
    (when ~retplace
      (setq retplace (dhc-declare-temp-var :treetype:type)))
    (dhc-add-c-statements (sprintf "%s = 0;" retplace)))
  (let ((test (cadr source))
        (testT (cadr :treetype:tn-list))
        (label1 (sprintf "L_%d" (dhc-postincr label-seed)))
        (label2 (sprintf "L_%d" (dhc-postincr label-seed)))
        (ret ()))
    (dhc-add-c-statements
     (concat "/* While loop */\n"
             (sprintf "goto %s;\n" label2)
             (sprintf "%s:\n" label1)
             "{"
             ))
    (setq ret (dhc-parse-progn-c (cddr source) (cddr :treetype:tn-list)
                                 retplace))
    (dhc-add-c-statements (concat "}\n"
                                  "/* While loop test*/\n"
                                  (sprintf "%s:\n" label2)
                                  "{"))
    ;; assumes anything returned inline is a C expression (teste)
    (setq teste (dhc-parse-expr-c test testT ()))
    (dhc-add-c-statements (concat (sprintf "if (%s) goto %s;\n"
                                           teste
                                           label1)
                                  "}"))
    ret))



;;; ------------------------------------------------------------------------
;;; DHM for parsing LET and LET* ...
;;; ------------------------------------------------------------------------

(de dhc-let-declare-var-t(dcl)
    (when ~(and (consp dcl) (consp (cdr dcl)) (null (cddr dcl)))
	  (dhc-error "Syntax error" dcl) )
    (when ~(symbolp (car dcl))
	  (dhc-error "Not a symbol" (car dcl)))
    
    (let* ((sym (new dhc-symbol (car dcl) lex-level))
	   (ini (cadr dcl))
	   (node (dhc-parse-expr-t ini))
	   (symb-ini ())
	   (treetype (new t-node
			  (list (new t-node () :sym:type (car dcl) sym)
				node)
			  (new dhc-type 'dht-unk))))

      (dhc-assign-unify :sym:type :node:type)
      (setq :sym:type:u-access :node:type:u-access)

      ;; For name replacement.  It set no-declare to the alternate name
      (when (symbolp ini)
	    (setq symb-ini (dhc-search-symtable ini symbol-table))
	    (if symb-ini
		(setq :sym:no-declare symb-ini)))

      (setq bump-list (append bump-list (list sym)))
      (setq :treetype:ignore t)
      (setq new-symbol-table 
	    (dhc-add-to-symtable new-symbol-table sym))
      treetype))

(dhm-t let(source)
       (when ~(cddr source)
	     (dhc-error "'let syntax error"))
       (let ((tn ())
	     (ret ()))
	 (dhc-push-scope-t 
	  (setq tn (new t-node (all ((dcl (cadr source)))
                                 (dhc-let-declare-var-t dcl))
			(new dhc-type 'dht-unk)))
	  (setq symbol-table new-symbol-table)
	  (setq ret (dhc-parse-progn-t (cddr source)))
	  (setq :ret:tn-list (cons tn :ret:tn-list))
	  ret)))

(dhm-c let(source treetype retplace)
  (dhc-push-scope-c 
   treetype retplace
   (all ((decl (cadr source)) 
         (decl-type :(cadr :treetype:tn-list):tn-list))
     (dhc-parse-expr-c (cadr decl) (cadr :decl-type:tn-list)
                       :(car :decl-type:tn-list):symbol:c-name))
   (dhc-parse-progn-c (cddr source) (cddr :treetype:tn-list) retplace)))

(dhm-t let*(source)
  (when ~(cddr source)
        (dhc-error "'let syntax error"))
  (let ((tn ())
        (ret ()))
    (setq ret (dhc-push-scope-t 
               (setq tn (new t-node 
                             (all ((dcl (cadr source)))
                               (prog1
                                   (dhc-let-declare-var-t dcl)
                                 (setq symbol-table new-symbol-table)))
                             (new dhc-type 'dht-unk)))
               (dhc-parse-progn-t (cddr source))))
    (setq :ret:tn-list (cons tn :ret:tn-list))
    ret))

(dhm-c-declare let let*)





;;; ------------------------------------------------------------------------
;;; DHM FOR PARSING NUMBER OPERATIONS
;;; ------------------------------------------------------------------------

#? (process-numerical-args-t <arglist> <rettype>)
;; Process the arguments of a numerical expression, and determine the type of
;; the returned value. The arguments are passed in <arglist>, and the
;; type of the return value in <rettype>.
;;
(de process-numerical-args-t (arglist)

    ;; determin the natural type of each arglist, except if rettype is
    (let* ((types (all ((x arglist)) (dhc-parse-expr-t x)))
	   (rtyp (1+ (length dhc-number-types))))

      ;; determine return type of arglist. Casting is: number->int ->flt ->real
      ;; use priority order determined by dhc-number-types
      (each ((y types) (x arglist)) 
	    (if (not (==> :y:type is-a-number)) 
		(dhc-error "not a numerical expression" x))
	    (let ((prio (length (member (unode-val (scope :y:type u-tclass))
					dhc-number-types))))
	      (if (< prio rtyp) 
		  (setq rtyp prio))))
      (setq rtyp (nth (1- rtyp) (reverse dhc-number-types)))
      (new t-node types (new dhc-type rtyp))))

(de process-numerical-args-c (source treetype func-string)
    (concat "(" (dhc-insert-op 
		 (all ((so (cdr source)) (ty (cdr :treetype:tn-list)))
		      (dhc-parse-expr-c so ty ()))
		 func-string) ")"))

;;; N-ADIC FUNCTIONS
;;; -----------------

(dhm-t +(source)
       (process-numerical-args-t (cdr source)))

(dhm-c +(source treetype retplace)
       (process-numerical-args-c source treetype "+"))

(dhm-t *(source)
       (process-numerical-args-t (cdr source)))

(dhm-c *(source treetype retplace)
       (process-numerical-args-c source treetype "*"))

;;; DIADIC FUNCTIONS
;;; -----------------
(dhm-t -(source)
  (when (and (<> 2 (length source)) (<> 3 (length source)) )
	(dhc-error "wrong number of arguments"))
  (process-numerical-args-t (cdr source)))

(dhm-c -(source treetype retplace)
   (let ((arg1 (dhc-parse-expr-c (cadr source) (cadr :treetype:tn-list) ())))
     (if (= (length source) 2)
	 (concat "(-" arg1 ")")
       (concat "(" arg1 "-" (dhc-parse-expr-c (caddr source) 
					      (caddr :treetype:tn-list)
					      ()) ")"))))

(dhm-t /(source)
  (when (and (<> 2 (length source)) (<> 3 (length source)) )
	(dhc-error "wrong number of arguments"))
  (process-numerical-args-t (cdr source)))

(de dhc-c-cast (type)
    (if (==> type is-a-real) "(real)"
      (if (==> type is-a-flt) "(flt)" "")))

(dhm-c /(source treetype retplace)
       (let ((arg1 (dhc-parse-expr-c (cadr source) 
				     (cadr :treetype:tn-list) ())))
	 (if (= (length source) 2)
	     (sprintf "(1/%s%s)" (dhc-c-cast :(cadr :treetype:tn-list):type) 
		      arg1)
	   (sprintf "(%s/%s%s)" 
		    arg1 (dhc-c-cast :(cadr :treetype:tn-list):type)
		    (dhc-parse-expr-c (caddr source) 
				      (caddr :treetype:tn-list)
				      ())))))

(dhm-t div(source)
  (when (<> 3 (length source))
	(dhc-error "wrong number of arguments"))
  (process-numerical-args-t (cdr source)))

(dhm-c div(source treetype retplace)
       (let ((arg1 (dhc-parse-expr-c (cadr source) 
				     (cadr :treetype:tn-list) ())))
	   (sprintf "(((int)%s) / ((int)%s))" 
		    arg1 
		    (dhc-parse-expr-c (caddr source) 
				      (caddr :treetype:tn-list)
				      ()))))

(dhm-t mod(source)
  (when (<> 3 (length source))
	(dhc-error "wrong number of arguments"))
  (process-numerical-args-t (cdr source)))

(dhm-c mod(source treetype retplace)
       (let ((arg1 (dhc-parse-expr-c (cadr source) 
				     (cadr :treetype:tn-list) ())))
	   (sprintf "(((int)%s) %% ((int)%s))" 
		    arg1 
		    (dhc-parse-expr-c (caddr source) 
				      (caddr :treetype:tn-list)
				      ()))))

(dhm-t **(source)
  (when (<> 3 (length source)) (dhc-error "wrong number of arguments"))
  (process-numerical-args-t (cdr source)))

(dhm-c **(source treetype retplace)
  (concat "pow((double)(" (dhc-parse-expr-c (cadr source) 
					    (cadr :treetype:tn-list) ())
	  "),(double)(" (dhc-parse-expr-c (caddr source)
					  (caddr :treetype:tn-list) ())
	  "))"))

(dhm-t max(source)
  (when (<> 3 (length source)) (dhc-error "two arguments expected"))
  (dhc-parse-replacement-source-t
   source
   `(let ((a ,(cadr source)) (b ,(caddr source)))
      (if (,(if (= (get-dhm-target source) :max) '> '<) a b) a b))))

(dhm-t-declare max min)


;;; MONADIC FUNCTIONS
;;; -----------------


;; if argument is an int, but fop is defined, cast int to real and return real

(de generate-monadic (symb fop iop)
  (eval `(dhm-t ,symb (source)
           (if (<> (length source) 2)
               (dhc-error "one argument expected"))
           (let ((treetype (dhc-parse-expr-t (cadr source))))
             ,(if (and (null iop) fop)
                  '(new t-node (list treetype) (new dhc-type 'dht-real))
                '(new t-node (list treetype) :treetype:type)))))
  (eval `(dhm-c ,symb (source treetype retplace)
           (let* ((treetype (cadr :treetype:tn-list))
                  (source (cadr source))
                  (rettype :treetype:type)
                  (rez (dhc-parse-expr-c source treetype ())))
             (cond
              ((and (==> rettype is-a-flt) ,fop)
               (sprintf ,fop rez))
              ((and (==> rettype is-a-real) ,fop)
               (sprintf ,fop rez))
              ((and (==> rettype is-an-int) ,iop)
               (sprintf ,iop rez))
              ((and (==> rettype is-an-int) ,fop ,(null iop))
               (sprintf ,fop rez))
              (t (dhc-error "no function for that type")))))))

(generate-monadic 'sgn "Fsgn(%s)" "((%s<0)?-1:1)")
(generate-monadic 'abs "Fabs(%s)" "abs(%s)")
(generate-monadic 'sqrt "Fsqrt(%s)" ())
(generate-monadic '0-x-1 "Fpiece(%s)" ())
(generate-monadic '0-1-0 "Frect(%s)" ())
(generate-monadic 'sin "Fsin(%s)" ())
(generate-monadic 'cos "Fcos(%s)" ())
(generate-monadic 'tan "Ftan(%s)" ())
(generate-monadic 'asin "Fasin(%s)" ())
(generate-monadic 'acos "Facos(%s)" ())
(generate-monadic 'atan "Fatan(%s)" ())
(generate-monadic 'exp "Fexp(%s)" ())
(generate-monadic 'exp-1 "Fexpm1(%s)" ())
(generate-monadic 'log "Flog(%s)" ())
(generate-monadic 'log1+ "Flog1p(%s)" ())
(generate-monadic 'tanh "Ftanh(%s)" ())
(generate-monadic 'cosh "Fcosh(%s)" ())
(generate-monadic 'sinh "Fsinh(%s)" ())
(generate-monadic 'qtanh "FQtanh(%s)" ())
(generate-monadic 'qdtanh "FQDtanh(%s)" ())
(generate-monadic 'qstdsigmoid "FQstdsigmoid(%s)" ())
(generate-monadic 'qdstdsigmoid "FQDstdsigmoid(%s)" ())
(generate-monadic 'atanh "Fatanh(%s)" ())
(generate-monadic 'qexpmx "FQexpmx(%s)" ())
(generate-monadic 'qdexpmx "FQDexpmx(%s)" ())
(generate-monadic 'qexpmx2 "FQexpmx2(%s)" ())
(generate-monadic '1+ "(%s+1)" "(%s+1)")
(generate-monadic '1- "(%s-1)" "(%s-1)")
(generate-monadic '2/ "(%s/2)" "(%s/2)")
(generate-monadic '2* "(%s*2)" "(%s*2)")

(dhm-t seed(source)
  (if (<> (length source) 2)
      (dhc-error "one argument expected"))
  (let ((treetype (dhc-parse-expr-t (cadr source))))
    (new t-node (list treetype) (new dhc-type 'dht-real)) ))

(dhm-c seed (source treetype retplace)
  (let* ((treetype (cadr :treetype:tn-list))
         (source (cadr source))
         (rettype :treetype:type)
         (rez (dhc-parse-expr-c source treetype ())) )
    (dhc-add-c-statements
     (sprintf "Fseed(%s);" rez))
    "0"))

(dhm-t gauss(source)
  (when (> (length source) 3)
    (dhc-error "Takes zero, one, or two arguments" (car source)))
  (setq source (cdr source))
  (let ((tns (all ((arg source)) (dhc-parse-expr-t arg))))
    (each ((tn tns))
      (when ~(==> :tn:type is-a-number)
            (dhc-error "not a numerical expression")))
    (new t-node tns (new dhc-type 'dht-flt))) )

(dhm-c gauss(source treetype retplace)
  (if :treetype:ignore
      (progn (dhc-add-c-statements "Fgauss(); /* state advance */" ) "")
    (when ~retplace
      (setq retplace (dhc-declare-temp-var :treetype:type "_gauss")))
    (dhc-add-c-statements
     (sprintf "%s = %s;" retplace
              (selectq (length (cdr source))
                (0 "Fgauss()")
                (1 (sprintf "((%s) * Fgauss())"
                            (dhc-parse-expr-c (cadr source)
                                              (cadr :treetype:tn-list) ())))
                (2 (sprintf "((%s) * Fgauss() + (%s))"
                            (dhc-parse-expr-c (caddr source)
                                              (caddr :treetype:tn-list) ())
                            (dhc-parse-expr-c (cadr source)
                                              (cadr :treetype:tn-list) ())))
                )))
    retplace))

(dhm-t-declare gauss rand)

(dhm-c rand(source treetype retplace)
  ;; if ignored still do Frand() because of state machine properties
  ;;  but skip the spreading
  (if :treetype:ignore
      (progn (dhc-add-c-statements "Frand(); /* state advance */" ) "")
    (when ~retplace
      (setq retplace (dhc-declare-temp-var :treetype:type "_rand")))
    (dhc-add-c-statements
     (sprintf "%s = %s;" retplace
              (selectq (length (cdr source))
                (0 "Frand()")
                (1 (let ((a1 (dhc-parse-expr-for-multi-use-c
                              (cadr source) (cadr :treetype:tn-list) ())))
                     (sprintf "((%s) * 2 * Frand() - (%s))" a1 a1)))
                (2 (let ((a1 (dhc-parse-expr-for-multi-use-c
                              (cadr source) (cadr :treetype:tn-list) ()))
                         (rettype :treetype:type))
                     (sprintf "(((%s) - (%s)) * Frand() + (%s))"
                              (dhc-parse-expr-c (caddr source)
                                                (caddr :treetype:tn-list) ())
                              a1 a1)))
                )))
    retplace))

(dhm-t incr(source)
  (when (or (> (length source) 3) (< (length source) 2))
    (dhc-error "incr takes one or two arguments"))
  (let (((incrsymb symbo &optional incrval) source))
    (dhc-parse-replacement-source-t
     source
     (list 'setq symbo (list '+ symbo (if incrval incrval 1))))))




;;; ------------------------------------------------------------------------
;;; DHM for querying/changing dimensions on idx.
;;; ------------------------------------------------------------------------


(dhm-t idx-ndim(source)
  (when (<> 2 (length source))
    (dhc-error "one argument expected"))
  (let* ((tn (dhc-parse-expr-t (cadr source)))
         (n (==> :tn:type is-an-idxptr)))
    (if ~n
        (dhc-error "argument must be an idx")
      (new t-node (list tn) (new dhc-type 'dht-int)))))

(dhm-c idx-ndim(source treetype retplace)
  (sprintf "(%d)" (==> :(cadr :treetype:tn-list):type is-an-idxptr)))

(dhm-t idx-modulo(source)
  (when (<> 3 (length source))
    (dhc-error "two arguments expected"))
  (let* ((tn (dhc-parse-expr-t (cadr source)))
         (tn2 (dhc-parse-expr-t (caddr source)))
         (ndim (==> :tn:type is-an-idxptr)))
    (dhc-unify-types :tn2:type (new dhc-type 'dht-number))
    (if (numberp (caddr source))
        (if (or (< (caddr source) 0) (>= (caddr source) ndim))
            (dhc-error "Illegal dimension for idx") (cadr source)))
    (if ~ndim
        (dhc-error "first argument must be an idx")
      (new t-node (list tn tn2) (new dhc-type 'dht-int)))))

(dhm-c idx-modulo(source treetype retplace)
  (let ((mat (dhc-parse-expr-c (cadr source) (cadr :treetype:tn-list) ()))
        (dim (dhc-parse-expr-for-multi-use-c 
              (caddr source) (caddr :treetype:tn-list) ()))
        (ndim (==> :(cadr :treetype:tn-list):type is-an-idxptr))
        (memb (if (= (get-dhm-target source) :idx-modulo) "mod" "dim")))
    (if ~(numberp (caddr source))
      (if ~dhc-unprotect 
          (dhc-add-c-statements
           (sprintf "RTERR_DIM(%s < 0 || %s >= %d);"
                    dim dim ndim))))
    (sprintf "(%s)->%s[%s]" mat memb dim)))

(dhm-t-declare idx-modulo idx-dim)
(dhm-c-declare idx-modulo idx-dim)

(dhm-t idx-offset(source)
  (when (<> 2 (length source))
    (dhc-error "one arguments expected"))
  (let* ((tn (dhc-parse-expr-t (cadr source)))
         (ndim (==> :tn:type is-an-idxptr)))
    (if ~ndim
        (dhc-error "first argument must be an idx")
      (new t-node (list tn) (new dhc-type 'dht-int)))))

(dhm-c idx-offset(source treetype retplace)
  (let ((mat (dhc-parse-expr-c (cadr source) (cadr :treetype:tn-list)())))
    (sprintf "(%s)->offset" mat)))

(dhm-t contiguep(source)
  (when (<> 2 (length source))
    (dhc-error "one argument expected"))
  (let* ((tn (dhc-parse-expr-t (cadr source)))
         (ndim (==> :tn:type is-an-idxptr)))
    (if ~ndim
        (dhc-error "first argument must be an idx")
      (new t-node (list tn) (new dhc-type 'dht-bool)))))

(dhm-c contiguep(source treetype retplace)
  (let ((mat (dhc-parse-expr-c (cadr source) (cadr :treetype:tn-list)())))
    (if :treetype:ignore ""
      (when ~retplace
        (setq retplace (dhc-declare-temp-var :treetype:type "_contigue")))
      (dhc-add-c-statements
       (sprintf "Midx_contiguep%d(%s,%s);"
                (==> :(cadr :treetype:tn-list):type is-an-idxptr)
                mat retplace))
      retplace)))

(dhm-t idx-size(source)
  (when (<> 2 (length source))
    (dhc-error "one argument expected"))
  (let* ((tn (dhc-parse-expr-t (cadr source)))
         (ndim (==> :tn:type is-an-idxptr)))
    (if ~ndim
        (dhc-error "argument must be an idx")
      (new t-node (list tn) (new dhc-type 'dht-int)))))

(dhm-c idx-size(source treetype retplace)
  (let ((mat (dhc-parse-expr-c (cadr source) (cadr :treetype:tn-list) ()))
	     (mattype :(cadr :treetype:tn-list):type))
    (if :treetype:ignore
        ""
      (when ~retplace
        (setq retplace (dhc-declare-temp-var :treetype:type)))
      (dhc-add-c-statements
       ;; EXTRACTS ELEMENT SIZE FROM SRG
       (sprintf "(%s) = sizeof(%s);"
                retplace (==> mattype get-element-decl))
       "{int i;\n"
       (sprintf "for(i= %d-1;i>=0;i--) {\n"
                (==> mattype is-an-idxptr))
       (sprintf "(%s) *= (%s)->dim[i];\n}\n}" retplace mat))
      retplace)))

(dhm-t idx-storage(source)
  (when (<> 2 (length source))
    (dhc-error "two arguments expected"))
  (let* ((tn (dhc-parse-expr-t (cadr source)))
         (idx-type :tn:type))
    (if ~(==> idx-type is-an-idxptr)
      (dhc-error "not an idx" (cadr source)))
    (new t-node (list tn) (new dhc-type 'dht-ptr
                               (unode-val :(unode-val 
                                            :idx-type:u-type):u-type)))))

(dhm-c idx-storage(source treetype retplace)
  (let* ((mattn (cadr :treetype:tn-list))
         (mat (dhc-parse-expr-for-multi-use-c (cadr source) mattn ())))
    (sprintf "((%s)->srg)" mat)))

(dhm-t new-index(source)
  (when (<> 3 (length source))
    (dhc-error "two arguments expected"))
  (let* ((tn (dhc-parse-expr-t (cadr source)))
         (dim-list (caddr source))
         (symbol-idx (new dhc-symbol
                          (named
                           (sprintf "%d_new_idx"(dhc-postincr tmpnames-seed)))
                          lex-level))
         (ndim 0) (dim-tn ()) (rettype ()) (ret-tn ())
         (srg-type (==> :tn:type is-a-srgptr)))
    (if ~srg-type
        (dhc-error "not a storage" (cadr source)))
    (if ~(listp dim-list)
      (dhc-error "Second argument is not a list" dim-list))
    (if ~(or (= (car dim-list) 'list) (= (car dim-list) 'quote)
             ~(car dim-list))
      (dhc-error 
       "lists are not fully implemented yet.  Use (list 3 4) or '(3 4))"
       dim-list))
    (setq dim-tn
          (if (= (car dim-list) 'list)
              (let ((tnl (all ((so (cdr dim-list))) 
                           (let ((tn (dhc-parse-expr-t so)))
                             (if ~(==> :tn:type is-a-number)
                               (dhc-error "number expected" so))
                             tn))))
                (setq ndim (length (cdr dim-list)))
                (new t-node (cons (new t-node () 
                                       (new dhc-type 'dht-dhm)
                                       'list)
                                  tnl)
                     (new dhc-type 'dht-unk)))
            (let ((tnl (all ((num (cadr dim-list)))
                         (if ~(numberp num)
                           (dhc-error "number expected"
                                      num))
                         (new t-node () 
                              (new dhc-type 'dht-number)
                              num))))
              (setq ndim (length (cadr dim-list)))
              (new t-node (list (new t-node () 
                                     (new dhc-type 'dht-dhm)
                                     'quote)
                                (new t-node tnl
                                     (new dhc-type 'dht-unk)))
                   (new dhc-type 'dht-unk)))))
    (setq rettype (new dhc-type 'dht-ptr 
                       (new dhc-type 'dht-idx ndim 
                            (unode-val :tn:type:u-type))))
    (dhc-unify-types :symbol-idx:type (unode-val :rettype:u-type))
    (setq ret-tn (new t-node (list tn dim-tn) rettype))
    (setq bump-list (append bump-list (list symbol-idx)))
    (setq :ret-tn:transfer symbol-idx)
    ret-tn))

(dhm-c new-index(source treetype retplace)
  (let* ((idx-symb :treetype:transfer)
         (idx :idx-symb:c-name)
         (mattn (cadr :treetype:tn-list))
         (mat (dhc-parse-expr-for-multi-use-c (cadr source) mattn ()))
         (tn-of-list (caddr :treetype:tn-list))
         (dim-list-source (caddr source))
         (is-a-quote (= :(car :tn-of-list:tn-list):source 'quote))
         (dims-so-l (if is-a-quote (cadr dim-list-source)
                      (cdr dim-list-source)))
         (dims-type-l (if is-a-quote 
                          :(cadr :tn-of-list:tn-list):tn-list
                          (cdr :tn-of-list:tn-list)))
         (list-of-dims-expr 
          (all ((so dims-so-l) (ty dims-type-l)
                (i (if dims-so-l (range 0 (1- (length dims-so-l))))))
            (dhc-parse-expr-c so ty (sprintf "%s->dim[%d]" idx i)))))
    (dhc-add-c-statements (sprintf "%s->srg = %s;" idx mat))
    (dhc-add-c-statements (sprintf "%s->ndim = %d;" idx 
                                   (==> :treetype:type is-an-idxptr)))
    (dhc-add-c-statements (sprintf "%s->flags = 0;" idx))
    (dhc-add-c-statements (sprintf "%s->offset = 0;" idx))
    (dhc-add-c-statements (sprintf "Midx_update_mod_from_dim(%s);" idx))
    idx))

(dhm-t idx-changedim(source)
  (when (<> (if (= (get-dhm-target source) :idx-changeoffset) 3 4) (length source))
    (dhc-error "three arguments expected"))
  (let* ((tnl (all ((so (cdr source))) (dhc-parse-expr-t so)))
         (ndim (==> :(car tnl):type is-an-idxptr))
         (tn ()))
    (if (<> (get-dhm-target source) :idx-changeoffset)
        (if (numberp (caddr source))
            (if (or (< (caddr source) 0) (>= (caddr source) ndim))
                (dhc-error "illegal dimension for idx") (cadr source))))
    (when ~ndim (dhc-error "first argument must be an idx"))
    (all ((tn (cdr tnl)))
      (dhc-unify-types :tn:type (new dhc-type 'dht_number)))
    (new t-node tnl (new dhc-type 'dht-nil))))


(putp idx-changedim 'cname "changedim")
(putp idx-changemod 'cname "changemod")
(putp idx-changeoffset 'cname "changeoffset")


(dhm-c idx-changedim(source treetype retplace)
  (let* ((mattn (cadr :treetype:tn-list))
         (lname (get-dhm-target source))
         (mat (dhc-parse-expr-for-multi-use-c (cadr source) mattn ()))
         (cname (or (getp (get-dhm-target source) 'cname)
                    (dhc-error "Cannot compile this function (no cname)") ) )
         (faccess (concat "Midx_" cname (sprintf "(%s" mat)))
         (cnames (all ((so (cddr source)) (tn (cddr :treetype:tn-list)))
                   (concat "((int)"
                           (dhc-parse-expr-for-multi-use-c so tn ())
                           ")")))
         (ndim (==> :mattn:type is-an-idxptr))
         (el-decl (==> :mattn:type get-element-decl)) )
    (if (<> lname :idx-changeoffset)
        (setq faccess (concat faccess "," (car cnames) ")"))
      (setq faccess (concat faccess ")")))
    (if dhc-unprotect
        (dhc-add-c-statements (concat faccess " = " (last cnames) ";"))
      (if (<> (get-dhm-target source) :idx-changeoffset)
          (if ~(numberp (caddr source))
            (dhc-add-c-statements
             (sprintf "RTERR_DIM(%s < 0 || %s >= %d);"
                      (car cnames) (car cnames) ndim))))
      (dhc-add-c-statements 
       (sprintf "{ int old_val=%s, min_size, max_size;" faccess)
       (if (= (get-dhm-target source) :idx-changedim)
           (sprintf "RTERR_RANGE(%s < 0);" (cadr cnames)))
       (concat faccess " = " (last cnames) ";")
       (sprintf "SRG_BOUNDS(%s,%d,min_size, max_size);" mat ndim)
       (sprintf "if(min_size < 0 || max_size >= (%s)->srg->size) {" mat)
       (concat faccess "= old_val;")
       "RTERR_SRG_OVERFLOW;}}"))
    "0"))

(dhm-t-declare idx-changedim idx-changemod idx-changeoffset)
(dhm-c-declare idx-changedim idx-changemod idx-changeoffset)



;;; ------------------------------------------------------------------------
;;; DHM for matrix creation and cloning functions
;;; ------------------------------------------------------------------------

(defvar dhc-type-to-matrix-name 
  '((dht-ubyte ubyte-matrix-nc ubyte-matrix)
    (dht-byte byte-matrix-nc byte-matrix)
    (dht-int int-matrix-nc int-matrix)
    (dht-short short-matrix-nc short-matrix)
    (dht-flt float-matrix-nc float-matrix)
    (dht-real double-matrix-nc double-matrix)
    (dht-gptr gptr-matrix-nc gptr-matrix) ) )

(defvar dhc-type-to-matrix 
  (mapcar (lambda ((x y z)) (cons x (eval `(list :,y :,z))))
          dhc-type-to-matrix-name ) )
(defvar dhc-matrix-to-type
  (apply append
         (mapcar (lambda ((x y z)) (eval `(list (cons :,y x) (cons :,z x))))
                 dhc-type-to-matrix-name ) ) )

(dhm-t float-matrix-nc(source)
  (let* ((arglist (cdr source))
         (types (all ((x arglist)) (dhc-parse-expr-t x)))
         (mtype (cdr (assoc (get-dhm-target source) dhc-matrix-to-type)))
         (srg-type (new dhc-type 'dht-srg (new dhc-type mtype)))
         (idx-type (new dhc-type 'dht-idx (length arglist) srg-type))
         (rettype (new dhc-type 'dht-ptr idx-type))
         (symbol-idx (new dhc-symbol (named (sprintf "%d_matrix" 
                                                     tmpnames-seed))
                          lex-level))
         (symbol-srg (new dhc-symbol (named (sprintf "%d_srg" 
                                                     tmpnames-seed))
                          lex-level))
         (tn (new t-node types rettype ())))
    (incr tmpnames-seed)
    (each ((y types) (x arglist))
      (if (not (==> :y:type is-a-number)) 
          (dhc-error "not a numerical expression" x)))
    (dhc-unify-types :symbol-idx:type idx-type)
    (dhc-unify-types :symbol-srg:type srg-type)
    (setq bump-list (append bump-list (list symbol-idx symbol-srg)))
    (setq :tn:transfer (list symbol-idx symbol-srg))
    tn))

(dhm-t-declare float-matrix-nc ubyte-matrix-nc byte-matrix-nc short-matrix-nc 
	       int-matrix-nc double-matrix-nc gptr-matrix-nc
	       ubyte-matrix byte-matrix short-matrix int-matrix 
               float-matrix double-matrix gptr-matrix )

(dhm-c float-matrix-nc(source treetype retplace)
  (let (((idx-symb srg-symb) :treetype:transfer)
        (ndim (1- (length source)))
        (srg-type (unode-val :(unode-val 
                               :(unode-val 
                                 (scope :treetype:type
                                        u-type)):u-type):u-type)))
    (dhc-add-c-statements (sprintf "(%s)->srg = %s;"
                                   :idx-symb:c-name :srg-symb:c-name))
    (if (= 0 ndim)
        (dhc-add-c-statements (sprintf "Midx_init_dim%d(%s);"
                                       ndim
                                       :idx-symb:c-name))
      (dhc-add-c-statements (sprintf "Midx_init_dim%d(%s, %s);"
                                     ndim
                                     :idx-symb:c-name
                                     (dhc-insert-op 
                                      (all ((so (cdr source)) 
                                            (ty (cdr :treetype:tn-list))
                                            (i (range 0 (1- ndim))))
                                        (dhc-parse-expr-c so ty ()))
                                      ","))))
    (if (member (get-dhm-target source)
                (list ubyte-matrix byte-matrix short-matrix int-matrix 
                      float-matrix double-matrix gptr-matrix ) )
        (dhc-add-c-statements (sprintf "Midx_maclear(%s, %s);"
                                       :idx-symb:c-name
                                       (dhc-type-to-c-decl srg-type))))
    (sprintf "%s" :idx-symb:c-name)))

(dhm-c-declare float-matrix-nc ubyte-matrix-nc byte-matrix-nc short-matrix-nc 
	       int-matrix-nc double-matrix-nc gptr-matrix-nc
	       ubyte-matrix byte-matrix short-matrix int-matrix 
               float-matrix double-matrix gptr-matrix )

(dhm-t idx-clone(source)
  (when (<> 2 (length source))
    (dhc-error "one argument expected"))
  (let* ((tnl (all ((so (cdr source))) (dhc-parse-expr-t so)))
         (ndim (==> :(car tnl):type is-an-idxptr))
         (rettype (==> :(car tnl):type copy))
         (symbol-idx (new dhc-symbol
                          (named
                           (sprintf "%d_clone" (dhc-postincr tmpnames-seed)))
                          lex-level))
         (tn (new t-node tnl rettype)))
    (when ~ndim (dhc-error "argument must be an idx"))
    (dhc-unify-types :symbol-idx:type (unode-val :rettype:u-type))
    ;; cause the storage to be bumped if idx is returned
    (dhc-unify-types (unode-val :(unode-val 
                                  :(car tnl):type:u-type):u-type)
                     (unode-val :(unode-val :rettype:u-type):u-type))
    (setq bump-list (append bump-list (list symbol-idx)))
    (setq :tn:transfer symbol-idx)
    tn))

(dhm-c idx-clone(source treetype retplace)
  (let* ((idx-symb :treetype:transfer)
         (mattn (cadr :treetype:tn-list))
         (mat (dhc-parse-expr-for-multi-use-c (cadr source) mattn ())))
    (dhc-add-c-statements
     (sprintf "Midx_clone%d(%s, %s);"
              (dhu-ndim (dhu-type :mattn:type))
              :idx-symb:c-name mat))
    :idx-symb:c-name))

(dhm-t clone-matrix(source)
  (when (<> 2 (length source))
    (dhc-error "one argument expected"))
  (let* ((mat (dhc-parse-expr-t (cadr source)))
         (ndims (==> :mat:type is-an-idxptr))
         (newsrc (mapfor (i 0 (1- ndims))
                   (list 'idx-dim (cadr source) i))))
    (when ~(==> :mat:type is-an-idxptr)
          (dhc-error "argument must be an idx"))
    (setq newsrc (cons (cadr (assoc (==> :mat:type get-element-type)
                                    dhc-type-to-matrix-name))
                       newsrc))
    (dhc-parse-replacement-source-t source newsrc)))

(dhm-t copy-matrix(source)
  (let (((func mat &optional to-mat more) source))
    (if more
        (dhc-error "one or two arguments expected")
      (if (not to-mat)
          (dhc-parse-replacement-source-t 
           source `(let ((m ,mat)) (copy-matrix m (clone-matrix m))) )
        (let ((tn-in (dhc-parse-expr-t mat))
              (tn-out (dhc-parse-expr-t to-mat)))
          (when (not (==> :tn-in:type is-an-idxptr))
            (dhc-error "Not a matrix" mat) )
          (when (not (==> :tn-out:type is-an-idxptr))
            (dhc-error "Not a matrix" to-mat) )
          (==> (unode-val :(unode-val :tn-out:type:u-type):u-type)
               access 'write)
          (new t-node (list tn-in tn-out) :tn-out:type () ()) ) ) ) ) )

(dhm-c copy-matrix(source treetype retplace)
  (let* ((idx-type-in :(cadr :treetype:tn-list):type)
         (idx-type-out :(caddr :treetype:tn-list):type)
         (srg-type-in (new dhc-type (==> idx-type-in get-element-type)))
         (srg-type-out (new dhc-type (==> idx-type-out get-element-type)))
         (c1 (dhc-parse-expr-c (cadr source)(cadr :treetype:tn-list)()))
         (ret-string (dhc-parse-expr-c (last source)
                                       (last :treetype:tn-list)
                                       ())))
    (if ~dhc-unprotect
        (dhc-add-c-statements
         (sprintf "check_main_maout(%s,%s);" c1 ret-string)))
    (dhc-add-c-statements
     (sprintf "Midx_macopy(%s,%s,%s,%s);"
              c1 ret-string
              (dhc-type-to-c-decl srg-type-in)
              (dhc-type-to-c-decl srg-type-out)))
    ret-string ) )



;;; ------------------------------------------------------------------------
;;; DHM for index manipulations (unfold, select, narrow, etc...)
;;; ------------------------------------------------------------------------


;;; WEIRD: We have UNFOLD but not IDX-UNFOLD!
(dhm-t unfold(source)
  (when (<> 5 (length source))
    (dhc-error "four arguments expected"))
  (let* ((tnl (all ((so (cdr source))) (dhc-parse-expr-t so)))
         (ndim (==> :(car tnl):type is-an-idxptr))
         (rettype (==> :(car tnl):type copy 1))
         (symbol-idx (new dhc-symbol
                          (named
                           (sprintf "%d_unfold" (dhc-postincr tmpnames-seed)))
                          lex-level))
         (tn (new t-node tnl rettype)) )
    (when ~ndim (dhc-error "first argument must be an idx"))
    (when (numberp (caddr source))
      (if (or (< (caddr source) 0) (>= (caddr source) ndim))
          (dhc-error "Illegal dimension for idx") (cadr source))
      (if (>= (1+ (caddr source)) 8)
          (dhc-error "Too many dimensions") (cadr source)))
    (if (and (numberp (nth 3 source)) (numberp (nth 4 source)))
        (if (or (< (nth 3 source) 1) (< (nth 4 source) 1))
            (dhc-error "Illegal dimension ksize or step"
                       (cdddr source))))
    (all ((tn (cdr tnl)))
      (dhc-unify-types :tn:type (new dhc-type 'dht_number)))
    (dhc-unify-types :symbol-idx:type (unode-val :rettype:u-type))
    (setq bump-list (append bump-list (list symbol-idx)))
    (dhc-unify-types (unode-val :symbol-idx:type:u-type)
                     (unode-val :(unode-val 
                                  :(car tnl):type:u-type):u-type))
    (setq :tn:transfer symbol-idx)
    tn))

(dhm-c unfold(source treetype retplace)
  (let* ((idx-symb :treetype:transfer)
         (mattn (cadr :treetype:tn-list))
         (cnames (all ((so (cdr source)) (tn (cdr :treetype:tn-list)))
                   (dhc-parse-expr-for-multi-use-c so tn ())))
         (idx :idx-symb:c-name)
         (mat (nth 0 cnames))
         (d (concat "((int)" (nth 1 cnames) ")"))
         (sz (concat "((int)" (nth 2 cnames) ")"))
         (st (concat "((int)" (nth 3 cnames) ")"))
         (ndim (==> :mattn:type is-an-idxptr))
         (el-decl (==> :mattn:type get-element-decl))
         (temp (dhc-declare-temp-var (new dhc-type 'dht_int))) )
    (dhc-add-c-statements
     (sprintf "Midx_clone%d(%s, %s);"
              (dhu-ndim (dhu-type :mattn:type))
              idx mat))
    (when ~dhc-unprotect
      (if ~(numberp (caddr source))
        (dhc-add-c-statements
         (sprintf "RTERR_DIM(%s < 0 || %s >= %d);"
                  d d ndim)))
      (if (or ~(numberp (nth 3 source)) 
              ~(numberp (nth 4 source)))
          (dhc-add-c-statements
           (sprintf "RTERR_GEN((%s<1 || %s<1), %s);"
                    sz st
                    "\"illegal 'size' or 'step'\""))))
    (dhc-add-c-statements
     (sprintf "%s = 1+ ((%s)->dim[%s]-%s)/%s;"
              temp idx d sz st))
    (when ~dhc-unprotect
      (dhc-add-c-statements
       (sprintf 
        "RTERR_GEN((%s<=0 || (%s)->dim[%s]!=%s*(%s-1)+%s), %s);"
        temp idx d st temp sz
        "\"Index dimension does not match size and step\""))
      (if ~(numberp (caddr source))
        (dhc-add-c-statements
         (sprintf "RTERR_GEN((%d +1 >= MAXDIMS), %s);"
                  ndim
                  "\"Too many dimensions\""))))
    (dhc-add-c-statements
     (sprintf "Midx_unfold(%s,%s,%s,%s,%s);"
              idx d sz st el-decl))
    idx))

;;; WEIRD: We have SELECT but not IDX-SELECT!
(dhm-t select(source)
  (when (<> 4 (length source))
    (dhc-error "three arguments expected"))
       (let* ((tnl (all ((so (cdr source))) (dhc-parse-expr-t so)))
	      (ndim (==> :(car tnl):type is-an-idxptr))
	      (rettype (==> :(car tnl):type copy -1))
	      (symbol-idx (new dhc-symbol
			       (named
				(sprintf "%d_select" (dhc-postincr tmpnames-seed)))
			       lex-level))
	      (tn (new t-node tnl rettype)) )
         (when ~ndim (dhc-error "first argument must be an idx"))
         (when (numberp (caddr source))
           (if (or (< (caddr source) 0) (>= (caddr source) ndim))
               (dhc-error "Illegal dimension for idx") (cadr source)))
         (if (numberp (nth 3 source))
             (if (< (nth 3 source) 0)
                 (dhc-error "Illigal dimension selection") (cadr source)))
         (all ((tn (cdr tnl)))
           (dhc-unify-types :tn:type (new dhc-type 'dht_number)))
         (dhc-unify-types :symbol-idx:type (unode-val :rettype:u-type))
         (setq bump-list (append bump-list (list symbol-idx)))
         (dhc-unify-types (unode-val :symbol-idx:type:u-type)
                          (unode-val :(unode-val 
                                       :(car tnl):type:u-type):u-type))
         (setq :tn:transfer symbol-idx)
         tn))

(dhm-c select(source treetype retplace)
  (let* ((idx-symb :treetype:transfer)
         (mattn (cadr :treetype:tn-list))
         (cnames (all ((so (cdr source)) (tn (cdr :treetype:tn-list)))
                   (dhc-parse-expr-for-multi-use-c so tn ())))
         (idx :idx-symb:c-name)
         (mat (nth 0 cnames))
         (d (concat "((int)" (nth 1 cnames) ")"))
         (x (concat "((int)" (nth 2 cnames) ")"))
         (ndim (==> :mattn:type is-an-idxptr))
         (el-decl (==> :mattn:type get-element-decl)) )
    (when ~dhc-unprotect
      (if ~(numberp (caddr source))
        (dhc-add-c-statements
         (sprintf "RTERR_DIM(%s < 0 || %s >= %d);"
                  d d ndim)))
      (if ~(numberp (nth 3 source))
        (dhc-add-c-statements
         (sprintf "RTERR_GEN((%s<0), %s);"
                  x
                  "\"illegal parameter\"")))
      (dhc-add-c-statements
       (sprintf "RTERR_GEN((%s >= (%s)->dim[%s]), %s);"
                x mat d
                "\"specified subscript is too large\"")))
    (dhc-add-c-statements
     (sprintf "Midx_select(%s,%s,%s,%s,%s);"
              idx mat d x el-decl))
    idx))

;; WEIRD: We have DIAGONAL but not IDX-DIAGONAL!
(dhm-t diagonal(source)
  (when (<> 3 (length source))
    (dhc-error "two arguments expected"))
  (let* ((tnl (all ((so (cdr source))) (dhc-parse-expr-t so)))
         (ndim (==> :(car tnl):type is-an-idxptr))
         (targ ())
         (rettype ())
         (symbol-idx (new dhc-symbol
                          (named
                           (sprintf "%d_diag" (dhc-postincr tmpnames-seed)))
                          lex-level))
         (tn ()) )
    (when ~ndim (dhc-error "first argument must be an idx"))
    (when (or ~(numberp (caddr source))
              (< (caddr source) 2)
              (> (caddr source) ndim))
      (dhc-error "2nd arg must be a compile time constant integer 2 <= d <= ndim"))
    (dhc-unify-types :(cadr tnl):type (new dhc-type 'dht_number))
    ;; creates a matrix with "d-1 dims less than the original"
    (setq targ (- ndim (1- (caddr source))))
    (setq rettype (==> :(car tnl):type copy (- targ ndim)))
    (setq tn (new t-node tnl rettype))
    (dhc-unify-types :symbol-idx:type (unode-val :rettype:u-type))
    (setq bump-list (append bump-list (list symbol-idx)))
    (dhc-unify-types (unode-val :symbol-idx:type:u-type)
                     (unode-val :(unode-val 
                                  :(car tnl):type:u-type):u-type))
    (setq :tn:transfer symbol-idx)
    tn))

(dhm-c diagonal(source treetype retplace)
  (let* ((idx-symb :treetype:transfer)
         (mattn (cadr :treetype:tn-list))
         (cnames (all ((so (cdr source)) (tn (cdr :treetype:tn-list)))
                   (dhc-parse-expr-for-multi-use-c so tn ())))
         (idx :idx-symb:c-name)
         (mat (nth 0 cnames))
         (d (nth 1 cnames))
         (ndim (==> :mattn:type is-an-idxptr))
         (el-decl (==> :mattn:type get-element-decl)) )
    (dhc-add-c-statements
     (sprintf "Midx_clone%d(%s, %s);"
              (dhu-ndim (dhu-type :mattn:type))
              idx mat))
    (dhc-add-c-statements
     (concat
      (sprintf "{ int i,m,n; m = %d - %s; n = (%s)->dim[m];"
               ndim d idx)
      (sprintf " for (i=1;i<(int)%s;i++)" d)
      (if ~dhc-unprotect
          (sprintf "   RTERR_GEN(((%s)->dim[m+i] != n), %s);" idx
                   "\"The last dimensions should have the same size\"")
        "")
      "}"))
    (dhc-add-c-statements
     (sprintf "Midx_diagonal(%s,(int)%s,%s);"
              idx d el-decl))
    idx))

;; We have IDX-NARROW and NARROW is a macro.
(dhm-t idx-narrow(source)
  (when (<> 5 (length source))
    (dhc-error "four arguments expected"))
  (let* ((tnl (all ((so (cdr source)))
                (dhc-parse-expr-t so)))
         (ndim (==> :(car tnl):type is-an-idxptr))
         (tn :(car tnl):type) )
    (if ~ndim
        (dhc-error "first argument must be an idx"))
    (when (numberp (caddr source))
      (if (or (< (caddr source) 0) (>= (caddr source) ndim))
          (dhc-error "Illegal dimension for idx") (cadr source)))
    (if (and (numberp (nth 3 source)) (numberp (nth 4 source)))
        (if (or (< (nth 3 source) 1) (< (nth 4 source) 0))
            (dhc-error "Illegal dimension size or offset"
                       (cdddr source))))
    (all ((tn (cdr tnl)))
      (dhc-unify-types :tn:type (new dhc-type 'dht_number)))
    (new t-node tnl (new dhc-type 'dht-bool))))

(dhm-c idx-narrow(source treetype retplace)
  (let* ((idxtn (cadr :treetype:tn-list))
         (cnames (all ((so (cdr source)) (tn (cdr :treetype:tn-list)))
                   (dhc-parse-expr-for-multi-use-c so tn ())))
         (mat (nth 0 cnames))
         (d (concat "((int)" (nth 1 cnames) ")")) 
         (sz (concat "((int)" (nth 2 cnames) ")"))
         (st (concat "((int)" (nth 3 cnames) ")"))
         (ndim (==> :idxtn:type is-an-idxptr))
         (el-decl (==> :idxtn:type get-element-decl)) )
    (when ~dhc-unprotect
      (if ~(numberp (caddr source))
        (dhc-add-c-statements
         (sprintf "RTERR_DIM(%s < 0 || %s >= %d);"
                  d d ndim)))
      (if (or ~(numberp (nth 3 source)) ~(numberp (nth 4 source)))
          (dhc-add-c-statements
           (sprintf "RTERR_GEN((%s<1 || %s<0), %s);"
                    sz st
                    "\"illegal 'size' or 'offset'\"")))
      (dhc-add-c-statements
       (sprintf "RTERR_GEN((%s+%s > (%s)->dim[%s]), %s);"
                st sz mat d
                "\"specified interval is too large\"")))
    (dhc-add-c-statements
     (sprintf "Midx_narrow(%s,%s,%s,%s,%s);"
              mat d sz st el-decl))
    "0"))

;; handles quoted list for idx-transclone
;;   (idx-transclone a '(1 2 3 0))
;;   could be expanded to handle (idx-transclone a (list 1 2 3 0))
;;   but would need runtime permtable check
(de dhc-parse-permlist-t (source ndim)
  (let ((x (car source))
        (lst (cdr source))
        (tnl ())
        (tn ())
        (tn2 ())
        (got-these (matrix ndim)) )
    (when (or ~(consp source) (<> x 'quote))
      (dhc-error "permutation list syntax error" source))
    (when (or (<> 1 (length lst)) ~(consp (car lst)))
      (dhc-error "permutation list syntax error" source))
    (setq lst (car lst))
    (when (<> ndim (length lst))
      (dhc-error "wrong # of dims in permlist" lst))
    (setq tnl (all ((so lst))
                (when (or ~(numberp so)
                          (<> so (int so))
                          (< so 0) (>= so ndim)
                          (0<> (got-these so)))
                  (dhc-error "bad permutation list" lst))
                (got-these so 1)
                (dhc-parse-number-t so)))
    (setq tn (new t-node tnl (new dhc-type 'dht-dhm) lst))
    (setq :tn:tn-list tnl)
    (setq tnl (list tn))
    (setq tn2 (new t-node tnl (new dhc-type 'dht-dhm) source))
    tn2))

(de dhc-parse-permlist-c (source treetype rettype)
  (let ((plist (all ((so (cadr source)) (ty :(car :treetype:tn-list):tn-list))
                 (dhc-parse-expr-for-multi-use-c so ty ()))))
    (dhc-add-c-statements
     "static int permlist[] = {"
     (dhc-insert-op plist ", ")
     "};")
    "permlist"))

(dhm-t idx-transclone(source)
  (when (<> 3 (length source))
    (dhc-error "two arguments expected"))
  (let* ((mat (dhc-parse-expr-t (cadr source)))
         (ndim (==> :mat:type is-an-idxptr))
         (bogus (when ~ndim (dhc-error "first argument must be an idx")))
         (tnl (list mat
                    (dhc-parse-permlist-t (caddr source) ndim)))
         (rettype (==> :(car tnl):type copy))
         (symbol-idx (new dhc-symbol
                          (named
                           (sprintf "%d_tclone" (dhc-postincr tmpnames-seed)))
                          lex-level))
         (tn (new t-node tnl rettype)))
    (dhc-unify-types :symbol-idx:type (unode-val :rettype:u-type))
    ;; cause the storage to be bumped if idx is returned
    (dhc-unify-types (unode-val :(unode-val :(car tnl):type:u-type):u-type)
                     (unode-val :(unode-val :rettype:u-type):u-type))
    (setq bump-list (append bump-list (list symbol-idx)))
    (setq :tn:transfer symbol-idx)
    tn))

(dhm-c idx-transclone(source treetype retplace)
  (let* ((idx-symb :treetype:transfer)
         (mattn (cadr :treetype:tn-list))
         (mat (dhc-parse-expr-for-multi-use-c (cadr source) mattn ()))
         (plist ()))
    (dhc-add-c-statements "{")
    (setq plist (dhc-parse-permlist-c (caddr source)
                                      (caddr :treetype:tn-list) ()))
    (dhc-add-c-statements
     (sprintf "Midx_transclone(%s, %s, %s, %s);"
              :idx-symb:c-name mat plist
              (==> :mattn:type get-element-decl))
     "}")
    :idx-symb:c-name))

;; Same as SUB-INDEX !
(dhm-t submatrix(source)
  (let (((func mat . dims) source)
        (expr ())
        (cur ())
        (taken-dim 0))
    (setq expr mat)
    (for (i 0 (1- (length dims)))
         (setq cur (nth i dims))
         (cond ((null cur))
               ((and (listp cur) (= (car cur) 'list) (= (length cur) 3))
                (setq expr `(narrow 
                             ,expr ,(- i taken-dim) 
                             (1+ (- ,(caddr cur)
                                    ,(cadr cur)))
                             ,(cadr cur)) ))
               ((and (listp cur) (= (car cur) 'quote))
                (setq cur (cadr cur))
                (if (not (and (numberp (car cur)) (numberp (cadr cur))
                              (null (cddr cur))))
                    (dhc-error "submatrix: bad argument" cur))
                (setq expr `(narrow 
                             ,expr ,(- i taken-dim) 
                             (1+ (- ,(cadr cur) ,(car cur)))
                             ,(car cur))))
               (t
                (setq expr (list 'select expr
                                 (- i taken-dim) cur))
                (incr taken-dim))))
    (dhc-parse-replacement-source-t source expr) ) )





;;; ------------------------------------------------------------------------
;;; DHM FOR PARSING IDX LOOPS
;;; ------------------------------------------------------------------------

(de dhc-idxloop-declare-var-t(dcl)
  (when ~(and (consp dcl) (consp (cdr dcl)) (null (cddr dcl)))
        (dhc-error "Syntax error" dcl) )
  (when ~(symbolp (car dcl))
        (dhc-error "Not a symbol" (car dcl)))
  (let* ((sym (new dhc-symbol (car dcl) lex-level))
         (ini (cadr dcl))
         (node (dhc-parse-expr-t ini))
         (ndim (==> :node:type is-an-idxptr)))
    (when ~ndim
      (dhc-error (sprintf "Not an index: %l" ini)))
    (when (= 0 ndim)
      (dhc-error "Can't loop over a 0D matrix."))
    (let* ((ptr-type (==> :node:type copy -1))
           (treetype (new t-node
                          (list (new t-node () :sym:type (car dcl) sym)
                                node)
                          (new dhc-type 'dht-unk))))
      (dhc-assign-unify :sym:type ptr-type)
      ;; loop var is not returnable!
      ;; (setq bump-list (append bump-list (list sym)))
      (setq :treetype:ignore t)
      (setq new-symbol-table 
            (dhc-add-to-symtable new-symbol-table sym))
      treetype)))

(dhm-t idx-bloop(source)
  (when ~(cddr source)
        (dhc-error "idx-[be]loop syntax error"))
  (when (> (length (cadr source)) 12)
    (dhc-error "Cannot loop on more than 12 indexes"))
  (let ((li ())
        (tn ())
        (ret ())
        (ignore t)					;; changed-returning 0
        (tmp ()))
    (dhc-push-scope-t
     (setq li (all ((dcl (cadr source)))
                (dhc-idxloop-declare-var-t dcl)))
     (setq symbol-table new-symbol-table)
     (setq tn (new t-node li (new dhc-type 'dht-unk)))
     (setq ret (dhc-parse-progn-t (cddr source)))
     (setq :ret:tn-list (cons tn :ret:tn-list))
     (setq :ret:type :(cadr :(last li):tn-list):type)
     ret)))

;; lays down a run-time check that the dim dimensions of
;; the elements in tnlist are equal
;; if dim < 0, take it as a delta from ndim
(de dhc-rt-dim-check (namelist tnlist dim)
  (when (> (length tnlist) 1)
    (let* ((arglist ())
           (getdim (lambda (ty d)
                     (if (>= d 0) d (+ (==> ty is-an-idxptr) d))))
           (arg1str (sprintf "(%s)->dim[%d]"
                             (car namelist)
                             (getdim :(car tnlist):type dim) ))
           (arglist (all ((tn (cdr tnlist)) (nm (cdr namelist)))
                      (sprintf "%s != (%s)->dim[%d]"
                               arg1str nm
                               (getdim :tn:type dim)))) )
      (setq arglist (dhc-insert-op arglist " || "))
      (if ~dhc-unprotect
          (dhc-add-c-statements (sprintf "RTERR_LOOPDIM(%s);" arglist))) )))

(dhm-c idx-bloop(source treetype retplace)
  (let ((arglist "")
        (el-types ())
        (ini-names ())
        (ini-tnl ())
        (ret-expr ())
        (str (if  (= (get-dhm-target source) :idx-bloop) "b" "e"))
        (check-dim (if (= str "b") 0 -1)) )
    (dhc-push-scope-c
     treetype retplace
     (each ((decl (cadr source))
            (decltype :(cadr :treetype:tn-list):tn-list))
       (let* ((sym-tn (car :decltype:tn-list))
              (ini-tn (cadr :decltype:tn-list))
              (sym :(car :decltype:tn-list):symbol )
              (ini (dhc-parse-expr-for-multi-use-c
                    (cadr decl) ini-tn ())))
         (setq arglist (concat arglist :sym:c-name ", " ini ","))
         ;; HACK for bloop speed up -- see idxmac.h
         (setq :sym:c-name (concat "&" :sym:c-name))
         ;; collect element types
         (setq el-types (cons (==> :sym-tn:type get-element-type) el-types))
         ;; collect ini names an types for rt dim check
         (setq ini-names (cons ini ini-names))
         (setq ini-tnl (cons ini-tn ini-tnl))
         (setq ret-expr ini)))
     ;; rt check of loop dims 
     (dhc-rt-dim-check ini-names ini-tnl check-dim)
     ;; extracts element size from srg!
     (setq arglist (concat arglist (dhc-type-to-c-decl
                                    (new dhc-type (car el-types)))))
     (dhc-add-c-statements
      (sprintf "Midx_begin_%sloop%d(%s)"
               str
               (length (cadr source)) arglist))
     (dhc-parse-progn-c (cddr source)
                        (cddr :treetype:tn-list) ())
     (dhc-add-c-statements
      (sprintf "Midx_end_%sloop%d(%s);"
               str
               (length (cadr source)) arglist))
     ret-expr)))

(dhm-t-declare idx-bloop idx-eloop)
(dhm-c-declare idx-bloop idx-eloop)




;;; ------------------------------------------------------------------------
;;; DHM for parsing TL3/SN2 matrix operations
;;; ------------------------------------------------------------------------

;;; These are defined in compat.lsh

(when (functionp m*m)
  (dhm-t m*m(source)
    (let (((func a b &optional c) source)
          (atype ())
          (btype ())
          (ndima ())
          (ndimb ())
          (expr ()))
      (setq atype :(dhc-parse-expr-t a):type)
      (setq btype :(dhc-parse-expr-t b):type)
      (setq ndima (==> atype is-an-idxptr))
      (setq ndimb (==> btype is-an-idxptr))
      (if (and (<> ndima 1) (<> ndima 2))
          (dhc-error "m*m: idx must be of dimension 1 or 2" a))
      (if (and (<> ndimb 1) (<> ndimb 2))
          (dhc-error "m*m: idx must be of dimension 1 or 2" b))
      (setq expr 
            (if (= ndima 1)
                (if (= ndimb 1)
                    (if (= 1 (car :btype:u-extra))
                        (if c 
                            (if (symbolp c)
                                `(let ((-dh-b (matrix-nc)))
                                   (idx-dotm0 ,a (-dh-b (,b 0)) ,c)
                                   ,c)
                              `(let ((-dh-b (matrix-nc))
                                     (-dh-c ,c))
                                 (idx-dotm0 ,a (-dh-b (,b 0)) -dh-c)
                                 -dh-c))
                          `(let* ((-dh-b (matrix-nc))
                                  (-dh-a ,a)
                                  (-dh-c (clone-matrix -dh-a)))
                             (idx-dotm0 -dh-a (-dh-b (,b 0)) -dh-c)
                             -dh-c))
                      (dhc-error "m*m: idx 2 must have 1 element"))
                  (if (= 1 (car :btype:u-extra))
                      (if c
                          (if (symbolp c)
                              `(progn (idx-extm1 ,a (select ,b 0 0) ,c) ,c)
                            `(let ((-dh-c ,c))
                               (idx-m1extm1 ,a (select ,b 0 0) -dh-c)
                               -dh-c))
                        `(let ((-dh-c (matrix-nc ,(car :atype:u-extra)
                                                 ,(cadr :btype:u-extra))))
                           (idx-m1extm1 ,a (select ,b 0 0) -dh-c)
                           -dh-c))
                    (dhc-error "m*m: idx 2 have bad dimensions")))
              (if (= 1 ndimb)
                  (if c
                      (if (symbolp c)
                          `(progn (idx-m2dotm1 ,a ,b ,c) ,c)
                        `(let ((-dh-c ,c)) (idx-m2dotm1 ,a ,b -dh-c) -dh-c))
                    `(let* ((-dh-a ,a)
                            (-dh-c (matrix-nc (idx-dim -dh-a 0))))
                       (idx-m2dotm1 -dh-a ,b -dh-c) -dh-c))
                (if c
                    (if (symbolp c)
                        `(progn (idx-eloop ((-dh-x ,b) (-dh-y ,c))
                                  (idx-m2dotm1 ,a -dh-x -dh-y))
                                ,c)
                      `(let ((-dh-c ,c))
                         (idx-eloop ((-dh-x ,b) (-dh-y -dh-c)) 
                           (idx-m2dotm1 ,a -dh-x -dh-y))
                         -dh-c))
                  `(let* ((-dh-a ,a)
                          (-dh-b ,b)
                          (-dh-c (matrix-nc (idx-dim -dh-a 0) (idx-dim -dh-b 1))))
                     (idx-eloop ((-dh-x -dh-b) (-dh-y -dh-c)) 
                       (idx-m2dotm1 -dh-a -dh-x -dh-y))
                     -dh-c)))))
      (dhc-parse-replacement-source-t source expr) ) ) )

(when (functionp m+m)
  (dhm-t m+m(source)
    (let (((func a b &optional c) source))
      (dhc-parse-replacement-source-t
       source
       (if c
           (if (symbolp c)
               `(progn (idx-add ,a ,b ,c) ,c)
             `(let ((-dh-c ,c))
                (progn (idx-add ,a ,b -dh-c) -dh-c)))
         (if (symbolp b)
             `(let ((-dh-c (clone-matrix ,b)))
                (idx-add ,a ,b -dh-c) -dh-c)
           (if (symbolp a)
               `(let ((-dh-c (clone-matrix ,a)))
                  (idx-add ,a ,b -dh-c) -dh-c)
             `(let* ((-dh-b ,b)
                     (-dh-c (clone-matrix -dh-b)))
                (idx-add ,a -dh-b -dh-c) -dh-c))))) ) ) )

(when (functionp mxm)
  (dhm-t mxm(source)
    (let (((func a b &optional c) source))
      (dhc-parse-replacement-source-t
       source
       (if c
           (if (symbolp c)
               `(progn (idx-mul ,a ,b ,c) ,c)
             `(let ((-dh-c ,c))
                (progn (idx-mul ,a ,b -dh-c) -dh-c)))
         (if (symbolp b)
             `(let ((-dh-c (clone-matrix ,b)))
                (idx-mul ,a ,b -dh-c) -dh-c)
           (if (symbolp a)
               `(let ((-dh-c (clone-matrix ,a)))
                  (idx-mul ,a ,b -dh-c) -dh-c)
             `(let* ((-dh-b ,b)
                     (-dh-c (clone-matrix -dh-b)))
                (idx-mul ,a -dh-b -dh-c) -dh-c))))) ) ) )
		       
(when (functionp m-m)
  (dhm-t m-m(source)
    (let (((func a b &optional c) source))
      (dhc-parse-replacement-source-t
       source
       (if c
           (if (symbolp c)
               `(progn (idx-sub ,a ,b ,c) ,c)
             `(let ((-dh-c ,c))
                (progn (idx-sub ,a ,b -dh-c) -dh-c)))
         (if (symbolp b)
             `(let ((-dh-c (clone-matrix ,b)))
                (idx-sub ,a ,b -dh-c) -dh-c)
           (if (symbolp a)
               `(let ((-dh-c (clone-matrix ,a)))
                  (idx-sub ,a ,b -dh-c) -dh-c)
             `(let* ((-dh-b ,b)
                     (-dh-c (clone-matrix -dh-b)))
                (idx-sub ,a -dh-b -dh-c) -dh-c))))) )) )

(when (functionp m*c)
  (dhm-t m*c(source)
    (let (((func a b &optional c) source))
      (dhc-parse-replacement-source-t
       source
       (if c
           (if (symbolp c)
               `(let ((-dh-d (matrix)))
                  (-dh-d ,b)
                  (idx-dotm0 ,a -dh-d ,c) ,c)
             `(let ((-dh-d (matrix)) (-dh-c ,c))
                (-dh-d ,b)
                (idx-dotm0 ,a -dh-d -dh-c) -dh-c))
         (if (symbolp a)
             `(let ((-dh-d (matrix)) (-dh-c (clone-matrix ,a)))
                (-dh-d ,b)
                (idx-dotm0 ,a -dh-d -dh-c) -dh-c)
           `(let* ((-dh-d (matrix)) (-dh-a ,a)
                   (-dh-c (clone-matrix -dh-a)))
              (-dh-d ,b)
              (idx-dotm0 -dh-a -dh-d -dh-c) -dh-c))) ) ) ) )

(when (functionp m+c)
  (dhm-t m+c(source)
    (let (((func a b &optional c) source))
      (dhc-parse-replacement-source-t
       source
       (if c
           (if (symbolp c)
               `(let ((-dh-d (matrix)))
                  (-dh-d ,b)
                  (idx-addm0 ,a -dh-d ,c) ,c)
             `(let ((-dh-d (matrix)) (-dh-c ,c))
                (-dh-d ,b)
                (idx-addm0 ,a -dh-d -dh-c) -dh-c))
         (if (symbolp a)
             `(let ((-dh-d (matrix)) (-dh-c (clone-matrix ,a)))
                (-dh-d ,b)
                (idx-addm0 ,a -dh-d -dh-c) -dh-c)
           `(let* ((-dh-d (matrix)) (-dh-a ,a)
                   (-dh-c (clone-matrix -dh-a)))
              (-dh-d ,b)
            (idx-addm0 -dh-a -dh-d -dh-c) -dh-c))))) ))

(when (functionp transpose)
  (dhm-t transpose(source)
    (when (<> (length source) 2)
      (dhc-error "one argument expected"))
    (let* ((a (cadr source))
           (ndimin (==> :(dhc-parse-expr-t a):type is-an-idxptr)))
      (dhc-parse-replacement-source-t
       source
       (selectq ndimin
         (1 `(let ((m (copy-matrix ,a)))
               (unfold m 0 (idx-dim m 0) 1)))
         (2 `(let ((m2 (copy-matrix ,a)))
               (idx-transclone m2 '(1 0))))
         (t (dhc-error "Two dimensioned matrix expected" a)) )) ) ) )





;;; ------------------------------------------------------------------------
;;; DHM FOR PARSING 'MA' OPERATIONS
;;; ------------------------------------------------------------------------

;; ------------------------------
;; MA with one argument!

(dhm-t idx-clear(source)
  (when (<> (length source) 2)
    (dhc-error "one argument expected"))
  (let* ((in (cadr source))
         (tn (dhc-parse-expr-t in))
         (ndimin (==> :tn:type is-an-idxptr)))
    (if ~ndimin (dhc-error "not a matrix" in))
    (==> (unode-val :(unode-val :tn:type:u-type):u-type)
         access 'write)
    (if (< ndimin 3)
        (new t-node (list tn) :tn:type ()())
      (dhc-parse-replacement-source-t
       source
       (let ((yo '(idx-clear in)))
         (while (> ndimin 3)
           (setq yo `(idx-bloop ((in in)) ,yo))
           (incr ndimin -1))
         (setq yo `(idx-bloop ((in ,in)) ,yo))
         yo)))))

(dhm-c idx-clear(source treetype retplace)
  (let* ((idx-type :(cadr :treetype:tn-list):type)
         (ndim (==> idx-type is-an-idxptr))
         (srg-type (new dhc-type (==> idx-type get-element-type)))
         (ret-string (dhc-parse-expr-c (cadr source)
                                       (cadr :treetype:tn-list)
                                       ())))
    (dhc-add-c-statements
     (sprintf "Midx_m%dclear(%s,%s);"
              ndim ret-string
              (dhc-type-to-c-decl srg-type)))
    ret-string))


;; ------------------------------
;; MA with two same size args


(putp idx-copy 'cname "copy")
(putp idx-minus 'cname "minus")
(putp idx-abs 'cname "abs")
(putp idx-sqrt 'cname "sqrt")
(putp idx-qtanh 'cname "qtanh")
(putp idx-qdtanh 'cname "qdtanh")
(putp idx-stdsigmoid 'cname "stdsigmoid")
(putp idx-dstdsigmoid 'cname "dstdsigmoid")
(putp idx-expmx 'cname "expmx")
(putp idx-dexpmx 'cname "dexpmx")
(putp idx-sin 'cname "sin")
(putp idx-cos 'cname "cos")
(putp idx-atan 'cname "atan")
(putp idx-log 'cname "log")
(putp idx-exp 'cname "exp")

(dhm-t idx-copy(source)
  (when (and (<> (length source) 3) (<> (length source) 2))
    (dhc-error "This function has one or two (in [out]) arguments"))
  (let* ((in (cadr source))
         (tn-in (dhc-parse-expr-t in))
         (ndimin (==> :tn-in:type is-an-idxptr)))
    (if ~ndimin (dhc-error "not a matrix" in))
    (if (= (length source) 3)
        (let* ((out (caddr source))
               (tn-out (dhc-parse-expr-t out))
               (ndimout (==> :tn-out:type is-an-idxptr)))
          (if ~ndimout (dhc-error "not a matrix" out))
          (when (<> ndimin ndimout)
            (dhc-error 
             "Matrices have different numbers of dimensions"))
          (==> (unode-val :(unode-val :tn-out:type:u-type):u-type)
               access 'write)
          ;; because automatic redimensioning
          (==> (unode-val :tn-out:type:u-type)
               access 'write)
          (if (< ndimin 3)
              (new t-node (list tn-in tn-out) :tn-out:type () ())
            (dhc-parse-replacement-source-t
             source
             (let ((yo `(,(car source) in out)))
               (while (> ndimin 3)
                 (setq yo `(idx-bloop ((in in)(out out)) ,yo))
                 (incr ndimin -1))
               (setq yo `(idx-bloop ((in ,in)(out ,out)) ,yo))
               yo))))
      (if (< ndimin 3)
          (dhc-parse-replacement-source-t 
           source
           `(let* ((in ,in))
              (,(car source) in (clone-matrix in))))
        (dhc-parse-replacement-source-t
         source
         (let ((yo `(,(car source) in out)))
           (while (> ndimin 3)
             (setq yo `(idx-bloop ((in in)(out out)) ,yo))
             (incr ndimin -1))
           (setq yo `(let* ((in ,in) (out (clone-matrix in)))
                       (idx-bloop ((in in)(out out)) ,yo)))
           yo))))))


(dhm-c idx-copy(source treetype retplace)
  (let* ((idx-type-in :(cadr :treetype:tn-list):type)
         (cname (or (getp (get-dhm-target source) 'cname)
                    (dhc-error "Cannot compile this function (no cname)") ) )
         (idx-type-out :(caddr :treetype:tn-list):type)
         (ndim (==> idx-type-in is-an-idxptr))
         (srg-type-in (new dhc-type (==> idx-type-in get-element-type)))
         (srg-type-out (new dhc-type (==> idx-type-out get-element-type)))
         (c1 (dhc-parse-expr-c (cadr source)(cadr :treetype:tn-list)()))
         (ret-string (dhc-parse-expr-c (last source)
                                       (last :treetype:tn-list)
                                       ())))
    (if ~dhc-unprotect
        (dhc-add-c-statements
         (sprintf "check_main_maout(%s,%s);" c1 ret-string)))
    (dhc-add-c-statements
     (sprintf "Midx_m%d%s(%s,%s,%s,%s);"
              ndim cname c1 ret-string
              (dhc-type-to-c-decl srg-type-in)
              (dhc-type-to-c-decl srg-type-out)))
    ret-string))

(dhm-t-declare idx-copy idx-minus idx-abs idx-sqrt idx-qtanh idx-qdtanh
	       idx-stdsigmoid idx-dstdsigmoid idx-expmx idx-dexpmx idx-sin
	       idx-cos idx-atan idx-log idx-exp)
(dhm-c-declare idx-copy idx-minus idx-abs idx-sqrt idx-qtanh idx-qdtanh
	       idx-stdsigmoid idx-dstdsigmoid idx-expmx idx-dexpmx idx-sin
	       idx-cos idx-atan idx-log idx-exp)

;; ------------------------------
;; MA with two arguments, 
;; last one of dim 0

(putp idx-sum    'dhmarg idx-sumacc) 
(putp idx-sup    'dhmarg idx-supacc)
(putp idx-inf    'dhmarg idx-infacc)
(putp idx-sumsqr 'dhmarg idx-sumsqracc)

(putp idx-sum 'cname "sum")
(putp idx-sup 'cname "sup")
(putp idx-inf 'cname "inf")
(putp idx-sumacc 'cname "sumacc")
(putp idx-supacc 'cname "supacc")
(putp idx-infacc 'cname "infacc")
(putp idx-sumsqr 'cname "sumsqr")
(putp idx-sumsqracc 'cname "sumsqracc")

(dhm-t idx-sum(source)
  (when (and (<> (length source) 3) (<> (length source) 2))
    (dhc-error "This function has one or two (in [out]) arguments"))
  (let* ((in (cadr source))
         (name (get-dhm-target source))
         (inner-name (or (getp name 'dhmarg) name))
         (tn-in (dhc-parse-expr-t in))
         (ndimin (==> :tn-in:type is-an-idxptr))
         (mgen (caddr (assoc (==> :tn-in:type get-element-type)
                             dhc-type-to-matrix))))
    
	 
    (if ~ndimin (dhc-error "not a matrix" in))
    (if (= (length source) 3)
        (let* ((out (caddr source))
               (tn-out (dhc-parse-expr-t out))
               (ndimout (==> :tn-out:type is-an-idxptr)))
          (if ~ndimout (dhc-error "not a matrix" out))
          (when (<> 0 ndimout)
            (dhc-error 
             "Output matrix is not an idx0"))
          (==> (unode-val :(unode-val :tn-out:type:u-type):u-type)
               access 'write)
          ;; because automatic redimensioning
          (==> (unode-val :tn-out:type:u-type)
               access 'write)
          (if (< ndimin 3)
              ;; full args, idx1
              (new t-node (list tn-in tn-out) :tn-out:type () ())
            ;; full args, idx3
            (dhc-parse-replacement-source-t
             source
             (let ((yo `(,inner-name in tEmP_m3AT)))
               (while (> ndimin 3)
                 (setq yo `(idx-bloop ((in in)) ,yo))
                 (incr ndimin -1))
               (setq yo `(idx-bloop ((in ,in)) ,yo))
               (setq yo `(let ((tEmP_m3AT 
                                ,(if (= inner-name name)
                                     out `(idx-clear ,out))))
                           ,yo tEmP_m3AT))
               yo))))
      ;; small idx, missing arg
      (if (< ndimin 3)
          (dhc-parse-replacement-source-t 
           source
           ;; progn necessary or it generates 2 dhm cells in treetype
           `(progn (,name ,in (,mgen))))
        ;; idx3, missing arg
        (dhc-parse-replacement-source-t
         source
         (let ((yo `(,inner-name in tEmP_m3AT)))
           (while (> ndimin 3)
             (setq yo `(idx-bloop ((in in)) ,yo))
             (incr ndimin -1))
           (setq yo `(let* ((tEmP_m3AT (,mgen)))
                       (idx-bloop ((in ,in)) ,yo) tEmP_m3AT))
           yo))))))

(dhm-c idx-sum(source treetype retplace)
  (let* ((idx-type-in :(cadr :treetype:tn-list):type)
         (cname (or (getp (get-dhm-target source) 'cname)
                    (dhc-error "Cannot compile this function (no cname)") ) )
         (idx-type-out :(caddr :treetype:tn-list):type)
         (ndim (==> idx-type-in is-an-idxptr))
         (srg-type-in (new dhc-type (==> idx-type-in get-element-type)))
         (srg-type-out (new dhc-type (==> idx-type-out get-element-type)))
         (c1 (dhc-parse-expr-c (cadr source)(cadr :treetype:tn-list)()))
         (ret-string (dhc-parse-expr-c (last source)
                                       (last :treetype:tn-list)
                                       ())))
    (if ~dhc-unprotect
        (dhc-add-c-statements
         (sprintf "check_main_m0out(%s,%s);" c1 ret-string)))
    (dhc-add-c-statements
     (sprintf "Midx_m%d%s(%s,%s,%s,%s);"
              ndim cname c1 ret-string
              (dhc-type-to-c-decl srg-type-in)
              (dhc-type-to-c-decl srg-type-out)))
    ret-string))

(dhm-t-declare idx-sum idx-sup idx-inf idx-sumacc 
               idx-supacc idx-infacc idx-sumsqr idx-sumsqracc)
(dhm-c-declare idx-sum idx-sup idx-inf idx-sumacc 
               idx-supacc idx-infacc idx-sumsqr idx-sumsqracc)

;; ------------------------------
;; MA with three same size args

(putp idx-add 'cname "add")
(putp idx-sub 'cname "sub")
(putp idx-mul 'cname "mul")
(putp idx-div 'cname "div")

(dhm-t idx-add(source)
  (when (and (<> (length source) 4) (<> (length source) 3))
    (dhc-error "This function has 2 or 3 (in in [out]) arguments"))
  (let* ((in1 (cadr source))
         (in2 (caddr source))
         (name (car source))
         (tn-in1 (dhc-parse-expr-t in1))
         (tn-in2 (dhc-parse-expr-t in2))
         (ndimin1 (==> :tn-in1:type is-an-idxptr))
         (ndimin2 (==> :tn-in2:type is-an-idxptr)))
    (if ~ndimin1 (dhc-error "not a matrix" in1))
    (if ~ndimin2 (dhc-error "not a matrix" in2))
    (when (<> ndimin1 ndimin2)
      (dhc-error 
       "Input matrices have different numbers of dimensions"))
    (if (= (length source) 4)
        (let* ((out (caddr (cdr source)))
               (tn-out (dhc-parse-expr-t out))
		    (ndimout (==> :tn-out:type is-an-idxptr)))
          (if ~ndimout (dhc-error "not a matrix" out))
          (when (<> ndimin1 ndimout)
            (dhc-error 
             "Matrices have different numbers of dimensions"))
          (==> (unode-val :(unode-val :tn-out:type:u-type):u-type)
               access 'write)
          ;; because automatic redimensioning
          (==> (unode-val :tn-out:type:u-type)
               access 'write)
          (if (< ndimin1 3)
              (new t-node (list tn-in1 tn-in2 tn-out) :tn-out:type () ())
            (dhc-parse-replacement-source-t
             source
             (let ((yo `(,name in1 in2 out)))
               (while (> ndimin1 3)
                 (setq yo `(idx-bloop ((in1 in1)(in2 in2)(out out)) ,yo))
                 (incr ndimin1 -1))
               (setq yo `(idx-bloop ((in1 ,in1)(in2 ,in2)(out ,out))
                           ,yo))
               yo))))
      (if (< ndimin1 3)
          (dhc-parse-replacement-source-t 
           source
           `(let ((tEmP_m1AT ,in1))
              (,name tEmP_m1AT ,in2 (clone-matrix tEmP_m1AT))))
        (dhc-parse-replacement-source-t
         source
         (let ((yo `(,name tEmP_m1AT in2 tEmP_m3AT)))
           (while (> ndimin1 3)
             (setq yo `(idx-bloop ((tEmP_m1AT tEmP_m1AT)
                                   (in2 in2)(tEmP_m3AT tEmP_m3AT))
                         ,yo))
             (incr ndimin1 -1))
           ;; beware of in1 or out appearing in2 (why strange names)
           (setq yo `(let* ((tEmP_m1AT ,in1)
                            (tEmP_m3AT (clone-matrix tEmP_m1AT)))
                       (idx-bloop ((tEmP_m1AT tEmP_m1AT)
                                   (in2 ,in2)
                                   (tEmP_m3AT tEmP_m3AT)) ,yo)))
           yo))))))

(dhm-c idx-add(source treetype retplace)
  (let* ((idx-type-in1 :(cadr :treetype:tn-list):type)
         (idx-type-in2 :(caddr :treetype:tn-list):type)
         (cname (or (getp (get-dhm-target source) 'cname)
                    (dhc-error "Cannot compile this function (no cname)") ) )
         (idx-type-out :(caddr (cdr :treetype:tn-list)):type)
         (ndim (==> idx-type-in1 is-an-idxptr))
         (srg-type-in1 (new dhc-type (==> idx-type-in1 get-element-type)))
         (srg-type-in2 (new dhc-type (==> idx-type-in2 get-element-type)))
         (srg-type-out (new dhc-type (==> idx-type-out get-element-type)))
         (c1 (dhc-parse-expr-c (cadr source)(cadr :treetype:tn-list)()))
         (c2 (dhc-parse-expr-c (caddr source)(caddr :treetype:tn-list)()))
         (ret-string (dhc-parse-expr-c (last source)
                                       (last :treetype:tn-list)
                                       ())))
    (if ~dhc-unprotect
        (dhc-add-c-statements
         (sprintf "check_main_main_maout(%s,%s,%s);" c1 c2 ret-string)))
    (dhc-add-c-statements
     (sprintf "Midx_m%d%s(%s,%s,%s,%s,%s,%s);"
              ndim cname c1 c2 ret-string
              (dhc-type-to-c-decl srg-type-in1)
              (dhc-type-to-c-decl srg-type-in2)
              (dhc-type-to-c-decl srg-type-out)))
    ret-string))

(dhm-t-declare idx-add idx-sub idx-mul idx-div)
(dhm-c-declare idx-add idx-sub idx-mul idx-div)

;; ------------------------------
;; MA with 3 arguments,
;; last one of dim 0

(putp idx-dot     'dhmarg idx-dotacc)
(putp idx-sqrdist 'dhmarg idx-sqrdistacc)
(putp idx-sqrdist 'cname "sqrdist")
(putp idx-sqrdistacc 'cname "sqrdistacc")


(dhm-t idx-dot(source)
  (when (and (<> (length source) 3) (<> (length source) 4))
    (dhc-error "This function has two or three (in in [out]) arguments"))
  (let* ((in1 (cadr source))
         (in2 (caddr source))
         (name (get-dhm-target source))
         (inner-name (or (getp name 'dhmarg) name))
         (tn-in1 (dhc-parse-expr-t in1))
         (tn-in2 (dhc-parse-expr-t in2))
         (ndimin1 (==> :tn-in1:type is-an-idxptr))
         (ndimin2 (==> :tn-in2:type is-an-idxptr))
         (mgen (caddr (assoc (==> :tn-in1:type get-element-type)
                             dhc-type-to-matrix))))
    (if ~ndimin1 (dhc-error "not a matrix" in1))
    (if ~ndimin2 (dhc-error "not a matrix" in2))
    (when (<> ndimin1 ndimin2)
      (dhc-error "Input matrices have different numbers of dimensions"))
    (if (= (length source) 4)
        (let* ((out (last source))
               (tn-out (dhc-parse-expr-t out))
               (ndimout (==> :tn-out:type is-an-idxptr)))
          (if ~ndimout (dhc-error "not a matrix" out))
          (when (<> 0 ndimout)
            (dhc-error "Output matrix is not an idx0"))
          (==> (unode-val :(unode-val :tn-out:type:u-type):u-type)
               access 'write)
          (if (< ndimin1 3)
              ;; full args, idx1
              (new t-node (list tn-in1 tn-in2 tn-out) :tn-out:type () ())
            ;; full args, idx3
            (dhc-parse-replacement-source-t
             source
             (let ((yo `(,inner-name in1 in2 tEmP_m3AT)))
               (while (> ndimin1 3)
                 (setq yo `(idx-bloop ((in1 in1)(in2 in2)) ,yo))
                 (incr ndimin1 -1))
               (setq yo `(idx-bloop ((in1 ,in1)(in2 ,in2))
                           ,yo))
               (setq yo `(let ((tEmP_m3AT ,(if (= inner-name name)
                                               out `(idx-clear ,out))))
                           ,yo tEmP_m3AT))
               yo))))
      ;; small idx, missing arg
      (if (< ndimin1 3)
          (dhc-parse-replacement-source-t 
           source
           ;; progn necessary or it generates 2 dhm cells in treetype
           `(progn (,name ,in1 ,in2 (,mgen))))
        ;; idx3, missing arg
        (dhc-parse-replacement-source-t
         source
         (let ((yo `(,inner-name in1 in2 tEmP_m3AT)))
           (while (> ndimin1 3)
             (setq yo `(idx-bloop ((in1 in1)(in2 in2)) ,yo))
             (incr ndimin1 -1))
           (setq yo `(let* ((tEmP_m3AT (,mgen)))
                       (idx-bloop ((in1 ,in1)(in2 ,in2)) ,yo) tEmP_m3AT))
           yo))))))

(dhm-c idx-dot(source treetype retplace)
  (let* ((idx-type-in1 :(cadr :treetype:tn-list):type)
         (idx-type-in2 :(caddr :treetype:tn-list):type)
         (ndim (==> idx-type-in1 is-an-idxptr))
         (name (get-dhm-target source))
         (cname (cond
                 ((= name idx-dot) (sprintf "dotm%d" ndim))
                 ((= name idx-dotacc) (sprintf "dotm%dacc" ndim))
                 (t (or (getp (get-dhm-target source) 'cname)
                        (dhc-error "Cannot compile this function (no cname)") )) ) )
         (idx-type-out :(last :treetype:tn-list):type)
         (srg-type-in1 (new dhc-type (==> idx-type-in1 get-element-type)))
         (srg-type-in2 (new dhc-type (==> idx-type-in2 get-element-type)))
         (srg-type-out (new dhc-type (==> idx-type-out get-element-type)))
         (c1 (dhc-parse-expr-c (cadr source)(cadr :treetype:tn-list)()))
         (c2 (dhc-parse-expr-c (caddr source)(caddr :treetype:tn-list)()))
         (ret-string (dhc-parse-expr-c (last source) 
                                       (last :treetype:tn-list) ())))
    (if ~dhc-unprotect
        (dhc-add-c-statements
         (sprintf "check_main_main_m0out(%s,%s,%s);" c1 c2 ret-string)))
    (dhc-add-c-statements
     (sprintf "Midx_m%d%s(%s,%s,%s,%s,%s,%s);"
              ndim cname c1 c2 ret-string
              (dhc-type-to-c-decl srg-type-in1)
              (dhc-type-to-c-decl srg-type-in2)
              (dhc-type-to-c-decl srg-type-out)))
    ret-string))

(dhm-t-declare idx-dot idx-dotacc idx-sqrdist idx-sqrdistacc)
(dhm-c-declare idx-dot idx-dotacc idx-sqrdist idx-sqrdistacc)


;; ------------------------------
;; MA with three args,
;; second one of dim 0

(putp idx-dotm0 'cname "dotm0")
(putp idx-dotm0acc 'cname "dotm0acc")
(putp idx-addm0 'cname "addm0")
(putp idx-addm0acc 'cname "addm0acc")

(dhm-t idx-dotm0(source)
  (when (and (<> (length source) 4) (<> (length source) 3))
    (dhc-error "This function has 2 or 3 (in in [out]) arguments"))
  (let* ((in1 (cadr source))
         (in2 (caddr source))
         (name (car source))
         (tn-in1 (dhc-parse-expr-t in1))
         (tn-in2 (dhc-parse-expr-t in2))
         (ndimin1 (==> :tn-in1:type is-an-idxptr))
         (ndimin2 (==> :tn-in2:type is-an-idxptr)))
    (if ~ndimin1 (dhc-error "not a matrix" in1))
    (if ~ndimin2 (dhc-error "not a matrix" in2))
    (when (<> ndimin2 0)
      (dhc-error "Second input matrix must be an idx0"))
    (if (= (length source) 4)
        (let* ((out (caddr (cdr source)))
               (tn-out (dhc-parse-expr-t out))
               (ndimout (==> :tn-out:type is-an-idxptr)))
          (if ~ndimout (dhc-error "not a matrix" out))
          (when (<> ndimin1 ndimout)
            (dhc-error "Matrices have different numbers of dimensions"))
          (==> (unode-val :(unode-val :tn-out:type:u-type):u-type)
               access 'write)
          (==> (unode-val :tn-out:type:u-type)
               access 'write)
          (if (< ndimin1 3)
              (new t-node (list tn-in1 tn-in2 tn-out) :tn-out:type () ())
            (dhc-parse-replacement-source-t
             source
             (let ((yo `(,name in1 tEmP_m3AT out)))
               (while (> ndimin1 3)
                 (setq yo `(idx-bloop ((in1 in1)(out out)) ,yo))
                 (incr ndimin1 -1))
               (setq yo `(let ((tEmP_m3AT ,in2))
                           (idx-bloop ((in1 ,in1)(out ,out))
                             ,yo)))
               yo))))
      (if (< ndimin1 3)
          (dhc-parse-replacement-source-t 
           source
           `(let ((tEmP_m1AT ,in1))
              (,name tEmP_m1AT ,in2 (clone-matrix tEmP_m1AT))))
        (dhc-parse-replacement-source-t
         source
         (let ((yo `(,name tEmP_m1AT in2 out)))
           (while (> ndimin1 3)
             (setq yo `(idx-bloop ((tEmP_m1AT tEmP_m1AT)
                                   (out out))
                         ,yo))
             (incr ndimin1 -1))
           (setq yo `(let* ((tEmP_m1AT ,in1)
                            (in2 ,in2)
                            (out (clone-matrix tEmP_m1AT)))
                       (idx-bloop ((tEmP_m1AT tEmP_m1AT)
                                   (out out)) ,yo)))
           yo))))))

(dhm-c idx-dotm0(source treetype retplace)
  (let* ((idx-type-in1 :(cadr :treetype:tn-list):type)
         (idx-type-in2 :(caddr :treetype:tn-list):type)
         (cname (or (getp (get-dhm-target source) 'cname)
                    (dhc-error "Cannot compile this function (no cname)") ))
         (idx-type-out :(caddr (cdr :treetype:tn-list)):type)
         (ndim (==> idx-type-in1 is-an-idxptr))
         (srg-type-in1 (new dhc-type (==> idx-type-in1 get-element-type)))
         (srg-type-in2 (new dhc-type (==> idx-type-in2 get-element-type)))
         (srg-type-out (new dhc-type (==> idx-type-out get-element-type)))
         (c1 (dhc-parse-expr-c (cadr source)(cadr :treetype:tn-list)()))
         (c2 (dhc-parse-expr-c (caddr source)(caddr :treetype:tn-list)()))
         (ret-string (dhc-parse-expr-c (last source)
                                       (last :treetype:tn-list)
                                       ())))
    (if ~dhc-unprotect
        (dhc-add-c-statements
         (sprintf "check_main_m0in_maout(%s,%s,%s);" c1 c2 ret-string)))
    (dhc-add-c-statements
     (sprintf "Midx_m%d%s(%s,%s,%s,%s,%s,%s);"
              ndim cname c1 c2 ret-string
              (dhc-type-to-c-decl srg-type-in1)
              (dhc-type-to-c-decl srg-type-in2)
              (dhc-type-to-c-decl srg-type-out)))
	 ret-string))

(dhm-t-declare idx-dotm0 idx-dotm0acc idx-addm0 idx-addm0acc)
(dhm-c-declare idx-dotm0 idx-dotm0acc idx-addm0 idx-addm0acc)

;; ------------------------------
;; Matrix * Vector

(putp idx-m2dotm1 'cname "m2dotm1")
(putp idx-m2dotm1acc 'cname "m2dotm1acc")

(dhm-t idx-m2dotm1(source)
  (when (and (<> (length source) 3) (<> (length source) 4))
    (dhc-error "This function has 2 or 3 (in in [out]) arguments"))
  (let* ((in1 (cadr source))
         (in2 (caddr source))
         (name (car source))
         (tn-in1 (dhc-parse-expr-t in1))
         (tn-in2 (dhc-parse-expr-t in2))
         (ndimin1 (==> :tn-in1:type is-an-idxptr))
         (ndimin2 (==> :tn-in2:type is-an-idxptr)))
    (if ~ndimin1 (dhc-error "not a matrix" in1))
    (if ~ndimin2 (dhc-error "not a matrix" in2))
    (if (<> ndimin1 2) (dhc-error "Arg #1 is not a 2 dimensional matrix"))
    (if (<> ndimin2 1) (dhc-error "Arg #2 is not a 1 dimensional matrix"))
    (if (= (length source) 4)
        (let* ((out (last source))
               (tn-out (dhc-parse-expr-t out))
               (ndimout (==> :tn-out:type is-an-idxptr)))
          (if ~ndimout (dhc-error "not a matrix" out))
          (if (<> ndimout 1) (dhc-error 
                              "Arg #3 is not a 1 dimensional matrix"))
          (==> (unode-val :(unode-val :tn-out:type:u-type):u-type)
               access 'write)
          (==> (unode-val :tn-out:type:u-type)
               access 'write)
          (new t-node (list tn-in1 tn-in2 tn-out) :tn-out:type () ()))
      ;; Missing arg
      (dhc-parse-replacement-source-t 
       source
       `(let ((in1 ,in1)(in2 ,in2))
          (let ((out (clone-matrix in2)))
            (,name in1 in2 out) out))))))

(dhm-c idx-m2dotm1(source treetype retplace)
  (let* ((idx-type-in1 :(cadr :treetype:tn-list):type)
         (idx-type-in2 :(caddr :treetype:tn-list):type)
         (ndim (==> idx-type-in1 is-an-idxptr))
         (cname (or (getp (get-dhm-target source) 'cname)
                    (dhc-error "Cannot compile this function (no cname)") ) )
         (idx-type-out :(last :treetype:tn-list):type)
         (srg-type-in1 (new dhc-type (==> idx-type-in1 get-element-type)))
         (srg-type-in2 (new dhc-type (==> idx-type-in2 get-element-type)))
         (srg-type-out (new dhc-type (==> idx-type-out get-element-type)))
         (c1 (dhc-parse-expr-c (cadr source)(cadr :treetype:tn-list)()))
         (c2 (dhc-parse-expr-c (caddr source)(caddr :treetype:tn-list)()))
         (ret-string (dhc-parse-expr-c (last source) 
                                       (last :treetype:tn-list) ())))
    (if ~dhc-unprotect
        (dhc-add-c-statements
         (sprintf "check_main_main_maout_dot21(%s,%s,%s);" c1 c2 ret-string)))
    (dhc-add-c-statements
     (sprintf "Midx_%s(%s,%s,%s,%s,%s,%s);"
              cname c1 c2 ret-string
              (dhc-type-to-c-decl srg-type-in1)
              (dhc-type-to-c-decl srg-type-in2)
              (dhc-type-to-c-decl srg-type-out)))
    ret-string))

(dhm-t-declare idx-m2dotm1 idx-m2dotm1acc)
(dhm-c-declare idx-m2dotm1 idx-m2dotm1acc)



;; ------------------------------
;; Tensor4 * Tensor2

(putp idx-m4dotm2 'cname "m4dotm2")
(putp idx-m4dotm2acc 'cname "m4dotm2acc")

(dhm-t idx-m4dotm2(source)
  (when (and (<> (length source) 3) (<> (length source) 4))
    (dhc-error "This function has 2 or 3 (in in [out]) arguments"))
  (let* ((in1 (cadr source))
         (in2 (caddr source))
         (name (car source))
         (tn-in1 (dhc-parse-expr-t in1))
         (tn-in2 (dhc-parse-expr-t in2))
         (ndimin1 (==> :tn-in1:type is-an-idxptr))
         (ndimin2 (==> :tn-in2:type is-an-idxptr)))
    (if ~ndimin1 (dhc-error "not a matrix" in1))
    (if ~ndimin2 (dhc-error "not a matrix" in2))
    (if (<> ndimin1 4) (dhc-error "Arg #1 is not a 4 dimensional matrix"))
    (if (<> ndimin2 2) (dhc-error "Arg #2 is not a 2 dimensional matrix"))
    (if (= (length source) 4)
        (let* ((out (last source))
               (tn-out (dhc-parse-expr-t out))
               (ndimout (==> :tn-out:type is-an-idxptr)))
          (if ~ndimout (dhc-error "not a matrix" out))
          (if (<> ndimout 2) 
              (dhc-error "Arg #3 is not a 2 dimensional matrix"))
          (==> (unode-val :(unode-val :tn-out:type:u-type):u-type)
               access 'write)
          (==> (unode-val :tn-out:type:u-type)
               access 'write)
          (new t-node (list tn-in1 tn-in2 tn-out) :tn-out:type () ()))
      ;; Missing arg
      (dhc-parse-replacement-source-t 
       source
       `(let ((in1 ,in1)(in2 ,in2))
          (let ((out (clone-matrix in2)))
            (,name in1 in2 out) out))))))

(dhm-c idx-m4dotm2(source treetype retplace)
  (let* ((idx-type-in1 :(cadr :treetype:tn-list):type)
         (idx-type-in2 :(caddr :treetype:tn-list):type)
         (ndim (==> idx-type-in1 is-an-idxptr))
         (cname (or (getp (get-dhm-target source) 'cname)
                    (dhc-error "Cannot compile this function (no cname)") ) )
         (idx-type-out :(last :treetype:tn-list):type)
         (srg-type-in1 (new dhc-type (==> idx-type-in1 get-element-type)))
         (srg-type-in2 (new dhc-type (==> idx-type-in2 get-element-type)))
         (srg-type-out (new dhc-type (==> idx-type-out get-element-type)))
         (c1 (dhc-parse-expr-c (cadr source)(cadr :treetype:tn-list)()))
         (c2 (dhc-parse-expr-c (caddr source)(caddr :treetype:tn-list)()))
         (ret-string (dhc-parse-expr-c (last source) 
                                       (last :treetype:tn-list) ())))
    (if ~dhc-unprotect
        (dhc-add-c-statements
         (sprintf "check_main_main_maout_dot42(%s,%s,%s);" 
                  c1 c2 ret-string)))
    (dhc-add-c-statements
     (sprintf "Midx_%s(%s,%s,%s,%s,%s,%s);"
              cname c1 c2 ret-string
              (dhc-type-to-c-decl srg-type-in1)
              (dhc-type-to-c-decl srg-type-in2)
              (dhc-type-to-c-decl srg-type-out)))
    ret-string))

(dhm-t-declare idx-m4dotm2 idx-m4dotm2acc)
(dhm-c-declare idx-m4dotm2 idx-m4dotm2acc)



;; ------------------------------
;; External product

(putp idx-m1extm1 'dhmarg 1)
(putp idx-m2extm2 'dhmarg 2)
(putp idx-m1extm1acc 'dhmarg 1)
(putp idx-m2extm2acc 'dhmarg 2)
(putp idx-m1extm1 'cname "m1extm1")
(putp idx-m2extm2 'cname "m2extm2")
(putp idx-m1extm1acc 'cname "m1extm1acc")
(putp idx-m2extm2acc 'cname "m2extm2acc")

(dhm-t idx-m1extm1(source)
  (when (and (<> (length source) 3) (<> (length source) 4))
    (dhc-error "This function has 2 or 3 (in in [out]) arguments"))
  (let* ((in1 (cadr source))
         (in2 (caddr source))
         (name (get-dhm-target source))
         (e-dim (getp name 'dhmarg))
         (tn-in1 (dhc-parse-expr-t in1))
         (tn-in2 (dhc-parse-expr-t in2))
         (ndimin1 (==> :tn-in1:type is-an-idxptr))
         (ndimin2 (==> :tn-in2:type is-an-idxptr))
         (mgen (cadr (assoc (==> :tn-in1:type get-element-type)
                            dhc-type-to-matrix))))
    (if ~ndimin1 (dhc-error "not a matrix" in1))
    (if ~ndimin2 (dhc-error "not a matrix" in2))
    (if (<> ndimin1 e-dim) 
        (dhc-error (sprintf "Arg #1 is not a %dD matrix" e-dim)))
    (if (<> ndimin2 e-dim) 
        (dhc-error (sprintf "Arg #2 is not a %dD matrix" e-dim)))
    (if (= (length source) 4)
        (let* ((out (last source))
               (tn-out (dhc-parse-expr-t out))
               (ndimout (==> :tn-out:type is-an-idxptr)))
          (if ~ndimout (dhc-error "not a matrix" out))
          (if (<> ndimout (* 2 e-dim))
              (dhc-error 
               (sprintf "Arg #3 is not a %dD matrix" e-dim)))
          (==> (unode-val :(unode-val :tn-out:type:u-type):u-type)
               access 'write)
          (==> (unode-val :tn-out:type:u-type)
               access 'write)
          (new t-node (list tn-in1 tn-in2 tn-out) :tn-out:type () ()))
      ;; Missing arg
      (dhc-parse-replacement-source-t 
       source
       `(let ((in1 ,in1)(in2 ,in2))
          (let ((out ,(if (= e-dim 1)
                          `(,mgen (idx-dim in1 0) (idx-dim in2 0))
                        `(,mgen (idx-dim in1 0) (idx-dim in1 1)
                                (idx-dim in2 0) (idx-dim in2 1)))))
            (,name in1 in2 out) out))))))


(dhm-c idx-m1extm1(source treetype retplace)
  (let* ((idx-type-in1 :(cadr :treetype:tn-list):type)
         (idx-type-in2 :(caddr :treetype:tn-list):type)
         (ndim (==> idx-type-in1 is-an-idxptr))
         (cname (or (getp (get-dhm-target source) 'cname)
                    (dhc-error "Cannot compile this function (no cname)") ) )
         (idx-type-out :(last :treetype:tn-list):type)
         (srg-type-in1 (new dhc-type (==> idx-type-in1 get-element-type)))
         (srg-type-in2 (new dhc-type (==> idx-type-in2 get-element-type)))
         (srg-type-out (new dhc-type (==> idx-type-out get-element-type)))
         (c1 (dhc-parse-expr-c (cadr source)(cadr :treetype:tn-list)()))
         (c2 (dhc-parse-expr-c (caddr source)(caddr :treetype:tn-list)()))
         (ret-string (dhc-parse-expr-c (last source) 
                                       (last :treetype:tn-list) ())))
    (if ~dhc-unprotect
        (dhc-add-c-statements
         (sprintf (if (= ndim 1) "check_m1in_m1in_m2out(%s,%s,%s);" 
                    "check_m2in_m2in_m4out(%s,%s,%s);")
                  c1 c2 ret-string)))
    (dhc-add-c-statements
     (sprintf "Midx_%s(%s,%s,%s,%s,%s,%s);"
              cname c1 c2 ret-string
              (dhc-type-to-c-decl srg-type-in1)
              (dhc-type-to-c-decl srg-type-in2)
              (dhc-type-to-c-decl srg-type-out)))
    ret-string))

(dhm-t-declare idx-m1extm1 idx-m2extm2 idx-m1extm1acc idx-m2extm2acc)
(dhm-c-declare idx-m1extm1 idx-m2extm2 idx-m1extm1acc idx-m2extm2acc)



;;; ------------------------------------------------------------------------
;;; DHM FOR PARSING PRINTF
;;; ------------------------------------------------------------------------


(de dhc-match-string-types (source arg-tnodes)
  (let*  ((arg-types
           (all ((ty arg-tnodes))
             (unode-val :ty:type:u-tclass)))
          (str-type ())
          (search (lambda (pos) 
                    (regex-seek
                     "((%)(-)?([0-9])*(\\.)?([0-9])*([a-z]|[A-Z]|\\ ))|(%%)"
                     source (+ (car pos) (cadr pos)))))
          (pos '(0 0)) (i 0) (num-args (length arg-types)))
    (while (and pos (< i num-args))
      (setq pos (search pos))
      (when (consp pos)
        (setq str-type (mid source (car pos) (cadr pos)))
        (if (not (selectq (right str-type 1)
                   ("d" 
                    (member (car arg-types) 
                            '(dht-number dht-int dht-byte dht-ubyte)))
                   (("f" "e" "g")
                    (member (car arg-types)
                            '(dht-number dht-flt dht-double)))
                   (("x" "X")
                    (member (car arg-types) 
                            '(dht-number dht-int dht-byte dht-ubyte)))
                   ("s"
                    (member (car arg-types) 
                            '(dht-str)))
                   ("%" t)
                   (t (dhc-error (concat "unknown type \" " str-type "\"")) ) ))
            (dhc-error (concat "type mismatch: \"" source "\" -> "  str-type)) )
        (when (<> "%" (right str-type 1))
          (setq arg-types (cdr arg-types))
          (setq i (+ 1 i)))))
    (if (or (<> i num-args)
            (and pos (setq pos (search pos))
                 (<> "%%" (mid source (car pos) (cadr pos)))))
        (dhc-error "number of arguments disagrees with number in format string") ) ) )

(dhm-t printf(source)
  (when (> 2 (length source))
    (dhc-error "at least one argument expected"))
  (let* ((tns (all ((tn (cdr source)))
                (if ~(stringp tn)
                  (dhc-parse-expr-t tn)
                  (new t-node () (new dhc-type 'dht-str) tn ())))))
    (when ~(==> :(car tns):type is-a-str)
          (dhc-error "first argument must be an string"))
    (if (stringp (cadr source))
        (dhc-match-string-types :(car tns):source (cdr tns)))
    (new t-node tns (new dhc-type 'dht-bool))))

(dhm-c printf(source treetype retplace)
  (let ((arg-source (cdr source))
        (arg-names 
         (all ((nm (cdr source)) (nmt (cdr :treetype:tn-list)))
           (if ~(stringp nm)
             (dhc-parse-expr-c nm nmt ())
             nm)))
        (data ())
        (arg-types
         (all ((ty (cdr :treetype:tn-list)))
           (unode-val :ty:type:u-tclass))))
    (if ~(stringp (car arg-source))
      (setq data (sprintf "printf((char *)((%s)->data)"
                          (car arg-names)))
      (setq data (sprintf "printf(\"%s\"" (dhc-printf-to-c
                                           (car arg-source)))))
    (each ((thearg (cdr arg-names))
           (theargsource (cdr arg-source))
           (thetype (cdr arg-types)))
      (if (= thetype 'dht-str)
          (if ~(stringp theargsource)
            (setq data (concat data ",(char *)((" thearg ")->data)"))
            (setq data (concat data "," "\""
                               (dhc-printf-to-c theargsource)
                               "\"")))
        (setq data (concat data "," thearg))))
    (dhc-add-c-statements  (concat  data ");")))
  "0")





;;; ------------------------------------------------------------------------
;;; DHM FOR PARSING STRING OPERATIONS
;;; ------------------------------------------------------------------------




;;; ------------------------------------------------------------------------
;;; DHM FOR PARSING OBJECT OPERATIONS
;;; ------------------------------------------------------------------------




;;; ------------------------------------------------------------------------
;;; DHM FOR PARSING LIST OPERATIONS
;;; ------------------------------------------------------------------------




;;; ------------------------------------------------------------------------
;;; DHM FOR PARSING GRAPHICS OPERATIONS
;;; ------------------------------------------------------------------------






