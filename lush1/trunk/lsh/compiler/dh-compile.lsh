;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; LUSH Lisp Universal Shell
;;;   Copyright (C) 2002 Leon Bottou, Yann Le Cun, AT&T Corp, NECI.
;;; Includes parts of TL3:
;;;   Copyright (C) 1987-1999 Leon Bottou and Neuristique.
;;; Includes selected parts of SN3.2:
;;;   Copyright (C) 1991-2001 AT&T Corp.
;;;
;;; This program is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 2 of the License, or
;;; (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program; if not, write to the Free Software
;;; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; $Id: dh-compile.lsh,v 1.9 2002-07-22 22:54:39 leonb Exp $
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;;; ------------------------------------------------------------------------
;;; ------------------------------------------------------------------------
;;; ------------------------------------------------------------------------
;;;                 D   H   -   C   O   M   P   I   L   E   R
;;; ------------------------------------------------------------------------
;;; ------------------------------------------------------------------------
;;; ------------------------------------------------------------------------


(libload "dh-util"))
(libload "dh-macro"))








;;; ------------------------------------------------------------------------
;;; ------------------------------------------------------------------------
;;;          C O D E    G E N E R A T I O N     U T I L I T I E S
;;; ------------------------------------------------------------------------
;;; ------------------------------------------------------------------------





;;; ------------------------------------------------------------------------
;;; GENERATE C CODE
;;; ------------------------------------------------------------------------



#? (dhc-generate-c <filename> '([<func1> [<funcn>]]))
;; Translate lisp functions and classes <func1>...<funcn> to C code
;; and produces a source file suitable for a file named <filename>.
;; Argument <filename> should be provided without the ".c" suffix
;; and must be a legal C identifier as it is used for the initialization
;; function in the C code.

(de dhc-generate-c (filename fsymb-list)
  (let* ((fname (basename filename))
         (ifcompiled (mlambda(fdf then . else) then))
         (C-COMPILE t)
         (c-pheader ())
         (c-header ())
         (program ())
         (metaprogram ())
         (initialization-calls ())
         (external-symbols ())
         (external-metasymbols ())
         (lex-level 0)
         (tmpnames-seed 0)
         (static-counter 0)
         (dhc-debug-stack ())
         (lname-list (all ((x fsymb-list))
                       (if (consp x) (mapcar pname x) (pname x))))
         (cname-list (all ((x lname-list))
                       (if (consp x) (mapcar dhc-lisp-to-c-name x)
                         (dhc-lisp-to-c-name x))))
         (func-list  (all ((x fsymb-list))
                       (if (consp x) (eval `:,(car x)) (eval `:,x))) )
         (treetype-list ())
         (source-list ())
         (symbol-table ())    ;; local symbol table
         (global-table ()) )  ;; gobal symbol table
    
    ;; FIRST PASS (MACRO+TYPES)
   (each ((funcname fsymb-list) 
	  (lname lname-list) 
	  (cname cname-list)
	  (func func-list))
     (when (not func)
       (error 'dhc-generate-c "Symbol is undefined" funcname))
     (cond 
      ;; FUNCTION
      ((functionp func)
       (when (and (is-of-class func |DH|)
                  (getp func 'saved) )
         (setq func (getp func 'saved)) )
       (when (not (is-of-class func |DE|))
         (error 'dhc-generate-c 
                "Cannot compile function of this type" funcname) )
       (let (((key arg . body) (funcdef func)))
         (printf "Preprocessing and parsing %s...\n" lname)
         (setq body (dhc-pp-all body))
         ;; Also protect the source from source replacement
         ;;   but give the altered source to the 2nd pass.
         (let ((source (dhc-copy-source-tree `(lambda ,arg ,@body))))
           (setq source-list (dhc-alist-add func source-list source))
           (setq treetype-list (cons (dhc-parse-expr-t source) treetype-list))
           ;; Make the new compiled function visible for subsequent function
           (let ((sym (new dhc-symbol funcname 0)))
             (dhc-unify-types :(car treetype-list):type :sym:type)
             (setq :sym:c-name cname)
             (setq global-table 
                   (append global-table 
                           (list (cons funcname sym)))) ) ) ) )
      ;; CLASS
      ((classp func)
       (setq treetype-list
             (cons (dhc-compile-class-t funcname cname func)
                   treetype-list ) ) )
      ;; ERROR
      (t 
       (error 'dhc-generate-c "cannot compile this object" funcname) ) ) )
   
   ;; SECOND PASS (GENERATION)
   (each ((funcname fsymb-list) 
	  (lname lname-list) 
	  (cname cname-list) 
	  (func func-list)
	  (treetype (reverse treetype-list)))
     (cond
      ;; FUNCTION
      ((functionp func)
       (when (is-of-class func |DH|)
         (setq func (getp func 'saved)) )
       (let ((source (dhc-alist-get func source-list)))
         (printf "Generating C for %s...\n" lname)
         (dhc-add-program 
          (append (list "" "/*" (sprintf " * FUNCTION %s" lname) " */")
                  (dhc-generate-compiled-func 
                   (concat "C_" cname) source treetype)) )
         (dhc-add-metaprogram
          (append (list "" "/*" (sprintf " * STUB %s" lname) " */")
                  (dhc-generate-interface-func cname treetype)
                  (list "" "/*" (sprintf " * DHDOC %s" lname) " */")
                  (dhc-generate-dhdoc-info-func cname :treetype:type) ) )
         (dhc-add-initialization
          (list (sprintf " dh_define(%l, &K_%s_R%s); " 
                         lname cname (dhu-hash :treetype:type) ) ) ) ) )
      ;; CLASS
      ((classp func)
       (dhc-compile-class-c funcname cname func treetype)
       t ) ) )

   ;; GENERATE THE FULL PROGRAM
   (setq program
         (append
          (dhc-generate-file-header fname)
          (list "" "/* ---------------------------------------- */" "")
          program
          (list "" "/* ---------------------------------------- */" "")
          (list "#ifndef NOLISP" "")
          (if external-metasymbols
              (append (list "/* Declarations */")
                      (dhc-remove-dup external-metasymbols) 
                      (list "") ) )
          metaprogram
          (list "")
          (dhc-generate-init-call fname)
          (list "" "#endif" "") ) )
   
   ;; CLEANUPS
   (each ((type treetype-list))
     (delete type) )
   (each (((name . type) global-table))
     (delete type) )
   program ) )



;; Make the file header
(de dhc-generate-file-header(filename)
    (append 
     ;; warning
     (list
      "/* WARNING: Automatically generated code."
      " * This code has been generated by the DH compiler."
      " */" "" ) 
     ;; pheaders
     (if c-pheader
         (cons "/*** USER DEFINED HEADERS (pheader) ***/"
               (dhc-remove-dup c-pheader) ) )
     ;; lush headers
     (cons "/* Lush headers */"
           (list "#include \"header.h\""
                 "#include \"dh.h\""
                 "#include \"idxmac.h\""
                 "#include \"idxops.h\""
                 "#include \"check_func.h\"" ) )
     ;; other headers
     (if c-header
         (cons "/* User defined headers (cheader) */"
               (dhc-remove-dup c-header) ) )
     ;; externals
     (list "")
     (if external-symbols
         (cons "/* Declarations */"
               (dhc-remove-dup external-symbols) ) )
     (list "") ) )


;; Make the initialisation routine
(de dhc-generate-init-call( filename )
  (append
   (list  "/*" " * INIT FUNCTION" " */" )
   (list (sprintf "void init_%s(void)" filename)
         "{" )
   initialization-calls
   (list "}"
         ""
         (sprintf "int majver_%s = %s;" filename (getconf "LUSH_MAJOR"))
         (sprintf "int minver_%s = %s;" filename (getconf "LUSH_MINOR"))
         "" ) ) )





;;; ------------------------------------------------------------------------
;;; PARSING FUNCTION DEFINITIONS
;;; ------------------------------------------------------------------------

(when dhc-debug-flag
  (putp lambda 'dhm-t ()) 
  (putp lambda 'dhm-c ()) )

(dhm-t lambda(source)
  (let (((lamb arguments .  body) source)
        (symbol-table symbol-table)
        (bump-list ())
        (arg-list ())
        (arg-treetype ())
        (tmpnames-seed tmpnames-seed)
        (return-type (new dhc-type 'dht-unk))
        (treetype ()))
    (setq arg-list 
          (all ((arg arguments)) (dhc-add-symbol-table arg 1)))
    (setq arg-treetype 
          (all ((symb arg-list) (arg arguments))
            (new t-node () :symb:type arg symb)))uy
            (let ((split ()))
              (let ((new-symbol-table symbol-table)
                    (symbol-table symbol-table)
                    (lex-level (1+ lex-level))
                    (bump-list ()))
                (setq treetype (dhc-parse-progn-t body))
                (dhc-assign-unify return-type :treetype:type)
                ;; if number, unify the type 
                ;; (if return is an int we want an int)
                (if (==> :treetype:type is-a-number)
                    (dhc-unify-types return-type :treetype:type))
                (let ((returnpoint (dhc-gather-types return-type t)))
                  (each ((arg arg-list))  
                    (setq returnpoint
                          (nconc returnpoint 
                                 (dhc-gather-types :arg:type ()))))
                  (each ((point returnpoint))
                    (==> point bump-level 0)) )
                (setq split 
                      (dhc-split-list bump-list 
                                      (lambda (x) (< (==> :x:type bump-level)
                                                     lex-level))))
                (setq :treetype:symbol (cadr split))
                (setq split (car split)))
              (setq bump-list (append bump-list split)))
            (setq :treetype:type (new dhc-type 'dht-func
                                      (all ((symb arg-list)) :symb:type)
                                      (all ((symb bump-list)) 
                                        :symb:type)
                                      return-type))
            ;; The variables which are bumped 
            ;; out are stored in symbol of args.
            (setq :treetype:tn-list 
                  (cons (new t-node arg-treetype (new dhc-type 'dht-unk) 
                             () bump-list)
                        :treetype:tn-list))
            treetype ) )

(dhm-c lambda(source treetype retplace)
  (dhc-error "The dhm-c for function lambda should never be called") )



;;; ------------------------------------------------------------------------
;;; GENERATING OF C FUNCTION COMPONENTS
;;; ------------------------------------------------------------------------


(de dhc-generate-prologue(c-name treetype)
  (let* ((functype :treetype:type)
         (rettype (unode-val :functype:u-type))
         (temp-list :(cadr :treetype:tn-list):symbol)
         (temp-list-type (all ((x temp-list)) :x:type))
         (arg-list (all ((x :(cadr :treetype:tn-list):tn-list)) :x:symbol))
         (arg-list-type (all ((x arg-list)) :x:type )) )
    ;; pointerify temporaries
    (setq temp-list-type
          (all ((arg temp-list-type))
            (if (not (==> arg is-a-ptr))
                (new dhc-type 'dht-ptr arg)
              arg ) ) )
    ;; build prototype
    (concat (dhc-type-to-c-decl rettype) 
            " " c-name "("
            (dhc-insert-op 
             (all ((symb-name (append arg-list temp-list))
                   (symb-type (append arg-list-type temp-list-type)) )
               (concat (dhc-type-to-c-decl symb-type) " " :symb-name:c-name) )
             "," ) 
            ")"  ) ) )

;; This is the main entry point of the 
;; code generation in the compiler...
(de dhc-generate-compiled-func(cname source treetype)
  (let ((c-prologue ())	
        (c-declarations ())
        (c-statements ())
        (c-epilog ())
        (tmpnames-seed tmpnames-seed)
        (label-seed 0)
        ((lam args . body-treetype) :treetype:tn-list))
    
    (setq c-prologue (dhc-generate-prologue cname treetype))
    ;; generate return statement
    (let ((ret (dhc-bumped-block body-treetype ()
                                 (dhc-parse-progn-c (cddr source)
                                                    body-treetype ()))))
      (if (==> :(caddr :treetype:tn-list):type is-a-nil)
          (setq c-epilog (nconc1 c-epilog "return 0;"))
        (setq c-epilog (nconc1 c-epilog (sprintf "return %s;" ret))) ) )
    ;; Return program (as a list of lines)
    (append (list c-prologue)
            (list "{" (sprintf "TRACE_PUSH(\"%s\");" cname) "{")
            c-declarations 
            c-statements 
            (list (sprintf "TRACE_POP(\"%s\");" cname))
            c-epilog
            (list "}" "}") ) ) )


(de dhc-generate-interface-func(c-name treetype)
  (let ((pro (sprintf "DH(X_%s)" c-name))
        (call (list "ret." 
                    (dhc-arg-format (dhu-type :treetype:type)) 
                    " = "
                    (if (==> (dhu-type :treetype:type) is-an-objptr) 
                        "(int *)" "" )
                    " C_" c-name "(" ))
        ((lam args . body-treetype) :treetype:tn-list)
        (arg-list ())
        (num 0) )
    ;; take care arguments and temporaries
    (each ((sym (all ((x :args:tn-list)) :x:symbol)))
      (let ((format (concat "a[%d]." (dhc-arg-format :sym:type))))
        (setq arg-list (nconc1 arg-list (sprintf format (incr num))))))
    (each ((sym :(cadr :treetype:tn-list):symbol))
      (let* ((type (if (==> :sym:type is-a-ptr) 
                       :sym:type 
                     (new dhc-type 'dht-ptr :sym:type))) 
             (format  (concat "a[%d]." (dhc-arg-format type))) )
        (setq arg-list (nconc1 arg-list (sprintf format (incr num))))))
    (setq call (nconc1 call (dhc-insert-op arg-list ", ")))
    (list pro "{" "dharg ret;" (concat (apply concat call) ");") 
          "return ret;" "}" ) ) )


(de dhc-generate-dhdoc-info-func(c-name functype)
  (let* ((desc (==> functype type-to-desc))
         (kname (sprintf "K_%s_R%s" c-name (dhu-hash functype)))
         (c-depends (dhc-remove-dup c-depends)) )
    (append
     (list (sprintf "DHDOC(%s,X_%s,\"C_%s\",0,0) = {" kname c-name c-name))
     (dhc-d-to-doc desc)
     (all ((name (reverse c-depends)))
       (sprintf "DH_REFER(%s)," name) )
     (list "DH_NIL" "};" ) ) ) )





;;; ------------------------------------------------------------------------
;;; PARSING A CLASS
;;; ------------------------------------------------------------------------

(de dhc-compile-class-t (fname cname cls)
    (let* ((dhc-debug-stack (cons `(defclass ,fname ...) dhc-debug-stack))
           (slot-dhc-types ())
           (method-list (cdr fname))
	   (fname (car fname))
	   (cname (car cname))
           (tslots (getp cls 'slots))
	   (treetype ())
	   (class-type ())
           (sup-cls (super cls))
	   (sup-name (pname (classname sup-cls))) 
           (sup-type ()) )
      ;; Basic checks
      (when  (classinfo-t (eval fname))
        (error 'dhc-compile-class-t "class has already been compiled" fname))
      (when (<> (length tslots) (length (slots cls)))
        (if (not tslots)
            (dhc-error "class slots are not typed" fname)
          (dhc-error "slots definition are garbled" fname) ) )
      (if  (and (not (classinfo-t sup-cls))
                (not (dhc-search-symtable (classname sup-cls) global-table)) )
          (dhc-error "the superclass must be compiled first" sup-name))
      (setq sup-type (dhc-class-to-dhc-type sup-cls))
      ;; Slot types
      (each ((slot tslots))
        (if (and (listp slot) (listp (car slot)))
            (verify-type-decl-format (car slot))
          (dhc-error "slots types are garbled" tslots)))
      (each ((slot-decl tslots))
        (each ((slot (cdr slot-decl)))
          (setq slot-dhc-types
                (append slot-dhc-types
                        (list (cons slot
                                    :(dhc-format-to-t-node
                                      (car slot-decl)):type))))))
      ;; Check for duplicate names
      (let ((ans ()))
	(each ((i  (mapcar car slot-dhc-types)))
          (if (null (member i ans))
              (setq ans (nconc1 ans i))
            (dhc-error "duplicate slot name found" i))))
      ;; Prepare class type without methods
      (setq class-type (new dhc-type 'dht-class cname 
                            sup-type slot-dhc-types ()))
      (let ((sym (new dhc-symbol fname 0)))
	(dhc-unify-types class-type :sym:type)
	(setq :sym:c-name cname)
	(setq global-table (append global-table
				   (list (cons fname sym)))))
      ;; Process methods
      (each ((method method-list))
        (printf "Parsing method %l in class %l ...\n" method fname)
        (when (not (member method (methods cls)))
          (dhc-error "unknown method for this class" method ) )
        
        (if (= method fname)
            ;; CONSTRUCTOR
            ;; --  install slots in symbol table
            (let ((symbol-table symbol-table)
                  (slot-list (dhu-temps (dhc-obj-type-from-class cls))))
              (each ((slot slot-list))
                (let ((sym (new dhc-symbol (car slot) 0)))
                  (dhc-unify-types (new dhc-type 'dht-unk) :sym:type)
                  (setq :sym:c-name 
                        (concat "L1_this->" 
                                (dhc-lisp-to-c-name (pname (car slot)))) )
                  (setq symbol-table 
                        (append symbol-table (list (cons (car slot) sym))) ) ) )
              ;; -- parse
              (let ((tnode ())
                    (methodname (dhc-lisp-to-c-name (pname method)))
                    (source (funcdef (check==> cls method))) )
                (when (<> (car source) 'lambda)
                  (dhc-error "Cannot compile method not defined with demethod" method) )
                (setq source `(lambda(this ,@(cadr source))
                                (declare (-obj- (,fname)) this)
                                ,@(dhc-pp-all (cddr source)) ))
                (setq tnode (dhc-parse-expr-t source))
                (setq :tnode:source source)
                (setq treetype (append treetype (list (cons method tnode))))
                ;; -- check that all slots are initialized
                (each ((slot slot-list))
                  (let ((sym (dhc-search-symtable (car slot) symbol-table)))
                    (if (and (= 'dht-unk (dhu-tclass :sym:type))
                             (not (==> (cdr slot) is-a-simple)) )
                        (error 'dhc-compile-class-t
                               (concat "class constructor did not "
                                       "intialize a slot with complex type")
                               (list fname (car slot)) ) ) 
                    ;; Unify slot types
                    (dhc-unify-types (cdr slot) :sym:type) ) )
                ;; -- insert into class type method list
                (unode-unify :class-type:u-extra
                             (new-unode
                              (append (unode-val :class-type:u-extra)
                                      (list (cons methodname :tnode:type))))
                             (lambda (a b) b) ) ) )
          ;; REGULAR METHOD
          ;; --  install slots in symbol table
          (let ((symbol-table symbol-table)
                (slot-list (dhu-temps (dhc-obj-type-from-class cls))))
            (each ((slot slot-list))
              (let ((sym (new dhc-symbol (car slot) 0)))
                (dhc-unify-types (cdr slot) :sym:type)
                (setq :sym:c-name 
                      (concat "L1_this->" 
                              (dhc-lisp-to-c-name (pname (car slot)))) )
                (setq symbol-table 
                      (append symbol-table (list (cons (car slot) sym))) ) ) )
            ;; -- parse
            (let ((tnode ())
                  (methodname (dhc-lisp-to-c-name (pname method)))
                  (source (funcdef (check==> cls method))) )
              (when (<> (car source) 'lambda)
                (dhc-error "Cannot compile method not defined with demethod" method) )
              (setq source `(lambda(this ,@(cadr source))
                              (declare (-obj- (,fname)) this)
                              ,@(dhc-pp-all (cddr source)) ))
              (setq tnode (dhc-parse-expr-t source))
              (setq :tnode:source source)
              (setq treetype (append treetype (list (cons method tnode))))
              ;; -- check type of method versus superclass
              (let ((sup-class-meth ()))
                (let ((cl sup-cls)
                      (found ()) )
                  (while (and cl (not found))
                    (setq found (member method (methods cl))) 
                    (setq cl (super cl)) )
                  (when (and cl found)
                    (setq sup-class-meth
                          (dhc-alist-get method 
                                         (dhu-extra 
                                          (dhc-class-to-dhc-type cl))) ) ) )
                (when sup-class-meth
                  ;; Unify arguments
                  (each ((args-sup (cdr (dhu-extra sup-class-meth)))
                         (args-sub (cdr (dhu-extra :tnode:type))))
                    ;; The order of the unification statement is critical!
                    (dhc-unify-types args-sub args-sup))
                  ;; Unify return
                  (dhc-unify-types (dhu-type sup-class-meth)
                                   (dhu-type :tnode:type))
                  ;; Unify temps
                  (if (<> (length (dhu-temps sup-class-meth))
                          (length (dhu-temps :tnode:type)))
                      (dhc-error 
                       "# of temps in method of class and subclass differs"))
                  (each ((temp-sup (cdr (dhu-temps sup-class-meth)))
                         (temp-sub (cdr (dhu-temps :tnode:type))))
                    (let ((tsup (==> temp-sup copy))
                          (tsub (==> temp-sub copy)))
                      (dhc-unify-types tsup tsub)
                      (dhc-unify-types tsub tsup) ) ) ) )
              ;; -- install into class type
              (dhc-add-method-to-class-type class-type 
                                            methodname :tnode:type) ) ) ) )
      ;; Fini
      (list class-type treetype) ) )



;;; ------------------------------------------------------------------------
;;; GENERATING CODE FOR A CLASS
;;; ------------------------------------------------------------------------

(de dhc-compile-class-c(fname cname cls treetype)
  (let* ((class-dhc-type (car treetype))
         (fname (car fname))
         (cname (car cname))
         (c-depends ())
         (c-method ())
         (c-dhdoc ())
         (method-list (dhc-methods-of-class cls))
         (kcsupername ())
         (kcname (sprintf "Kc_%s_R%s" cname (dhu-hash class-dhc-type)))
         (vtname (sprintf "Vt_%s_R%s" cname (dhu-hash class-dhc-type))) )
    ;; find superclass record
    (let ((stype (dhu-type class-dhc-type)))
      (setq kcsupername 
            (if (= (dhu-class stype) :object)
                "Kc_object"
              (sprintf "Kc_%s_R%s" (dhu-name stype) (dhu-hash stype))) ) )
    (dhc-add-c-externs 
     (dhc-class-to-struct-decl class-dhc-type))
    (dhc-add-c-externs 
     (dhc-class-to-vtable-decl class-dhc-type))
    (dhc-add-c-externs 
     (sprintf "extern struct VClass_%s %s;" cname vtname))
    (dhc-add-c-metaexterns 
     (sprintf "extern dhclassdoc_t %s;" kcsupername))
    (dhc-add-c-metaexterns 
     (sprintf "extern dhclassdoc_t %s;" kcname))
    (dhc-add-initialization
     (list (sprintf " dhclass_define(%l, &%s);" (pname fname) kcname)) )
    ;; generate methods
    (each ((treetype (cadr treetype)))
      (let* ((method (car treetype))
             (method-cname (dhc-lisp-to-c-name (pname method)))
             (method-fullname (concat method-cname "_C_" cname))
             (method-tn (cdr treetype)) )
        (printf "Generating C for method %l in class %l ...\n" method fname)
        (dhc-add-program
         (append 
          (list  "" "/*" 
                 (sprintf " * METHOD FUNCTION %l (class %l)" method  fname) 
                 " */")
          (dhc-generate-compiled-func (concat "C_" method-fullname)
                                      :method-tn:source method-tn ) ) )
        (dhc-add-metaprogram
         (append 
          (list "" "/*" 
                (sprintf " * METHOD STUB %l (class %l)" method fname) 
                " */")
          (dhc-generate-interface-func method-fullname method-tn)
          (list "" "/*" 
                (sprintf " * METHOD DHDOC %l (class %l)" method fname) 
                " */")                  
          (dhc-generate-dhdoc-info-func method-fullname 
                                        :method-tn:type) ) )
        (dhc-add-initialization
         (list (sprintf " dhmethod_define(&%s, %l, &K_%s_R%s);"
                        kcname (pname method) method-fullname 
                        (dhu-hash :method-tn:type) )) ) ) )
    ;; generate vtable
    (dhc-add-program
     (append (list  "" "/*" (sprintf " * CLASS %l VTABLE" fname) " */")
             (list  (sprintf "struct VClass_%s %s =" cname vtname) "{" "(dhclassdoc_t*)0," )
             (all ((method method-list))
               (let ((method-type (cdr method))
                     (method-cname (dhc-lisp-to-c-name (car method)))
                     (method-fullname ())
                     (clname ()))
                 ;; retrieve class name
                 (let* ((cltype (dhu-type (dhu-type 
                                           (car (dhu-extra method-type))))))
                   (when (not (==> cltype is-a-class))
                     (error 'dhc-compile-class-c 
                            "internal error : expecting class type") )
                   (setq clname (dhu-name cltype)) )
                 (setq method-fullname
                       (sprintf "C_%s_C_%s" method-cname clname) )   
                 (dhc-add-c-externs
                  (sprintf "extern %s;" 
                           (dhc-compose-prototype method-type 
                                                  method-fullname)) )
                 (sprintf "&%s," method-fullname) ) )
             (list "};") ) )
    ;; generate dhclassdoc
    (dhc-add-metaprogram
     (append (list  "" "/*" (sprintf " * CLASS %l DHCLASSDOC" fname) " */")
             (list (sprintf "DHCLASSDOC(%s, &%s, %s, %l, %s, 0) ="
                            kcname kcsupername cname (pname fname) vtname )
                   "{" 
                   (sprintf "DH_CLASS(%d, %s),"
                            (length (dhu-temps class-dhc-type)) kcname) )
             (flatten
              (all ((slot (dhu-temps class-dhc-type)))
                (let ((slot-cname (dhc-lisp-to-c-name (pname (car slot)))))
                  (cons (sprintf "DH_NAME(%l,%s,%s)," 
                                 slot-cname cname slot-cname )
                        (dhc-d-to-doc (==> (cdr slot) type-to-desc)) ) ) ) )
             (list (sprintf "DH_END_CLASS,"))
             (all ((treetype (cadr treetype)))
               (let* ((method (car treetype))
                      (method-cname (dhc-lisp-to-c-name (pname method)))
                      (method-tn (cdr treetype)) )
                 (sprintf "DH_METHOD(%l,K_%s_C_%s_R%s),"
                          method-cname method-cname cname
                          (dhu-hash :method-tn:type) ) ) )
             (list "DH_NIL" "};") ) ) 
    t ) )



















;;; ------------------------------------------------------------------------
;;; ------------------------------------------------------------------------
;;;          C   O   N   T   R   O   L
;;; ------------------------------------------------------------------------
;;; ------------------------------------------------------------------------





;;; ------------------------------------------------------------------------
;;; USER FUNCTIONS
;;; ------------------------------------------------------------------------


#? (dhc-substitute-env <str> [<htable>])
;; Returns a copy of string <str> after substituting all
;; environment variables.  Substitution values are
;; searched in <htable> when available, then passed
;; to functions <getconf> and <getenv>.
(de dhc-substitute-env (str &optional ht)
  (let ((r ())
        (pos 1)
        (npos ()) )
    ;; Decompose and substitute
    (while (setq npos (regex-seek "\\$[({]?[_A-Za-z][_A-Za-z0-9]*[})]?" str pos))
      (when (> (car npos) pos)
        (setq r (cons (mid str pos (- (car npos) pos)) r)) )
      (let* ((var (regex-subst "[$({})]" "" (mid str (car npos) (cadr npos)) ))
             (subst1 (or (when ht (ht var)) (getconf var)))
             (subst2 (or subst1 (getenv var))) )
        (when (and (not subst1) (= subst2 ""))
          (error 'dhc-substitute-env "Unknown variable" var) )
        (setq r (cons subst2 r)) )
      (setq pos (+ (car npos) (cadr npos))) )
    (setq r (cons (mid str pos) r))
    ;; Reconstruct
    (apply concat (reverse r)) ) )


#? (dhc-make-o <src-file> <obj-file> [<cflags>])
;; Compile C source file <src-file> generated by the 
;; dh compiler into object file <obj-file>.
;; Argument <cflags> is an optional string containing 
;; compiler options or an alist overriding variables
;; defined by <getconf> or <getenv>. 
(de dhc-make-o (src obj &optional cflags)
  (let* ((cmd (sprintf "$CC $DEFS $INCS %s -c %s -o %s"
                       (if (stringp cflags) cflags
                         "$CPPFLAGS $CFLAGS $OPTS $PTHREAD_FLAGS")
                       src obj ))
         (vars (htable)) )
    ;; Additional definitions
    (vars "INCS" (concat "-I" (concat-fname lushdir "include")))
    (when (not (stringp cflags))
      (each (((var . def) cflags))
        (vars var def) ) )
    ;; Print and execute
    (setq cmd (dhc-substitute-env cmd vars))
    (printf "%s\n" cmd)
    (let ((retcode (sys cmd)))
      (when (<> retcode 0)
        (error 'dhc-make-o "Compiler returned error code" retcode) ) )
    t ) )

#? (dhc-make-o-maybe <src-file> <obj-file> [<cflags>])
;; Same as <dhc-make-o> but only recompiles if
;; source file is newer than object file
(de dhc-make-o-maybe(src obj &optional cflags)
  (when (not (filep src))
    (error 'dhc-make-o-maybe "Source file not found" src) )
  (let ((srctime (alist-get 'mtime (fileinfo src)))
        (objtime (alist-get 'mtime (fileinfo obj))) )
    (when (or (not objtime) (<= objtime srctime))
      (dhc-make-o src obj cflags) ) ) )


#? (dhc-make-c <fname> <fsymblist>)
;; Compile functions or classes <fsymblist>
;; into a new source file <fname>.
;; Argument <fname> must be provided without
;; the <".c"> suffix.
(de dhc-make-c(fname fsymblist)
  (let ((strlist ())
        (indent (getconf "INDENT"))
        (cfname (if fname (concat fname "." (or (getconf "CEXT") "c")))) )
    (when (not (listp fsymblist))
      (error 'dhc-make-c "Not a list" fsymblist) )
    (each ((symb fsymblist))
      (when (not (or (symbolp symb)
                     (and (consp symb) (symbolp (car symb))
                          (classp (eval `:,(car symb))) ) ) )
        (error 'dhc-make-c "Not a symbol or a class list" symb) ) )
    (setq strlist 
          (dhc-generate-c (or fname "stdout") fsymblist))
    (writing (if indent
                 (sprintf "| %s -st -gnu -sob -bfda %s" indent
                          (if cfname (concat "> " cfname) "") )
               (or cfname "$stdout") )
      (each ((str strlist))
        (printf "%s\n" str) ) )
    t ) )      


#? (dhc-make-c-maybe <snname> <fname> <fsymblist>)
;; Compile functions or classes <fsymblist>
;; producing the file <fname>.  Argument <fname> 
;; must be provided without the suffix ".c".
;; Compilation will only occur if the existing <fname>
;; was created before the file <snname> or any file
;; loaded from <snname> using <libload>.
(de dhc-make-c-maybe(snname fname fsymblist)
  (when (= snname "$stdin")
    (setq snname ()) )
  (when (stringp snname)
    (setq snname (concat-fname snname))
    (when (not (filep snname))
      (setq snname ()) ) )
  ;; checks
  (when snname
    (let* ((cfname (concat fname "." (or (getconf "CEXT") "c")))
           (cmtime (alist-get 'mtime (fileinfo cfname))) 
           (mtime (alist-get 'mtime (fileinfo snname)))
           (frec ()) )
      ;; compute dependencies
      (when (is-of-class libload.data |HTABLE|)
        (let ((dtable (htable))
              (dfunc  (lambda(fn)
                        (when (not (dtable fn))
                          (dtable fn t)
                          (mapcar dfunc (cdr (libload.data fn))) ) )) )
          (dfunc snname)
          (setq frec (htable-keys dtable)) ) )
      ;; check dependencies
      (when snname
        (when (or (not mtime) (not cmtime) (>= mtime cmtime))
          (setq snname ()) ) )
      (when snname
        (each ((dep frec))
          (let ((mtime (alist-get 'mtime (fileinfo dep))))
            (when (or (not mtime) (>= mtime cmtime))
              (setq snname ()) ) ) ) ) ) )
  ;; compile
  (when (not snname)
    (dhc-make-c fname fsymblist) ) )


#? (dhc-make <fname> <f1> [<f2> ...[<fn>]])
;; Document this!
(dm dhc-make(fn fname . fsymblist) 
  `(dhc-make-all ,fname ',fsymblist ()) )


#? (dhc-make-with-libs <fname> <library-list> <f1> [<f2> ...[<fn>]])
;; Document this
(dm dhc-make-with-libs(fn fname liblist . fsymblist)
  `(dhc-make-all ,fname ',fsymblist ',liblist) )


;; Does the real job
(de dhc-make-all (fname fsymblist liblist)
  (let* ((force ())
         (snname ())
         (sndir ())
         (cdir ())
         (odir ())
         (cfname ())
         (ofname ()) )
    ;; determine snname
    (if (filep file-being-loaded)
        (progn
          (setq snname file-being-loaded)
          (setq sndir (dirname snname)) )
      (setq force t)
      (setq sndir ".")
      (setq snname (last fsymblist))
      (when (consp snname) 
        (setq snname (car snname)))
      (when (not (symbolp snname))
        (error 'dhc-make-all "Cannot determine suitable filename" ()) )
      (setq snname (dhc-lisp-to-c-name (pname snname))) )
    ;; determine fname
    (when (not fname)
      (setq cdir (concat-fname sndir "C"))
      (let ((base (regex-subst "\\.[a-zA-Z0-9]+$" "" (basename snname))))
        (setq fname (concat-fname cdir (dhc-lisp-to-c-name base))) ) )
    (when fname
      (setq fname (regex-subst "\\.[a-zA-Z0-9]+$" "" fname))
      (when (= (dirname fname) ".")
        (setq cdir (concat-fname sndir "C"))
        (setq fname (concat-fname cdir fname)) ) )
    ;; determine cfname and ofname
    (let ((cfname (concat fname "." (or (getconf "CEXT") "c")))
          (ofname (concat fname "." (or (getconf "OBJEXT") "o"))) )
      (when (and cdir (getconf "host"))
        (setq odir (concat-fname cdir (getconf "host"))) 
        (setq ofname (concat-fname odir (basename ofname))) )
      ;; make sure directories exist
      (when (and cdir (not (dirp cdir)))
        (mkdir cdir) )
      (when (and odir (not (dirp odir)))
        (mkdir odir) ) 
      ;; generate
      (dhc-make-c-maybe (if (not force) snname) fname fsymblist)
      (dhc-make-o-maybe cfname ofname)
      ;; mark compiled sources (see module.hook in sysenv.sn)
      (each ((symb fsymblist))
        (when (consp symb) 
          (setq symb (car symb)) )
        (when (symbolp symb)
          (putp (eval `:,symb) 'precious t) ) )
      ;; load
      (mod-load ofname)
      (let ((m (mod-search ofname)))
        (when (not m)
          (error 'dhc-make-all "Module was not loaded!" ()) )
        (when (<> liblist 't)
          (each ((lib liblist))
            (mod-load lib) ) 
          (when (not (module-executable-p m))
            (error 'dhc-make-all "Module has undefined references" ()) ) ) )
      ofname ) ) )

