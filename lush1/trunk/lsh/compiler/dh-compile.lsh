;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; LUSH Lisp Universal Shell
;;;   Copyright (C) 2002 Leon Bottou, Yann Le Cun, AT&T Corp, NECI.
;;; Includes parts of TL3:
;;;   Copyright (C) 1987-1999 Leon Bottou and Neuristique.
;;; Includes selected parts of SN3.2:
;;;   Copyright (C) 1991-2001 AT&T Corp.
;;;
;;; This program is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 2 of the License, or
;;; (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program; if not, write to the Free Software
;;; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; $Id: dh-compile.lsh,v 1.1 2002-07-15 23:22:45 leonb Exp $
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;;; ------------------------------------------------------------------------
;;; ------------------------------------------------------------------------
;;; ------------------------------------------------------------------------
;;;                 D   H   -   C   O   M   P   I   L   E   R
;;; ------------------------------------------------------------------------
;;; ------------------------------------------------------------------------
;;; ------------------------------------------------------------------------


(mload "dh-util"))
(mload "dh-macro"))








;;; ------------------------------------------------------------------------
;;; ------------------------------------------------------------------------
;;;          C O D E    G E N E R A T I O N     U T I L I T I E S
;;; ------------------------------------------------------------------------
;;; ------------------------------------------------------------------------





;;; ------------------------------------------------------------------------
;;; GENERATE C CODE
;;; ------------------------------------------------------------------------



#? (dhc-generate-c <filename> '([<func1> [<funcn>]]))
;; Translate lisp functions and classes <func1>...<funcn> to C code
;; and produces a source file suitable for a file named <filename>.
;; Argument <filename> should be provided without the ".c" suffix
;; and must be a legal C identifier as it is used for the initialization
;; function in the C code.

(de dhc-generate-c (filename fsymb-list)
  (let* ((fname (base-name filename))
         (ifcompiled (mlambda(fdf then . else) then))
         (C-COMPILE t)
         (c-pheader ())
         (c-header ())
         (program ())
         (metaprogram ())
         (initialization-calls ())
         (external-symbols ())
         (external-metasymbols ())
         (lex-level 0)
         (tmpnames-seed 0)
         (static-counter 0)
         (dhc-debug-stack ())
         (lname-list (all ((x fsymb-list))
                       (if (consp x) (mapcar pname x) (pname x))))
         (cname-list (all ((x lname-list))
                       (if (consp x) (mapcar dhc-lisp-to-c-name x)
                         (dhc-lisp-to-c-name x))))
         (func-list  (all ((x fsymb-list))
                       (if (consp x) (eval `:,(car x)) (eval `:,x))) )
         (treetype-list ())
         (source-list ())
         (symbol-table ())    ;; local symbol table
         (global-table ()) )  ;; gobal symbol table
    
    ;; FIRST PASS (MACRO+TYPES)
   (each ((funcname fsymb-list) 
	  (lname lname-list) 
	  (cname cname-list)
	  (func func-list))
     (when (not func)
       (error 'dhc-generate-c "Symbol is undefined" funcname))
     (cond 
      ;; FUNCTION
      ((functionp func)
       (when (and (is-of-class func |DH|)
                  (getp func 'saved) )
         (setq func (getp func 'saved)) )
       (when (not (is-of-class func |DE|))
         (error 'dhc-generate-c "Cannot compile function of this type" funcname) )
       (let (((key arg . body) (funcdef func)))
         (printf "Preprocessing and parsing %s...\n" lname)
         (setq body (dhc-pp-all body))
         ;; Also protect the source from source replacement
         ;;   but give the altered source to the 2nd pass.
         (let ((source (dhc-copy-source-tree `(lambda ,args ,@body))))
           (setq source-list (dhc-alist-add func source-list source))
           (setq treetype-list (cons (dhc-parse-expr-t source) treetype-list))
           ;; Make the new compiled function visible for subsequent function
           (let ((sym (new dhc-symbol funcname 0)))
             (dhc-unify-types :(car treetype-list):type :sym:type)
             (setq :sym:c-name cname)
             (setq global-table (append global-table (list (cons funcname sym)))) ) ) ) )
      ;; CLASS
      ((classp func)
       (printf "Parsing class %s ...\n" (car lname) (cdr lname))
       (setq treetype-list
             (cons (dhc-compile-class-t funcname cname func)
                   treetype-list ) ) )
      ;; ERROR
      (t 
       (error 'dhc-generate-c "cannot compile this object" funcname) ) ) )
   
   ;; SECOND PASS (GENERATION)
   (each ((funcname fsymb-list) 
	  (lname lname-list) 
	  (cname cname-list) 
	  (func func-list)
	  (treetype (reverse treetype-list)))
     (cond
      ;; FUNCTION
      ((functionp func)
       (when (is-of-class func |DH|)
         (setq func (getp func 'saved)) )
       (let ((source (dhc-alist-get func source-list)))
         (printf "Generating C for %s...\n" lname)
         (dhc-add-program 
          (append (list "" "/*" (sprintf " * FUNCTION %s" lname) " */")
                  (dhc-generate-compiled-func (concat "C_" cname) source treetype)) )
         (dhc-add-metaprogram
          (append (list "" "/*" (sprintf " * STUB %s" lname) " */")
                  (dhc-generate-interface-func cname treetype)
                  (list "" "/*" (sprintf " * DHDOC %s" lname) " */")                  
                  (dhc-generate-dhdoc-info-func cname :treetype:type) ) )
         (dhc-add-initialization
          (list (sprintf " dh_define(%l, K_%s_R%08x); " 
                         fname cname (dhu-hash :treetype:type) ) ) ) ) )
      ;; CLASS
      ((classp func)
       (dhc-compile-class-c funcname cname func treetype)
       t ) ) )

   ;; GENERATE THE FULL PROGRAM
   (setq program
         (append
          (dhc-generate-file-header fname)
          (list "" "/* ---------------------------------------- */" "")
          program
          (list "" "/* ---------------------------------------- */" "")
          (list "#ifndef NOLISP" "")
          (if external-metasymbols
              (append (list "/*** DECLARATIONS ***/")
                      (dhc-remove-dup external-metasymbols) 
                      (list "") ) )
          metaprogram
          (list "")
          (dhc-generate-init-call fname)
          (list "" "#endif" "") ) )
   
   ;; CLEANUPS
   (each ((type treetype-list))
     (delete type) )
   (each (((name . type) global-table))
     (delete type) )
   program ) )



;; Make the file header
(de dhc-generate-file-header(filename)
    (append 
     ;; warning
     (list
      "/* WARNING: Automatically generated code."
      " * This code has been generated by the DH compiler."
      " */")
     ;; pheaders
     (if c-pheader
         (cons "/*** USER DEFINED HEADERS (pheader) ***/"
               (dhc-remove-dup c-pheader) ) )
     ;; lush headers
     (cons "/*** LUSH HEADERS ***/"
           (list "#include \"header.h\""
                 "#include \"dh.h\""
                 "#include \"idxmac.h\""
                 "#include \"idxops.h\""
                 "#include \"check_func.h\"" ) )
     ;; other headers
     (if c-header
         (cons "/*** USER DEFINED HEADERS  (cheader) ***/"
               (dhc-remove-dup c-header) ) )
     ;; externals
     (list "")
     (if external-symbols
         (cons "/*** DECLARATIONS ***/"
               (dhc-remove-dup external-symbols) ) )
     (list "") ) )


;; Make the initialisation routine
(de dhc-generate-init-call( filename )
  (append
   (list  "/*"
          " * INIT FUNCTION"
          " */" )
   (list (sprintf "void init_%s(void)" filename)
         "{" )
   initialization-calls
   (list "}"
         ""
         (sprintf "int majver_%s = %d;" filename (getconf "LUSH_MAJOR"))
         (sprintf "int minver_%s = %d;" filename (getconf "LUSH_MINOR"))
         "" ) ) )





;;; ------------------------------------------------------------------------
;;; PARSING FUNCTION DEFINITIONS
;;; ------------------------------------------------------------------------

(dhm-t lambda(source)
  (let (((lamb arguments .  body) source)
        (symbol-table symbol-table)
        (bump-list ())
        (arg-list ())
        (arg-treetype ())
        (tmpnames-seed tmpnames-seed)
        (return-type (new dhc-type 'dht-unk))
        (treetype ()))
    (setq arg-list 
          (all ((arg arguments)) (dhc-add-symbol-table arg 1)))
    (setq arg-treetype 
          (all ((symb arg-list) (arg arguments))
            (new t-node () :symb:type arg symb)))uy
            (let ((split ()))
              (let ((new-symbol-table symbol-table)
                    (symbol-table symbol-table)
                    (lex-level (1+ lex-level))
                    (bump-list ()))
                (setq treetype (dhc-parse-progn-t body))
                (dhc-assign-unify return-type :treetype:type)
                ;; if number, unify the type (if return is an int we want an int)
                (if (==> :treetype:type is-a-number)
                    (dhc-unify-types return-type :treetype:type))
                (let ((returnpoint (dhc-gather-types return-type t)))
                  (each ((arg arg-list))  
                    (setq returnpoint
                          (nconc returnpoint 
                                 (dhc-gather-types :arg:type ()))))
                  (each ((point returnpoint))
                    (==> point bump-level 0)) )
                (setq split 
                      (dhc-split-list bump-list 
                                      (lambda (x) (< (==> :x:type bump-level)
                                                     lex-level))))
                (setq :treetype:symbol (cadr split))
                (setq split (car split)))
              (setq bump-list (append bump-list split)))
            (setq :treetype:type (new dhc-type 'dht-func
                                      (all ((symb arg-list)) :symb:type)
                                      (all ((symb bump-list)) 
                                        :symb:type)
                                      return-type))
            ;; The variables which are bumped out are stored in symbol of args.
            (setq :treetype:tn-list 
                  (cons (new t-node arg-treetype (new dhc-type 'dht-unk) 
                             () bump-list)
                        :treetype:tn-list))
            treetype ) )

(dhm-c lambda(source treetype retplace)
  (dhc-error "The dhm-c for function lambda should never be called") )



;;; ------------------------------------------------------------------------
;;; GENERATING OF C FUNCTION COMPONENTS
;;; ------------------------------------------------------------------------


(de dhc-generate-prologue(c-name treetype)
  (let* ((functype :treetype:type)
         (rettype (unode-val :functype:u-type))
         (temp-list :(cadr :treetype:tn-list):symbol)
         (temp-list-type (all ((x temp-list)) :x:type))
         (arg-list (all ((x :(cadr :treetype:tn-list):tn-list)) :x:symbol))
         (arg-list-type (all ((x arg-list)) :x:type )) )
    ;; pointerify temporaries
    (setq temp-list-type
          (all ((arg temp-list-type))
            (if (not (==> arg is-a-ptr))
                (new dhc-type 'dht-ptr arg)
              arg ) ) )
    ;; build prototype
    (concat (dhc-type-to-c-decl rettype) 
            " " c-name "("
            (dhc-insert-op 
             (all ((symb-name (append arg-list temp-list))
                   (symb-type (append arg-list-type temp-list-type)) )
               (concat (dhc-type-to-c-decl symb-type) " " :symb-name:c-name) )
             "," ) 
            ")"  ) ) )

;; This is the main entry point of the 
;; code generation in the compiler...
(de dhc-generate-compiled-func(cname source treetype)
  (let ((c-prologue ())	
        (c-declarations ())
        (c-statements ())
        (c-epilog ())
        (tmpnames-seed tmpnames-seed)
        (label-seed 0)
        ((lam args . body-treetype) :treetype:tn-list))
    
    (setq c-prologue (dhc-generate-prologue cname treetype))
    ;; generate return statement
    (let ((ret (dhc-bumped-block body-treetype ()
                                 (dhc-parse-progn-c (cddr source)
                                                    body-treetype ()))))
      (if (==> :(caddr :treetype:tn-list):type is-a-nil)
          (setq c-epilog (nconc1 c-epilog "return 0;"))
        (setq c-epilog (nconc1 c-epilog (sprintf "return %s;" ret))) ) )
    ;; Return program (as a list of lines)
    (append c-prologue 
            (list "{" (sprintf "TRACE_PUSH(\"%s\");" cname) "{")
            c-declarations 
            c-statements 
            (list (sprintf "TRACE_POP(\"%s\");" cname))
            c-epilog
            (list "}" "}") ) ) )


(de dhc-generate-interface-func(c-name treetype)
  (let ((pro (sprintf "DH(X_%s)" prefix c-name))
        (call (list "ret." (dhc-arg-format (dhu-type :treetype:type)) " = "
                    (if (==> (dhu-type :treetype:type) is-an-objptr) "(int *)" "" )
                    (sprintf " C%s_" prefix) c-name "(" ))
        ((lam args . body-treetype) :treetype:tn-list)
        (arg-list ())
        (num 0) )
    ;; take care arguments and temporaries
    (each ((sym (all ((x :args:tn-list)) :x:symbol)))
      (let ((format (concat "a[%d]." (dhc-arg-format :sym:type))))
        (setq arg-list (nconc1 arg-list (sprintf format (incr num))))))
    (each ((sym :(cadr :treetype:tn-list):symbol))
      (let* ((type (if (==> :sym:type is-a-ptr) :sym:type (new dhc-type 'dht-ptr :sym:type))) 
             (format  (concat "a[%d]." (dhc-arg-format type))) )
        (setq arg-list (nconc1 arg-list (sprintf format (incr num))))))
    (setq call (nconc1 call (dhc-insert-op arg-list ", ")))
    (list pro "{" "dharg ret;" (concat (apply concat call) ");") 
          "return ret;" "}" ) ) )


(de dhc-generate-dhdoc-info-func(c-name functype)
  (let* ((desc (==> functype type-to-desc))
         (kname (sprintf "K_%s%s_R%08x" c-name prefix (dhu-hash functype)))
         (c-depends (dhc-remove-dup c-depends)) )
    (append
     (list (sprintf "DHDOC(%s,X_%s,\"C_%s\",0,0) =" c-name c-name c-name) "{")
     (dhc-d-to-doc desc)
     (all ((name (reverse c-depends)))
       (sprintf "DH_REFER(%s)," name) )
     (list "DH_NIL" "};" ) ) ) )





;;; ------------------------------------------------------------------------
;;; PARSING A CLASS
;;; ------------------------------------------------------------------------

(de dhc-compile-class-t (fname cname source cls)
    (let* ((method-list (cdr fname))
	   (fname (car fname))
	   (cname (car cname))
           (tslots (getp cls 'slots))
	   (treetype ())
	   (class-type ())
           (sup-cls (super cls))
	   (sup-name (pname (classname sup-cls))) 
           (sup-type ()) )
      ;; Basic checks
      (when  (classinfo-t (eval fname))
        (error 'dhc-compile-class-t "class has already been compiled" fname))
      (when (<> (length tslots) (length (slots cls)))
        (if (not tslots)
            (error 'dhc-compile-class-t "class slots are not typed" fname)
          (error 'dhc-compile-class-t "slots definition are garbled" fname) ) )
      (if  (or (not (classinfo-t sup-cls))
               (not (dhc-search-symtable (classname sup-cls) global-table)) )
          (dhc-error "the superclass must be compiled first" sup-name))
      (setq sup-type (dhc-class-to-dhc-type sup-cls))
      ;; Slot types
      (each ((slot tslots))
        (if (and (listp slot) (listp (car slot)))
            (verify-type-decl-format (car slot))
          (error 'dhc-compile-class-t "slots types are garbled" tslots)))
      (each ((slot-decl tslots))
        (each ((slot (cdr slot-decl)))
          (setq slot-dhc-types
                (append slot-dhc-types
                        (list (cons slot
                                    :(dhc-format-to-t-node
                                      (car slot-decl)):type))))))
      ;; Check for duplicate names
      (let ((ans ()))
	(each ((i  (mapcar car slot-dhc-types)))
          (if (null (member i ans))
              (setq ans (nconc1 ans i))
            (dhc-error "duplicate slot name found" i))))
      ;; Prepare class type without methods
      (setq class-type (new dhc-type 'dht-class cname sup-type slot-dhc-types ()))
      (let ((sym (new dhc-symbol fname 0)))
	(dhc-unify-types class-type :sym:type)
	(setq :sym:c-name cname)
	(setq global-table (append global-table
				   (list (cons fname sym)))))
      ;; Process methods
      (each ((method method-list))
        (printf "Parsing method %l in class %l ...\n" method fname)
        (when (not (member method (methods cls)))
          (error 'dhc-compile-class-t
                 (sprintf "not a method of class %l" fname) method ) )
        
        (if (= method fname)
            ;; CONSTRUCTOR
            ;; --  install slots in symbol table
            (let ((symbol-table symbol-table)
                  (slot-list (dhu-temps (dhc-obj-type-from-class cls))))
              (each ((slot slot-list))
                (let ((sym (new dhc-symbol (car slot) 0)))
                  (dhc-unify-types (new dhc-type 'dht-unk) :sym:type)
                  (setq :sym:c-name 
                        (concat "L1_this->" (dhc-lisp-to-c-name (pname (car slot)))) )
                  (setq symbol-table 
                        (append symbol-table (list (cons (car slot) sym))) ) ) )
              ;; -- parse
              (let ((tnode ())
                    (methodname (dhc-lisp-to-c-name (pname method)))
                    (source (funcdef (check==> cls method))) )
                (when (not (is-of-class funcdef |DE|))
                  (error 'dhc-compile-class-t
                         "Cannot compile method not defined with demethod"
                          (list fname method) ) )
                (setq source `(lambda(this ,@(cadr source))
                                ((-obj- (,fname)) this)
                                ,@(dhc-pp-all (cddr source)) ))
                (setq tnode (dhc-parse-expr-t source))
                (setq :tnode:source source)
                (setq treetype (append treetype (list (cons method tnode))))
                ;; -- check that all slots are initialized
                (each ((slot slot-list))
                  (let ((sym (dhc-search-symtable (car slot) symbol-table)))
                    (if (and (= 'dht-unk (dhu-tclass :sym:type))
                             (not (==> (cdr slot) is-a-simple)) )
                        (error 'dhc-compile-class-t
                               "class constructor did not intialize a slot with complex type"
                               (list fname (car slot)) ) ) 
                    ;; Unify slot types
                    (dhc-unify-types (cdr slot) :sym:type) ) )
                ;; -- insert into class type method list
                (unode-unify :class-type:u-extra
                             (new-unode
                              (append (unode-val :class-type:u-extra)
                                      (list (cons methodname :tnode:type))))
                             (lambda (a b) b) ) ) )
          ;; REGULAR METHOD
          ;; --  install slots in symbol table
          (let ((symbol-table symbol-table)
                (slot-list (dhu-temps (dhc-obj-type-from-class cls))))
            (each ((slot slot-list))
              (let ((sym (new dhc-symbol (car slot) 0)))
                (dhc-unify-types (new dhc-type 'dht-unk) :sym:type)
                (setq :sym:c-name 
                      (concat "L1_this->" (dhc-lisp-to-c-name (pname (car slot)))) )
                (setq symbol-table 
                      (append symbol-table (list (cons (car slot) sym))) ) ) )
            ;; -- parse
            (let ((tnode ())
                  (methodname (dhc-lisp-to-c-name (pname method)))
                  (source (funcdef (check==> cls method))) )
              (when (not (is-of-class funcdef |DE|))
                (error 'dhc-compile-class-t
                       "Cannot compile method not defined with demethod"
                       (list fname method) ) )
              (setq source `(lambda(this ,@(cadr source))
                              ((-obj- (,fname)) this)
                              ,@(dhc-pp-all (cddr source)) ))
              (setq tnode (dhc-parse-expr-t source))
              (setq :tnode:source source)
              (setq treetype (append treetype (list (cons method tnode))))
              ;; -- check type of method versus superclass
              (let ((sup-class-meth ()))
                (let ((cl sup-cls)
                      (found ()) )
                  (while (and cl (not found))
                    (setq found (member method (methods cl))) 
                    (setq cl (super cl)) )
                  (when (and cl found)
                    (setq sup-class-meth
                          (dhc-alist-get method (dhu-extra (dhc-class-to-dhc-type cl))) ) ) )
                (when sup-class-meth
                  ;; Unify arguments
                  (each ((args-sup (cdr (dhu-extra sup-class-meth)))
                         (args-sub (cdr (dhu-extra :tnode:type))))
                    ;; The order of the unification statement is critical!
                    (dhc-unify-types args-sub args-sup))
                  ;; Unify return
                  (dhc-unify-types (dhu-type sup-class-meth)
                                   (dhu-type :tnode:type))
                  ;; Unify temps
                  (if (<> (length (dhu-temps sup-class-meth))
                          (length (dhu-temps :tnode:type)))
                      (dhc-error "# of temps in method of class and subclass differs"))
                  (each ((temp-sup (cdr (dhu-temps sup-class-meth)))
                         (temp-sub (cdr (dhu-temps :tnode:type))))
                    (let ((tsup (==> temp-sup copy))
                          (tsub (==> temp-sub copy)))
                      (dhc-unify-types tsup tsub)
                      (dhc-unify-types tsub tsup) ) ) ) )
              ;; -- install into class type
              (dhc-add-method-to-class-type class-type methodname :tnode:type) ) ) ) )
      ;; Fini
      (list class-type treetype) ) )



;;; ------------------------------------------------------------------------
;;; GENERATING CODE FOR A CLASS
;;; ------------------------------------------------------------------------

(de dhc-compile-class-c(fname cname cls treetype)
  (let* ((class-dhc-type (car treetype))
         (fname (car fname))
         (cname (car cname))
         (c-depends ())
         (c-method ())
         (c-dhdoc ())
         (method-list (dhc-methods-of-class cls))
         (kcsupername ())
         (kcname (sprintf "Kc_%s_R%08x" cname (dhu-hash class-dhc-type)))
         (vtname (sprintf "Vt_%s_R%08x" cname (dhu-hash class-dhc-type))) )
    
    (let ((stype (dhu-type class-dhc-type)))
      (setq kcsupername (sprintf "Kc_%s_R%08x" (dhu-name stype) (dhu-hash stype))) )
    (dhc-add-c-externs (dhc-class-to-vtable-decl class-dhc-type))
    (dhc-add-c-externs (dhc-class-to-struct-decl class-dhc-type))
    (dhc-add-c-externs (sprintf "extern struct VClass_%s %s;" cname vtname))
    (dhc-add-c-metaexterns (sprintf "extern struct dhclassdoc_t %s;" kcsupername))
    (dhc-add-c-metaexterns (sprintf "extern struct dhclassdoc_t %s;" kcname))
    (dhc-add-initialization
     (list (sprintf " dhclass_define(%l, &%s);" fname kcname)) )
    ;; generate methods
    (each ((treetype (cadr treetype)))
      (let* ((method (car treetype))
             (method-cname (dhc-lisp-to-c-name (pname method)))
             (method-fullname (concat "C_" method-cname "_C_" cname))
             (method-tn (cdr treetype)) )
        
        (printf "Generating C for method %l in class %l ...\n" method fname)
        (dhc-add-program
         (append (list  "" "/*" (sprintf " * METHOD FUNCTION %l (class %l)" method  fname) " */")
                 (dhc-generate-compiled-func method-fullname
                                             :method-tn:source method-tn ) ) )
        (dhc-add-metaprogram
         (append (list "" "/*" (sprintf " * METHOD STUB %l (class %l)" method fname) " */")
                 (dhc-generate-interface-func method-fullname method-tn)
                 (list "" "/*" (sprintf " * METHOD DHDOC %l (class %l)" method fname) " */")                  
                 (dhc-generate-dhdoc-info-func method-fullname :method-tn:type) ) )
        (dhc-add-initialization
         (list (sprintf " dhmethod_define(&%s, %l, &K_%s_R%08x);"
                        kcname method method-fullname (dhu-hash :method-tn:type) )) ) ) )
    ;; generate vtable
    (dhc-add-program
     (append (list  "" "/*" (sprintf " * CLASS %l VTABLE" fname) " */")
             (list  (sprintf "struct VClass_%s %s =" cname vtname) "{" )
             (all ((method method-list))
               (let ((method-type (cdr method))
                     (method-cname (dhc-lisp-to-c-name (pname method)))
                     (method-fullname ())
                     (clname ()))
                 ;; retrieve class name
                 (let* ((cltype (dhu-type (dhu-type (car (dhu-extra method-type))))))
                   (when (not (==> cltype is-a-class))
                     (error 'dhc-compile-class-c "internal error : expecting class type") )
                   (setq clname (dhu-name cltype)) )
                 (setq method-fullname
                       (sprintf "C_%s_%s" method-cname clname) )   
                 (dhc-add-c-externs
                  (sprintf "extern %s;" (dhc-compose-prototype method-type method-fullname)) )
                 (sprintf "&%s," method-fullname) ) )
             "};" ) )
    ;; generate dhclassdoc
    (dhc-add-metaprogram
     (append (list  "" "/*" (sprintf " * CLASS %l DHCLASSDOC" fname) " */")
             (list (sprintf "DHCLASSDOC(%s, %s, %s, %l, %s, 0) ="
                            kcname kcsupername cname fname vtname )
                   "{" 
                   (sprintf "DH_CLASS(%d, %s)"
                            (length (dhu-temps class-dhc-type)) kcname) )
             (all ((slot (dhu-temps class-dhc-type)))
               (cons (sprintf "DH_NAME(%l,%s,%s)," 
                              (car slot) cname (car slot) )
                     (dhc-d-to-doc (==> (cadr slot) type-to-desc)) ) )
             (list (sprintf "DH_END_CLASS,"))
             (all ((treetype (cadr treetype)))
               (let* ((method (car treetype))
                      (method-cname (dhc-lisp-to-c-name (pname method)))
                      (method-tn (cdr treetype)) )
                 (sprintf "DH_METHOD(%l,&K_%s_C_%s_R%08x),"
                          method-cname method-cname cname (dhu-hash :method-tn:type) ) ) )
             (list "DH_NIL" "};") ) ) 
    t ) )
















;;;;;HERE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;HERE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;HERE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;HERE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;HERE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;HERE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;HERE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;HERE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;HERE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;HERE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;HERE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;HERE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


















;;; ------------------------------------------------------------------------
;;; ------------------------------------------------------------------------
;;;          C   O   N   T   R   O   L
;;; ------------------------------------------------------------------------
;;; ------------------------------------------------------------------------





;;; ------------------------------------------------------------------------
;;; USER FUNCTIONS
;;; ------------------------------------------------------------------------

(setq dhc-pretty-c "indent \
   -npro -bap -bad -nbc -bl -cli0 -d0 -eei \
   -i2 -lp -nip -di1 -pcs -psl -sc -sob -st \
")

(setq dhc-pretty-c "indent -st -gnu -sob -bfda ")

(setq dhc-cname (getenv "SN31_CC"))
(if (= dhc-cname "") 
    (setq dhc-cname
          (selectq :operating-system 
            (solaris   "gcc")
            (solaris86 "gcc")
            (sgi       "cc")
            (t         "cc") ) ) )

(setq dhc-cflags (getenv "SN31_CFLAGS"))
(if (= dhc-cflags "") 
    (setq dhc-cflags 
          (if (= dhc-cname "gcc")
              (selectq :operating-system 
                (solaris86  "-O2 -m486 -ffast-math")
                (sgi        "-O2 -mcpu=r4400 -ffast-math")
                (t          "-O2 -ffast-math") )
            (selectq :operating-system 
              (sunos     "-fsingle -O4")
              (sgi       "-O -float")
              (t         "-O") ) ) ) )

#? (dhc-make-o <src-file> <obj-file> [<cflags>])
;; compile C source file <src-file> generated by the dh compiler 
;; into object file <obj-file>.
;; <cflags> is an optional string containing cc options.
;; if no <cflag> is provided, the value of the variable dhc-cflags is used.
;; the initial value for dhc-cflags is "-O4".
(de dhc-make-o (src obj &optional cflags)
    (when ~dhc-include (setq dhc-include "."))
    (sys (print (concat dhc-cname 
                        " -I" sn3-dir 
                        "include -I" dhc-include  " -c -D" 
                        (upcase (pname :operating-system)) " "
                        (if cflags cflags dhc-cflags ) " -o " obj " " src))))

#? (dhc-makeo <src-file> <obj-file> [<cflags>])
;; compile C source file <src-file> generated by the dh compiler
;; into object file <obj-file>, if <src-file> is more recent than
;; <obj-file>.  <cflags> is an optional string containing cc options.
;; if no <cflag> is provided, the value of the variable dhc-cflags is used.
;; the initial value for dhc-cflags is "-O4".
(de dhc-makeo (src obj &optional cflags)
        (if (file-newerp src obj) (dhc-make-o src obj cflags)))




#? (cfile-compile-and-load <c-file> <compile-command>)
;;.VP
;; ((-str-) c-file) Name of a C-code file
;; ((-str-) compile-command) Command to use for the compilation
;; CREATED: Pascal Vincent 04/11/96
;; COMPILABLE: No
;; RETURNS: ()
;;
;; DESCRIPTION: Looks for the given c-file, compiles it if necessary, 
;;              and mod-loads the resulting .o files
;;              This way of processing gives a support for portability across
;;              systems, since the .o files are generated and then mod-loaded from
;;              a subdirectory corresponding to the current system (ex: OBJS/SUNOS)
;;              It should be used for native C code rather than the older method (that consisted 
;;              in compiling the .c file outside of SN and mod-loading the resulting .o file)
;;              However it should not be used to compile SN-generated C. This is the role of dhc-make.
;;
;; The c-file is looked for in:
;;         - the directory of the file-being-loaded
;;         - the current directory
;;         - the SN path
;;
;; All subsequent operations take place in the directory of the found c-file
;; 
;; The corresponding .o file is determined from the c-file and considered to be
;; in subdirectory OBJS/name-of-the-operating-system
;;
;; If the .c file is more recent than the .o file, then it gets recompiled with command
;;  <compile-command> OBJS/name-of-the-operating-system/o-file c-file
;;
;; The .o file is then mod-loaded (a mod-unload is called beforehand if necessary)
;; 
;; EXAMPLE: Suppose there is a file animate.c in directory /home/mickey/CC/ and that this
;;          directory is in the SN path (it was for ex. added with addpath)
;;          A call to (cfile-compile-and-load "mouse.c" "cc -c -o") under Sun OS will:
;;             - compare last modification dates of /home/mickey/CC/mouse.c 
;;               with /home/mickey/CC/OBJS/SUNOS/mouse.o
;;             - if a recompilation is necessary, it will issue command:
;;                 cd /home/mickey/CC; cc -c -o OBJS/SUNOS/mouse.o mouse.c
;;             - it then mod-loads /home/mickey/CC/OBJS/SUNOS/mouse.o
;;
;;.SEE (g++-load <c++-file> [<options>])
;;.SEE (cc-load <c-file> [<cc-options>])
;;.SEE (c-include <include-file>)
(de cfile-compile-and-load (cfilename compilecommand)
    ((-str-) cfilename compilecommand)
    (let ((abscfile (findfile cfilename))
          (cfile "")
          (sourcedir "")
          (ofile "")
          (absofile "")
          )
      (when ~abscfile
        (error (concat "Error: couldn't find file " cfilename)))

      (printf "[%s]\n" abscfile)

      (setq sourcedir (dir-name abscfile))
      (setq cfile (file-name abscfile))

      (mkdir (concat sourcedir "OBJS/")) ;; creates the dir if it does not already exist
      (mkdir (concat sourcedir "OBJS/" :os-string)) ;; creates the dir if it does not already exist
      (setq ofile (concat "OBJS/" :os-string "/" (change-suffix cfile ".o")))
      (setq absofile (concat sourcedir ofile))

      (when (file-newerp abscfile absofile)
        (printf "In %s --> %s %s %s\n" sourcedir compilecommand ofile cfile)
          (when (<> 0 (sys (sprintf "cd %s; %s %s %s\n" sourcedir compilecommand ofile cfile)))
            (error "Error during C compilation")))

      ;; load or reload object file
      (when (member absofile (mod-list))
        (mod-unload absofile))
      (mod-load absofile))
    () )

#? (cc-load <c-file> [<cc-options>])
;;.VP
;; ((-str-) c-file) Name of a C-code file
;; ((-str-) cc-options) Additional options to be passed on the compile command-line
;;
;; CREATED: Pascal Vincent 04/11/96
;; COMPILABLE: No
;; RETURNS: ()
;;
;; DESCRIPTION: Looks for the given c-file, compiles it if necessary, 
;;              and mod-loads the resulting .o files
;;
;; This function should be called instead of a mod-load of a .o file
;; for using C-written code (i.e. when the .c source file is available)
;; but NOT for SN-generated C (this is the role of dhc-make) 
;; The method offers several advantages:
;;    - it looks for the .c file in several places: 
;;         + the directory of the file-being-loaded
;;         + the current directory
;;         + the SN path
;;    - it automatically recompiles the .c file if it was changed
;;    - it offers support for cross-architecture portability: 
;;         + the .o files are generated to and mod-loaded from the sub directory 
;;           OBJS/name_of_operating_system of the directory where the .c file was found
;;         + the compiler is called with option -Dname_of_operating_system, so one could
;;           for example use a #ifdef SUNOS to do system-specific operations
;;
;;.SEE (g++-load <c++-file> [<options>])
;;.SEE (cfile-compile-and-load <c-file> <compile-command>)
;;.SEE (c-include <include-file>)
(de cc-load (cfilename &optional optlist)
    ((-str-) cfilename)
    (when (not (stringp optlist))
      (setq optlist ""))
    (cfile-compile-and-load cfilename (sprintf "%s -I%sinclude -Iinclude %s -c -D%s %s -o " dhc-cname sn3-dir optlist :os-string dhc-cflags))
    () )

#? (gcc-load <c-file> [<cc-options>])
;;.VP
;; ((-str-) c-file) Name of a C-code file
;; ((-str-) cc-options) Additional options to be passed on the compile command-line
;;
;; CREATED: Pascal Vincent 04/11/96
;; COMPILABLE: No
;; RETURNS: ()
;;
;; DESCRIPTION: same as cc-load but systematically uses the gnu gcc compiler
;;
;;.SEE (cc-load <c-file> [<cc-options>])
;;.SEE (c-include <include-file>)
(de gcc-load (cfilename &optional optlist)
    ((-str-) cfilename)  
    
    (when (not (stringp optlist))
      (setq optlist ""))
    (if (= operating-system 'solaris86)
        (cfile-compile-and-load cfilename (sprintf "gcc -c -D%s -I%sinclude -I../include %s -O2 -ffast-math -m486 -o " :os-string sn3-dir optlist))
      (cfile-compile-and-load cfilename (sprintf "gcc -c -D%s -I%sinclude -I../include %s -O2 -ffast-math -o " :os-string sn3-dir optlist)))
    () )

#? (g++-load <c++-file> [<options>])
;;.VP
;; ((-str-) c++-file) Name of a C++-code file
;; ((-str-) options) Additional options to be passed on the compile command-line
;;
;; CREATED: Yoshua Bengio 08/13/96
;; COMPILABLE: No
;; RETURNS: ()
;;
;; DESCRIPTION: same as cc-load but systematically uses the gnu g++ compiler
;;
;;.SEE (gcc-load <c-file> [<cc-options>])
;;.SEE (cc-load <c-file> [<cc-options>])
;;.SEE (c-include <include-file>)
(de g++-load (cfilename &optional optlist)
    ((-str-) cfilename)
    (when (not (stringp optlist))
      (setq optlist ""))
    (if (= operating-system 'solaris86)
        (cfile-compile-and-load cfilename (sprintf "g++ -c -D%s -I%sinclude -Iinclude %s -O2 -ffast-math -m486 -o " :os-string sn3-dir optlist))
      (cfile-compile-and-load cfilename (sprintf "g++ -c -D%s -I%sinclude -Iinclude %s -O2 -ffast-math -o " :os-string sn3-dir optlist)))
    () )

#? (c-include <include-file>)
;;.VP
;; MACRO
;; CREATED: Pascal Vincent 04/18/96
;; DESCRIPTION: This macro is an interface to macro cheader, allowing to 
;;              add personal includes in the header of the SN-generated C file.
;;              The difference between (cheader "#include \"myheader.h\"")
;;              and (c-include "myheader.h") is that, in the latter,
;;              it is searched for file myheader.h in several places (see findfile)
;;              Thus if for example myheader.h is in /usr/ocr/C-Source and /usr/ocr/C-Source
;;              is part of the SN path, then call (c-include "myheader.h") will be expanded into
;;              (cheader "#include \"/usr/ocr/C-Source/myheader.h\"")
;; NOTICE: one should not use c-include to include standard-includes (such as <stdio.h>)
;;         use (cheader "#include <the-std-include.h>") instead.
;;
;;.SEE (cheader <s1> [...<sn>])
;;.SEE (findfile <filename>)   
(dm c-include (junk filename)
    ((-str-) filename)
    (list 'cheader (concat "#include \"" (findfile filename) "\"\n")))


#? (dhc-make <fname> <f1> [<f2> ...[<fn>]])
;;.VP
;; translate functions <f1>...<fn> to C into file <fname>.c, compile 
;; <fname>.c to <fname>.o and load it.
;; If dhc-make is called from within a file being loaded (say f.sn), the time and
;; date of last modification of f.sn is compared to that of <fname>.c and
;; <fname>.o. If <fname>.o is more recent, it is loaded without recompilation.
;; If the .o is older or does not exist, the .c is recompiled.
;; of course, if the .c is older or does not exist it is regenerated.
;; If <fname> is nil, or the empty string, the name of the current file 
;; being loaded is used, after transformation to a legal C identifier (this
;; is necessary because 
;; if the file being loaded is stdin and no filename is given, the code is written
;; in a file whose name is a C-ified version of the last argument <fn>).
;;
;; MODIFIED: Pascal Vincent 04/10/96 
;;    If a directory C exists, generated .c files are put inside
;;    If a directory OBJS exists, .o files are put in directory OBJS/name_of_operating_system

(df dhc-make ( fname . fsymb-list) 
  (setq fname (eval fname))
  (let* ((forceit ())
         (snname (if (= "$stdin" file-being-loaded) 
                     (progn (setq forceit t) 
                            (if (consp (last fsymb-list))
                                (pname (car (last fsymb-list)))
                              (pname (last fsymb-list))))
                   file-being-loaded))
         (snname-dir (dir-name snname))
         (snname-base (base-name snname))
         ;; name of C file must be a legal C symbol
         (cname (concat
                 (dhc-lisp-to-c-name 
                  (if (and fname (<> "" fname)) 
                      fname 
                    snname-base))
                 ".c"))
         (oname  (change-suffix cname ".o"))
         (src-list (all ((sym fsymb-list))
                     (if (consp sym)  (eval (car sym)) (eval sym))))
         )
    (if (not (dir-existsp (concat snname-dir "C")))
        (setq cname (concat snname-dir cname))
      (setq cname (concat snname-dir "C/" cname)))

    (if (and (= :operating-system 'sunos) (not (dir-existsp (concat snname-dir "OBJS"))) )
        (setq oname (concat snname-dir oname))
      (mkdir (concat snname-dir "OBJS")) ;; creates it if it does not already exist
      (mkdir (concat snname-dir "OBJS/" :os-string))  ;; creates it if it does not already exist 
      (setq oname (concat snname-dir "OBJS/" :os-string "/" oname)))
    
    ;; Look if .o is ancient or does not exist
    (if (not (file-existsp (concat sn3-dir "src/OBJS/" 
                                   :os-string "/touch-to-recompile")))
	(error (sprintf "A file named touch-to-recompile must exist in %ssrc/OBJS/%s"
			sn3-dir :os-string)))
    (when (and (not forceit) (file-existsp oname))
      (when (file-newerp (concat sn3-dir "src/OBJS/" :os-string 
                                 "/touch-to-recompile") cname)
	(setq forceit t) ) )
    (when (or forceit (file-newerp snname cname))
      ;; generate C file
      (dhc-make-c cname fsymb-list) )
    (when (or forceit (file-newerp cname oname))
      ;; generate object file
      (when (<> (dhc-make-o cname oname) 0)
	(error "Error during C compilation") ) )	
    ;; load object file
    (dhc-load oname fsymb-list) ) )


(ifdef sta-dir 
(df dhc-make ( fname . fsymb-list) 
  (setq fname (eval fname))
  (let* ((forceit ())
         (snname (if (= "$stdin" file-being-loaded) 
                     (progn (setq forceit t) 
                            (if (consp (last fsymb-list))
                                (pname (car (last fsymb-list)))
                              (pname (last fsymb-list))))
                   file-being-loaded))
         (snname-dir (dir-name snname))
         (snname-base (base-name snname))
         ;; name of C file must be a legal C symbol
         (cname (concat
                 (dhc-lisp-to-c-name 
                  (if (and fname (<> "" fname)) 
                      fname 
                    snname-base))
                 ".c"))
         (oname  (change-suffix cname ".o"))
         (src-list (all ((sym fsymb-list))
                     (if (consp sym)  (eval (car sym)) (eval sym))))
         )
    
    (mkdir (concat sta-dir "C")) ;; creates it if it does not already exist
    (setq cname (concat sta-dir "C/" cname))
    
    (mkdir (concat sta-dir "OBJS")) ;; creates it if it does not already exist
    (mkdir (concat sta-dir "OBJS/" :os-string))  ;; creates it if it does not already exist 
    (setq oname (concat sta-dir "OBJS/" :os-string "/" oname))
    
    ;; Look if .o is ancient or does not exist
    (if (not (file-existsp (concat sn3-dir "src/OBJS/" 
                                   :os-string "/touch-to-recompile")))
	(error (sprintf "A file named touch-to-recompile must exist in %ssrc/OBJS/%s"
			sn3-dir :os-string)))
    (when (and (not forceit) (file-existsp oname))
      (when (file-newerp (concat sn3-dir "src/OBJS/" :os-string 
                                 "/touch-to-recompile") cname)
	(setq forceit t) ) )
    (when (or forceit (file-newerp snname cname))
      ;; generate C file
      (dhc-make-c cname fsymb-list) )
    (when (or forceit (file-newerp cname oname))
      ;; generate object file
      (when (<> (dhc-make-o cname oname) 0)
	(error "Error during C compilation") ) )	
    ;; load object file
    (dhc-load oname fsymb-list) ) )

)



#? (dhc-make-with-libs <fname> <library-list> <f1> [<f2> ...[<fn>]])
;; Like dhc-make but loads dynamically the libraries in the given <library-list>
;; after loading the compiled objects of <f1>, <f2>, ...
;; The function is created by replacing in dhc-make the last call
;; to (dhc-load oname fsymb-list) by (dhc-load oname fsymb-list libs).
;; Each library must be given by a string with its object name (and path,
;; if it is not local or on SN's standard path).
;;.SEE (dhc-make <fname> <f1> [<f2> ...[<fn>]])
(setq dhc-make-with-libs
  (let*((dhc-make-def (funcdef dhc-make)))
     (eval `(flambda (fname libs . fsymb-list)
              ,(caddr dhc-make-def)
              ,(reverse (cons '(dhc-load oname fsymb-list (eval libs))
                              (cdr (reverse (nth dhc-make-def 4)))))))))


#? (dhc-make-old <fname> <f1> [<f2> ...[<fn>]])
;;OLD DHC-MAKE FUNCTION, REPLACED 95/04.
;; translate functions <f1>...<fn> to C into file <fname>.c, compile 
;; <fname>.c to <fname>.o and load it.
;; If dhc-make is called from within a file being loaded (say f.sn), the time and
;; date of last modification of f.sn is compared to that of <fname>.c and
;; <fname>.o. If <fname>.o is more recent, it is loaded without recompilation.
;; If the .o is older or does not exist, the .c is recompiled.
;; of course, if the .c is older or does not exist it is regenerated.
;; If <fname> is nil, or the empty string, the name of the current file 
;; being loaded is used, after transformation to a legal C identifier (this
;; is necessary because 
;; if the file being loaded is stdin and no filename is given, the code is written
;; in a file whose name is a C-ified version of the last argument <fn>).

(df dhc-make-old ( fname . fsymb-list) 
  (setq fname (eval fname))
  (let* ((forceit ())
	 (snname (if (= "$stdin" file-being-loaded) 
		     (progn (setq forceit t) 
			    (if (consp (last fsymb-list))
				(pname (car (last fsymb-list)))
			      (pname (last fsymb-list))))
		   file-being-loaded))
	 (snname-dir (dir-name snname))
	 (snname-base (base-name snname))
	 ;; name of C file must be a legal C symbol
	 (cname  (concat snname-dir 
			 (dhc-lisp-to-c-name 
			  (if (and fname (<> "" fname)) fname snname-base))
			 ".c"))
	 (oname  (change-suffix cname ".o"))
	 (src-list (all ((sym fsymb-list))
			(if (consp sym)  (eval (car sym)) (eval sym))))
	)
    ;; Adjust oname to use OBJS directory
    (when (or (<> :operating-system 'sunos)
              (dir-existsp (concat snname-dir "OBJS")) )
      (when (not (dir-existsp (concat snname-dir "OBJS")))
        (sys (sprintf "mkdir %sOBJS" snname-dir)) )
      (when (not (dir-existsp (concat snname-dir "OBJS/" :os-string)))
        (sys (sprintf "mkdir %sOBJS/%s" snname-dir :os-string)) )
      (setq oname (concat snname-dir "OBJS/" :os-string "/" 
                          (base-name oname) ".o") ) )
    ;; Look if .o is ancient or does not exist
    (if (not (file-existp (concat sn3-dir "src/OBJS/" 
                                  :os-string "/touch-to-recompile")))
	(error (sprintf "A file named touch-to-recompile must exist in %ssrc/OBJS/%s"
			sn3-dir :os-string)))
    (when (and (not forceit) (file-existp oname))
      (when (file-newerp (concat sn3-dir "src/OBJS/" :os-string 
                                 "/touch-to-recompile") cname)
	(setq forceit t) ) )
    (when (or forceit (file-newerp snname cname))
      ;; generate C file
      (dhc-make-c cname fsymb-list) )
    (when (or forceit (file-newerp cname oname))
      ;; generate object file
      (when (<> (dhc-make-o cname oname) 0)
	(error "Error during C compilation") ) )	
    ;; load object file
    (dhc-load oname fsymb-list) ) )


#? (dhc-load <oname> <fsymb-list>)
;; Similar to mod-load, but check that the loaded function name correspond to 
;; fsymb-list and convert those into DHE.
;;
(de dhc-load (oname fsymb-list &optional libs)
    (if ~(listp fsymb-list)
        (error 'dhc-load "A list of symbol was expected"))
    
    ;; now load compiled funcs and cast them to DHE
    (let* ((src-list (all ((fsy fsymb-list))
                       (if ~(listp fsy)
                           (eval fsy)
                         (if ~(classp (eval (car fsy)))
                           (error 'dhc-load
                                  (sprintf "Not a class: %l" (car fsy))))
                         (cons (eval (car fsy))
                               (all ((fs (cdr fsy)))
                                 (check==> (eval (car fsy)) fs))))))
	   (src-list-old src-list)
	   (fsymb-list-old fsymb-list)
	   (rerror (lambda (s . l) 
		     (each ((fsym fsymb-list-old) (src src-list-old))
			   (if ~(listp fsym)
			     (set fsym src)
			     (set (car fsym) (car src))
			     (each ((fs (cdr fsym)) (sr (cdr src)))
                               (putmethod (eval (car fsym)) fs sr))))
		     (error 'dhc-load (apply sprintf (cons s l)))))
           (fname (mod-load oname))
           (fsymbs (reverse (cdr (mod-inquire fname))))
	   (fsymbs-old fsymbs)
           (lsymb ())
           (fsymb ())
           (passed-symb ()))
      
      (when libs
        (each ((lib libs))
          (mod-load lib))
        (setq fsymbs (reverse (cdr (mod-inquire fname))))
        (setq fsymbs-old fsymbs))
      (when (= "State: uninitialized" (car (mod-inquire fname)))
        (rerror (concat "Module %s was loaded but not initialized\n"
                        "The following symbol were undefined: %s")
                oname (dhc-insert-op (mod-undefined oname) ", ")))
      
      (while src-list
        (setq lsymb (car fsymb-list))      ;; symbol passed from lisp
        (setq func (car src-list))   ;; the symbol above evaluated
        (setq fsymb (car fsymbs))    ;; the symbol from the loaded file
        
        (if (listp func)
            (let ((temp ())
                  (new-class (eval (car lsymb)))
                  (old-class (car func)))
              (when (<> (car lsymb) fsymb)
		    (rerror "Symbol and loaded class name differ: %l <> %l"
			    (car lsymb) fsymb))
              (when (< (length fsymbs) (length lsymb))
		    (rerror "Not enough methods in file loaded: %l <> %l"
			    (cdr lsymb) (cdr fsymbs)))
              (setq fsymbs (cdr fsymbs))
              
              (for (i 1 (1- (length lsymb)) 1)
                (setq temp (cons (car fsymbs) temp))
                (setq fsymbs (cdr fsymbs)))
              (setq temp (reverse temp))
              (let* ((shift (+ 10 (len (pname (car lsymb)))))
                     (te-name (all ((te temp))
                                (named (left (mid (pname te) shift)
                                             (- (len (pname te)) shift)))))
		     (ste-name ())
		     (slsymb ()))
		(setq ste-name (sort-list te-name 
					   (lambda (a b) 
					     (< (pname a) (pname b)))))
		(setq slsymb (sort-list (cdr lsymb)
					 (lambda (a b) 
					   (< (pname a) (pname b)))))
                (when (<> slsymb ste-name)
                  (rerror "Loaded methods and symbol differ: %l <> %l"
                          (cdr lsymb) te-name)))
	      
              (class-cclass old-class (class-cclass new-class))
              
	      ;; Transfer the lisp methods of the old class to the new class
	      (each ((old-lisp-met (methods old-class)))
                (when ~(member old-lisp-met (methods new-class))
                      (putmethod new-class old-lisp-met 
                                 (check==> old-class old-lisp-met))))
              
              (let ((old-met ())
                    (new-met ()))
                (each ((me (cdr lsymb)))
                  (setq old-met (check==> old-class me))
                  (setq new-met (check==> new-class me))
                  (if (= (classof old-met) |DEM|)
                      (if (null :old-met:source)
                          (rerror (concat "method %l was already loaded"
                                          "as a DEM with no source")
                                  me)
                        (setq :new-met:source :old-met:source))
                    (setq :new-met:source old-met))
                  (setq :new-met:file fname)
                  (putmethod old-class me new-met)))
              
              (setq src-list (cdr src-list))
              (setq func (cdr func))
	      (setq fsymb-list (cdr fsymb-list)))
          
	  ;; It is not a class, it is a function
	  (if (= (classof func) |DH|)
	      (rerror "function %l was already loaded as a DH (no source)"
		      fsymb))
	  (if (= (classof func) class)
	      (rerror (concat "Bad format for loading classes:\n        "
			      "       Expecting (... (cl [m1...]) ...): %l")
		      fsymb))
	  (if (and (<> (classof func) |DE|) (<> (classof func) |DHE|))
	      (rerror "Don't know how to compile the type of %l: %s"
		      fsymb (pname (eval fsymb))))

	  (cast (eval fsymb) |DHE|) ;; (eval fsymb) is either a DE or a DH
	  (setq :(eval fsymb):source (==> func get-source))
          (setq :(eval fsymb):file fname)
          (setq src-list (cdr src-list))
          (setq fsymbs (cdr fsymbs))
          (setq fsymb-list (cdr fsymb-list))))
      
      fsymbs-old))

#? (dhc-cc <fname> <fsymbs>)
;; Compile and load the functions in the <fsymbs> list of symbols.
;; <fname> is a file name, using unix convention, relative to the current
;; directory (absolute path name are allowed.
(de dhc-cc (fname symblist)
    (dhc-make-c (concat fname ".c") symblist)
    (dhc-make-o (concat fname ".c") (concat fname ".o"))
    (dhc-load (concat fname ".o") symblist))





#? (dhc-uncompile <dhc-make-style-funclist>)
;; Restores the lisp definition of functions.  Calling the function from the
;; interpreter will now use the lisp version of the function. Compiled
;; functions will still use the compiled version. The compiled function
;; is still available by appending <"-compiled"> to its name.

(df dhc-uncompile __funcs
    (all ((__fs __funcs))

      (cond
       ((symbolp __fs)
        (let ((__ff (eval __fs)))
          (when (or (not __ff) (not (is-of-class __ff |DHE|)))
            (error 'dhc-uncompile "Cannot uncompile" __fs) )
          (set (named (sprintf "%l-compiled" __fs)) __ff)
          (set __fs (eval :__ff:source)) )
        __fs )
       
       ((consp __fs)
        (let* ((__fc (car __fs))
               (__ff (eval __fc)) )
          (when (or (not (classp __ff)) (not (class-cclass __ff)))
            (error 'dhc-uncompile "Not a compiled class" __fs) )
          (each ((meth (cdr __fs)))
            (let ((func (check==> __ff meth)))
              (when (not func)
                (error 'dhc-uncompile "Unknown method" (list __fc meth)) )
              (putmethod __ff (named (sprintf "%l-compiled" meth)) func)
              (putmethod __ff meth (eval :func:source)) ) ) )
        __fs )
       
         (t 
          (error 'dhc-uncompile "Cannot uncompile" __fs) ) ) ) )


#? (dhc-recompile <dhc-make-style-funclist>)
;; Restore the compiled versions saved by <dhc-uncompile>.

(df dhc-recompile __funcs
    (all ((__fs1 __funcs))

      (cond
       ((symbolp __fs1)
        (let* ((__fs (named (sprintf "%l-compiled" __fs1)))
               (__ff (eval __fs)) )
          (when (or (not __ff) (not (is-of-class __ff |DHE|)))
            (error 'dhc-recompile "Cannot recompile" __fs1) )
          (set __fs1 __ff)
          (set __fs ()) )
        __fs1 )
       
       ((consp __fs1)
        (let* ((__fc (car __fs1))
               (__ff (eval __fc)) )
          (when (or (not (classp __ff)) (not (class-cclass __ff)))
            (error 'dhc-recompile "Not a compiled class" __fs) )
          (each ((meth1 (cdr __fs1)))
            (let* ((meth (named (sprintf "%l-compiled" meth1)))
                   (func (check==> __ff meth)))
              (when (not func)
                (error 'dhc-uncompile "Cannot recompile" (list __fc meth1)) )
              (putmethod __ff meth1 func)
              (putmethod __ff meth ()) ) ) ) 
        __fs1)
       
         (t 
          (error 'dhc-uncompile "Cannot uncompile" __fs) ) ) ) )







