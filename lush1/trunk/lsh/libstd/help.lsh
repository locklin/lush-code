;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; LUSH Lisp Universal Shell
;;;   Copyright (C) 2002 Leon Bottou, Yann Le Cun, AT&T Corp, NECI.
;;; Includes parts of TL3:
;;;   Copyright (C) 1987-1999 Leon Bottou and Neuristique.
;;; Includes selected parts of SN3.2:
;;;   Copyright (C) 1991-2001 AT&T Corp.
;;;
;;; This program is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 2 of the License, or
;;; (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program; if not, write to the Free Software
;;; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;;    "help.lsh"   
;;;;    The help subsystem...
;;;;	Yann LeCun 2002
;;;;
;;;;  $Id: help.lsh,v 1.2 2002-08-27 19:46:26 leonb Exp $
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;; ========================================
;;; Help on help
;;; ========================================

#? *** Help.
;; The online help system of Lush is able to perform several tasks.
;;.IP
;; If you want to check the usage of a regular Lush function, you can
;; use function <apropos> to retrieve its documentation and display it
;; on your screen.
;;.IP
;; If you want to document your Lush functions, just add comments 
;; in a particular format in your source file. The help system will 
;; format your comments and insert them into the help database.
;;.IP
;; Finally, the help system can produce a complete documentation
;; in HTML.


;;; ========================================
;;; A propos
;;; ========================================

#? ** Browsing the Manual
;; The simplest way to view the manual and obtain on-line help
;; is to start the graphical help tool by typing:
;;.PRE
;; (helptool)
;;.P
;; at the lush prompt. 
;;.P
;; Display the documentation on a particular topic at
;; the terminal can be done by typing: <(apropos "topic")>
;; or <^Atopic> (caret A and the topic) at the Lush prompt.
;; For example:
;;.PRE
;;   ? ^Acar
;;.P
;; displays a choice of help entries that contain
;; the string ``car''.


;;; ----------------------------------------
#? ^A <topic>
;; This macro character calls command <apropos>.

;; (dmc |^A| (list 'apropos (read-string)))

;;; ----------------------------------------
#? (apropos <topic>)
;; This command displays some help text for a given subject <topic>.
;;
;; If several help entries match string <topic>, the list of the
;; titles of the matching entries is displayed. The user can then
;; select one entry using its number and proceed.
;;
;; The text for this entry is then formatted and displayed.  using a
;; pager program.  References to related entries are also displayed A
;; prompt is then displayed.
;;.IP
;; Entering <v> redisplays the current entry.
;;.IP
;; Entering <u> jumps to the section entry for this entry.
;;.IP
;; Entering <n> or <p> jumps to the next or previous entries 
;; in this section of the manual.
;;.IP
;; Entering a number jumps to the numbered subentry or related entry
;; attached to this entry.
;;.IP
;; Entering <s> displays the initial list of entries matching your query.
;;.IP
;; Entering <q> or just typing <CR> quits the help system.


(de apropos(topic) (error "not implemented yet"))


;;; ========================================
;;; Adding help documentation
;;; ========================================

;;; ----------------------------------------
#? ** Adding Help.
;; Online help is either extracted from comments in Lush files <".lsh">
;; or extracted from special <".hlp"> files.
;;.P
;; Help entries can contain text, and/or can contain other
;; help entries as subtopics.  Entries can be organized 
;; hierarchically into books that can be browsed graphically
;; using <(helptool)>. Entries in a file are added to the 
;; main documentation by inserting the file name at the desired
;; location in one of the .hlp files read by <(helptool)>.
;;.P
;; Looking at any .lsh or .hlp file in  <"<lushdir>/lsh"> or 
;; <"<lushdir>/packages"> is a good way to learn how to organize 
;; the comments of a Lush file in order to provide help
;; entries.  
;;.P
;; Each help entry is created by a title line starting
;; with compound macro-character <#?>. Title lines can
;; create new sections, describe variables, functions,
;; classes, and methods. 
;;.P
;; Here are a few examples of typical title lines:
;;.LI Add a Section: #? *** All about Choucroute Garnie
;;.LI Include lsh file: #? ** << choucroute-garnie.lsh
;;.LI Include hlp file: #? << choucroute-garnie.hlp
;;.LI Describe Variable: #? choucroute-garnie
;;.LI Describe Function: #? (garni-la-choucroute <saucisse> <patates>)
;;.LI Describe Class: #? choucroute
;;.LI Describe Method: #? (==> <choucroute> garni <saucisse> <patates>)
;;.LI Describe Constructor: #? (new choucroute)
;;.P
;; The #? of each entry can optionally be followed by one or
;; more asterisks. The number of asterisks specifies the hierarchical
;; level of the entry in the manual. Entries with fewer asterisks than
;; a previous entry in the same file will become subtopics of that
;; previous entry:
;;.PRE
;;       #? *** My Section Title.
;;       my section text goes here
;;       #? ** My Subsection Title 1
;;       my subsection 1 text goes here
;;       #? ** My Subsection Title 2
;;       my subsection 2 text goes here
;;.P
;; Entries that document functions, classes, methods, and variables, 
;; should be written according to the following convention:
;;.LI Function:
;; Function description entries indicate how to call
;; the function. Arguments are indicated by angle brackets.
;; Here are a few examples:
;;.VP
;;       #? (car <list>)
;;       #? (+ <n_1> ... <n_n>)
;;       #? (new-window [<w> <h>] <name>)
;;
;;.LI Variable:
;; Description of variables should simply include the 
;; variable name on the title line. It is recommended 
;; that the text include a ``.TYPE VAR'' directive.
;;.LI Class:
;; Class description are usually associated to an entry
;; indicating how to create an instance. Method documentation
;; entries show how to call the method.
;;.VP
;;       #? (new helpinfo <record>)
;;       #? (==> <helpinfo> tty-print)
;;.P
;; You can also require the help parser to read help from
;; another file. The following example inserts all toplevel entries
;; from file <"toto.hlp"> as a section marked with two stars
;; (the stars of the entries in the file <"toto.hlp">
;; are only used to place the those entries relative to each other).
;;.PRE
;;      #? ** << toto.hlp
;;.P
;; The help text is then composed using the following comment lines
;; until a non comment line is reached. Blank lines as well as dotted
;; directives delimitate paragraphs.  Arguments and literal should
;; be surrounded with angle brackets.
;;.P
;; Directives can be inserted in the text that follows the entry title
;; Some directive provide additional information for indexing the entry:
;;.PRE
;;  the topic filename    ;;.FILE help.lsh
;;  the topic type        ;;.TYPE  DE
;;  the short description ;;.DESC this function does blah and blah
;;  related entries       ;;.SEE (apropos <topic>)
;;.PP
;; Some directives provide formatting instructions
;; pertaining to the next paragraph
;;.VP
;;  ordinary paragraph      ;;.P
;;  list entry              ;;.LI
;;  pre-formatted paragraph ;;.PRE
;;  online doc only         ;;.IFHLP
;;  paper manual only       ;;.IFTEX
;;.PP
;; Directive .EX lets you run a lisp expression and display
;; it as an example during when the user looks the corresponding
;; entry. You should make sure that this operation carries no side
;; effect.
;;.PRE
;;  running an example    ;;.EX (lush expression)
;;.P
;; Directive IMG lets you include a picture (in any format).
;; The name of the file should be given by the <figure=<name>>
;; parameter. Further optional parameters are <height=<height>>
;; and  <width=<width>>. Both express a number of pixels.
;;.VP
;;   ;;.IMG toto.png
;;.PP
;; Certain conventions have been established:
;; Angle brackets delimitate the arguments of a function as well
;; as Lush objects embedded in the text. Strings are delimited
;; by two backquotes <``> and two quotes <''>.
;;.VP
;;  <identifier> <"string"> <( list )>
;;  ``A non Lush string''
;;.PP
;; Help files <".hlp"> just contain a text formatted as explained
;; above.  Semicolons introducing comments however are unnecessary.


(libload "ldoc/ldoc")

(de help-tmp () 
    (if (stringp *help-tmp*) *help-tmp* (setq *help-tmp* (tmpname))))

(help-tmp)

;;; ========================================
;;; Globals
;;; ========================================

#? ** Help internals
;; Here are the functions used by the help system.


;;; ========================================
;;; Parsing help files
;;; ========================================

;; (setq help-dir-list '("manual" "packages" "local"))

;; ----------------------------------------

#? (help-search-file <file> [<hd>])
;; Tries to locate a given help file <file>.
;; Help files are searched along the help path. SN files are searched
;; along the SN path. If everything fails, the specified directory <hd>
;; is assumed.
(de help-search-file (file &optional (hd "."))
  ;; Search along help path
  (let ((dirs (or help-dir-list  (cons "." (path))))
	(fullname ()) )
    (when (regex-match ".*\\.(lsh|sn|tl)" file)
      ;; Search SN files along SN path
      (setq dirs (cons "." (path))) )
    (while (and dirs 
		(setq fullname (concat-fname (car dirs) file))
		(not (filep fullname)) )
      (setq dirs (cdr dirs)) )
    (if (not dirs)
	(setq fullname (concat-fname hd file)) )
    fullname ) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; parse a brace-enclosed series of lisp expressions
(de parse-help-brace()
  (skip-char "{")
  (let ((ans (list (read))))
    (while (<> (skip_char " \t") "}")
      (setq ans (nconc1 ans (read))) )
    (skip-char "}")
    ans ) )

;; parse a single help entry line
(de parse-help-entry ()
    (let* ((line (read-string "~{\n\r\f\e"))
	   (pattern "^[ \t]*((\\**)[ \t]*((<<)?)[ \t]*(.*))$")
	   (lvl (len (regex-subst pattern "%1" line)))
	   (txt (regex_subst "[ \t]+$" "" 
			     (regex-subst pattern "%4" line)))
	   (includep (= (regex-subst pattern "%2" line) "<<")))
      (if includep 
	  (progn 
	    (skip-char "\n\r\f")
	    (read-help-headers txt lvl))
	(let ((ans ())
	      (ok t)
	      (next ()))
	  (if (= "" txt)
	      (progn
		(setq ans (list 'helpt-noentry 'state lvl))
		(while (not (index (setq next (skip-char " \t")) "\n\r\f\e"))
		  (when (= "{" next) 
		    (setq ans (append ans (parse-help-brace))))))
	    (setq ans (list 'helpt-entry 'state lvl txt))
	    (while (not (index (setq next (skip-char " \t")) "\n\r\f\e"))
	      (when (= "{" next) 
		(nconc1 ans (cons 'helpt-noentry (cons 'state (cons lvl (parse-help-brace))))))))
	    (skip-char "\n\r\f")
	  ans))))

;; parse help entries in a help file 
;; returns a lisp expression that will build the
;; ldoc tree when evaluated in the right context.
;; The returned expression is a nested list of entries.
;; Sub-entries are nested into their parent entry.
;; (file <level> <filename>
;;   (entry <level> <name> 
;;     (noentry <level> <expr1> .... <exprn>)
;;     (entry <level> <name>)
;;     (file <level> <filename>
;;       (entry <level> <name>)
;;       .....
;;       (entry <level> <name>))
;;     (entry <level> <name>))
;;   (entry <level> <name>))
(de read-help-headers(file lvl)
  ;; (printf " [%s] (parsing help)\n" file)
  (let* ((fname (help-search-file file))
	 (ans (list 'helpt-file 'state lvl fname))
	 (zz ())
	 (level -1)
	 (last-level -1)
	 (tailend (lastcdr ans)))
    (if (not (filep fname))
        ;; (error 'help-parse "Help file not found" file) 
	(progn (printf "[Help file %s not found]\n" file) ())
      (reading (concat "| grep '#?' " fname)
	(while (<> (skip-char "") "\e")
	  ;; does the line begin with #?
	  (if (and (= (read-string 1) "#")
		   (= (read-string 1) "?"))
	      ;; yes, parse the rest of the line
	      (let ((r (parse-help-entry)))
		(when r 
		  (let* ((rlevel (caddr r))
			 (z (if (<= rlevel last-level) tailend ans)))
		    (while (and (consp (last z)) 
				(< rlevel (caddr (last z))))
		      (setq z (last z)))
		    (nconc1 z r)
		    (setq last-level rlevel)
		    (setq tailend (lastcdr z)))))
	    ;; no, just gobble up the line
	    (read-string) (skip-char "\n\r\f"))))
      ans)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; a help-node is a tree-node whose data is
;; a dynamically loaded ldoc.

(defclass help-node ltree-node file)

(defmethod help-node help-node (lname lfile lkey ldata &optional lchildren)
  (setq data ldata)
  (setq keywords lkey)
  (setq file lfile)
  (setq name lname)
  (each ((c lchildren))
    (==> this insert c)))

(defmethod help-node -destructor () 
  (each ((c (==> this getchildren))) (delete c)))

(defmethod help-node getdata () 
  (when (not data)
    (setq data (new ldoc))
    (==> data read-help name file))
  data)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CAUTION: the next three function rely on dynamic binding

(df helpt-file (state lvl f . c)
    (let ((current-file (eval f)))
      (each ((c c)) (eval c))))
      
(df helpt-entry (state lvl name . c) 
    (let* ((n (new help-node (eval name) current-file () ())))
      ;; add node to the help-node tree
      (when current-node (==> current-node insert n))
      ;; add node to the file alist
      (==> current-book put-entry current-file n)
      ;; evaluate content
      (let ((current-node n))
	(each ((c c)) (eval c)))))

(df helpt-noentry (state lvl . c) 
      (each ((c c)) (eval c)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; the help-book contains the tree of help-nodes as
;; well as an alist of filenames and associated help-nodes.
;; It manages the dynamic updating of help topics when
;; program files are re-loaded.
(defclass help-book object
  root
  files)

(defmethod help-book  help-book (f title)
  (setq root (new help-node title "" () ()))
  (setq files (list (list f root)))
  (let* ((help-code  (read-help-headers f 0))
	 (current-file f)
	 (current-node root)
	 (current-book this))
    (eval help-code)))

;; supposed to build the hash table mapping files to nodes
(defmethod help-book  put-entry (f n) 
  (let ((pair (assoc f files)))
    (if pair 
	(nconc1 pair n)
      (setq files (cons (list f n) files)))))

(defmethod help-book make-ltree () (make-ltree-from-tree root))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; turn a full filename into a short one
;; removing the prefix if it is the Lush directory
(de shorten-filename (f) (regex-subst (concat "^" lushdir) "" f))

;; parse a single help entry line and return the entry name
(de read-help-entry-name ()
    (let* ((line (read-string "~{\n\r\f\e"))
	   (pattern "^[ \t]*((\\**)[ \t]*((<<)?)[ \t]*(.*))$")
	   (txt (regex_subst "[ \t]+$" "" 
			     (regex-subst pattern "%4" line)))
	   (includep (= (regex-subst pattern "%2" line) "<<")))
      (if includep "" txt)))


;; look for help entry <lname> in file <lfile> 
;; and read it into the ldoc object.
(defmethod ldoc read-help (lname lfile)
  (let* ((fname lfile)
	 (found ()))
    (if (not (filep fname))
	(setq doc '(p "<< help file not found >>"))
      (reading fname
	       (while (and (not found) (<> (skip-char "~#\e") "\e"))
		 ;; does the line begin with #?
		 (if (and (= (read-string 1) "#")
			  (= (read-string 1) "?"))
		     ;; yes, parse the rest of the line
		     (let ((r (read-help-entry-name)))
		       (when (= r lname)
			 (setq title lname)
			 (setq name lname)
			 (setq file (shorten-filename lfile))
			 (read-string 1)
			 (==> this read-help-here)
			 (setq found t) )))))
      (when (not found)
	(setq   
	 doc '(p "<< help entry not found >>")
	 name lname
	 keywords ()
	 title lname
	 hlinks ()
	 description ()
	 file lfile
	 type ()
	 author ()
	 date ())))))

;; read the body of a help text from the current
;; point in the file (presumably right after the 
;; the entry header line.
(defmethod ldoc read-help-here()
  (setq   
   doc (list 'progn)
   keywords ()
   hlinks ()
   description ()
   type ()
   author ()
   date ())
  ;; Try to figure out TYPE from ENTRY
  (cond
    ((= type t)
     (setq type t) )
    ((regex-match "\\(==> .*\\)" name)
     (setq type "MSG") )
    ((regex-match "\\(new .*\\)" name)
     (setq type "CLASS") )
    ((regex-match "\\([-a-zA-Z0-9+*/<>=]+( .*)?\\)" name)
     (let ((symb (regex-subst "\\(([-a-zA-Z0-9+*/<>=]+)( .*)?\\)" "%0" name)))
       (setq symb (apply scope (list (named symb))))
       (when symb 
	 (setq symb (pname (classname (classof symb))))
	 (setq type (regex-subst "\\|(.*)\\|" "%0" symb)) ) ) ) )
  ;; Go reading
  (let ((line ())
	(para "")
	(paratype 'p)
	(regex (selectq (regex-subst ".*(\\.[a-z]+)$" "%0" file)
		 (".lsh"  "^;+(.*)$")
		 (".tl"  "^;+(.*)$")
		 (".c"   "^ *\\*+(.*)$")
		 (".hlp" "(.?|[^#].*|#[^?].*)")
		 (t      "(.?|[^#].*|#[^?].*)")
		 ) ) )
    (while (let ((ok t))
	     ;; Test
	     (setq line ())
	     (if (= (skip-char "") "\e")
		 (setq ok ())
	       (setq line (read-string "~\n\r\e"))
	       (read-string 1)
	       (if (regex-match regex line)
		   (setq line (regex-subst regex "%0" line))
		 (setq ok ()) ) )
	     ;; Finished paragraph
	     (when (or (not ok)
		       (regex-match "\\.[A-Z]+.*" line)
		       (regex-match "[ \t]*" line) )
	       (setq para (regex-subst "[ \t\n]+" " " para))
	       (setq para (regex-subst " $" "" para))
	       (setq para (regex-subst "^ " "" para))
	       (setq para (regex-subst "\\. " ".  " para))
	       (when (<> para "")
		 (setq doc (nconc1 doc (list paratype para))) 
		 (setq para "") ) )
	     ;; Return boolean for while
	     ok )
      (if (regex-match "\\.[A-Z]+.*" line)
	  ;; This is a special .XXX directive
	  (let ((f (regex-subst "^\\.([A-Z]+)[ \t]*(.*)$" "%0" line))
		(a (regex-subst "^\\.([A-Z]+)[ \t]*(.*)$" "%1" line)) )
	    (if (= a "") 
		(setq a ()) 
	      (setq a (regex-subst "[ \t]+$" "" a)))
	    (selectq f
	      ("TYPE"
	       (when (and a (<> type t)) (setq type a)) )
	      ("DESC"
	       (when a (setq description a)))
	      ("FILE"
	       (when a (setq file a)) )
	      ("HLINK"
	       (when a 
		 ;; add hyperlink to list
		 (setq hlinks (nconc1 hlinks (list a)))
		 ;; add hlink in text with index of hyperlink in hlink list
		 (setq doc (nconc1 doc (list 'hlink (1- (length hlinks)) a)))))
	      ("SEE" 
	       (when a 
		 ;; same as HLINK but adds "see also" to text.
		 ;; add hyperlink to list
		 (setq hlinks (nconc1 hlinks (list a)))
		 ;; add hlink in text with index of hyperlink in hlink list
		 (setq doc 
		       (nconc1 doc 
			       (list 'li "see also " 
				     (list 'hlink (1- (length hlinks)) a))))))
	      (("AUTH" "AUTHOR")
	       (when a (setq author a)))
	      ("DATE"
	       (when a (setq date a)))
	      (("EX" "EXAMPLE")
	       (when a
		 (writing (help-tmp) (printf "%s))\n" a))
		 (reading (help-tmp) (setq a (read)))
		 (writing (help-tmp)
			  (printf "? ")
			  (pprint a)
			  (let ((result (eval a)))
			    (printf "= ")
			    (pprint result) ))
		 (reading (help-tmp) 
			  (let ((ans (list 'code)))
			    (while (<> (skip-char "\n\r\f") "\e")
			      (setq ans 
				    (nconc1 ans 
					    (regex-subst "%" "%%%%" 
							 (read-string)))))
			    (setq doc (nconc1 doc ans))))))
	      (("PP" "P")
	       (setq paratype 'p) )
	      (("IP" "LI")
	       (when ~a (setq a "*"))
	       (setq paratype 'li))
	      (("VP" "PRE")
	       (setq paratype 'pre) )
	      ("CODE"
	       (setq paratype 'code) )
	      (("IFHLP" "IFHELP" "IFOGRE")
	       (setq paratype 'if-ogre) )
	      ("IFTEX"
	       (setq paratype 'if-latex) ) 
	      ("IFTXT"
	       (setq paratype 'if-text) ) 
	      (("IMG" "EPS")
	       (if a
		   (setq doc (nconc1 doc (list 'p (list 'center (cons 'img a)))))
		 (error () ".IMG/.EPS without a filename " 
			(concat file ":" name))))
	      (t 
		(printf "Unknown help directive %s\n" f) ) ) )
	;; This is an ordinary line
	(setq line (regex-subst "%" "%%%%" line))
	(if (member paratype '(p li))
	    (setq para (concat para "\n" line))
	  (setq doc (nconc1 doc 
			    (if (consp paratype) 
				(append paratype (list line))
			      (list paratype line))) ) ) ))
    ;; Check that something has been read
    (when (not doc)
      (setq doc '((p ""))) )
    (when (and line (= (left line 2) "#?"))
      (mid line 3))))

;;; ========================================
;;; Help macro
;;; ========================================

;;; ----------------------------------------
#? #? <entry>
;;.TYPE DMC
;; This macro marks the node root as outdated.

(dmc |#?|
  (when (and file-being-loaded (<> file-being-loaded "$stdin"))
    (let ((e (parse-help-entry)))
      (==> (find-help-section file-being-loaded (caddr e)) insert e))))

(dmc |#?|
  (when (and file-being-loaded (<> file-being-loaded "$stdin"))
    (let ((e (parse-help-entry))) ())))





