;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; LUSH Lisp Universal Shell
;;;   Copyright (C) 2002 Leon Bottou, Yann Le Cun, AT&T Corp, NECI.
;;; Includes parts of TL3:
;;;   Copyright (C) 1987-1999 Leon Bottou and Neuristique.
;;; Includes selected parts of SN3.2:
;;;   Copyright (C) 1991-2001 AT&T Corp.
;;;
;;; This program is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 2 of the License, or
;;; (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program; if not, write to the Free Software
;;; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;;    "help.lsh"   
;;;;    The help subsystem...
;;;;	Yann LeCun 2002
;;;;
;;;;  $Id: help.lsh,v 1.6 2002-10-01 22:27:38 profshadoko Exp $
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(libload "libstd/ldoc")

;;; ========================================
;;; Help on help
;;; ========================================

#? *** Help.
;; The online help system of Lush is able to perform several tasks.
;;.IP
;; If you want to check the usage of a regular Lush function, you can
;; use function <apropos> to retrieve its documentation and display it
;; on your screen.
;;.IP
;; If you want to document your Lush functions, just add comments 
;; in a particular format in your source file. The help system will 
;; format your comments and insert them into the help database.
;;.IP
;; Finally, the documentation system can produce a complete documentation
;; in HTML.


;;; ========================================
;;; A propos
;;; ========================================

#? ** Browsing the Manual
;; The simplest way to view the manual and obtain on-line help
;; is to start the graphical help tool by typing:
;;.PRE
;; (helptool)
;;.P
;; at the lush prompt. 
;;.P
;; Display the documentation on a particular topic at
;; the terminal can be done by typing: <(apropos "topic")>
;; or <^Atopic> (caret A and the topic) at the Lush prompt.
;; For example:
;;.PRE
;;   ? ^Acar
;;.P
;; displays a choice of help entries that contain
;; the string ``car''.


;;; ----------------------------------------
#? ^A <topic>
;; This macro character calls command <apropos>.
;; (dmc |^A| (list 'apropos (read-string)))

;;; ----------------------------------------
#? (apropos <topic> [<force>])
;; This command displays some help text for a given subject <topic>.
;;
;; If several help entries match string <topic>, the list of the
;; titles of the matching entries is displayed. The user can then
;; select one entry using its number and proceed.
;; 
;; hitting the enter key or entering "q" or "quit"
;; returns to the regular Lush prompt
;;
;; If the optional boolean parameter <force> is
;; non-nil, the Lush manual is re-read from
;; the help files.
(de apropos(topic &optional force) 
  (let ((hp (read-help-book force)))
    (if (= "" topic) 
      (printf "Empty search topic. Type (helptool) to browse the documentation.\n")
    (let* ((filter 
	    (eval 
	     `(lambda (c)
		(let ((s (==> c getkey)) (r ())) 
		  (while (and s (not r)) 
		    (when (regex-seek ,topic (cleanup-regex (car s))) (setq r t))
		    (setq s (cdr s))) r))))
	   (rez (new ltree-node 
		     (sprintf "Search Results for: %s" topic) ()()))
	   )
      (filter-flat-ltree-from-tree :hp:root rez filter)
      (==> rez open)
      (let* ((ch (==> rez getchildren))
	     (nch (length ch)))
	(cond 
	 ((= 0 nch) (printf "no match found\n"))
	 ((= 1 nch) 
	  (==> (==> (==> (car ch) getdata) getdata) render-text)
	  )
	 (t
	  (when
	      (if (<= nch 50) t
		(printf "%d matches, show anyway (y/n) [n]" nch)
		(flush)
		(let ((choice (read-string)))
		  (when (member choice '("y" "Y")) t)))
	    (ltree-pretty rez)
	    (let ((done ()) (choice ()))
	      (while (not done)
		(printf "choice")
		(flush)
		(setq choice (read-string))
		(cond
		 ((member choice '(() "" "q" "Q" "n" "N" "quit")) (setq done t))
		 ((and (setq choice (val choice))
		       (>= choice 1)
		       (<= choice (length ch)))
		  (setq done t)
		  (==> (==> (==> (nth ch choice) getdata) getdata) render-text))
		 (t (printf "invalid choice, try again\n")))))))
	 ))
      (delete rez)))))


;;; ========================================
;;; Adding help documentation
;;; ========================================

;;; ----------------------------------------
#? ** Adding Help.
;; Online help is either extracted from comments in Lush files <".lsh">
;; or extracted from special <".hlp"> files.
;;.P
;; Help entries can contain text, and/or can contain other
;; help entries as subtopics.  Entries can be organized 
;; hierarchically into books that can be browsed graphically
;; using <(helptool)>. Entries in a file are added to the 
;; main documentation by inserting the file name at the desired
;; location in one of the .hlp files read by <(helptool)>.
;;.P
;; Looking at any .lsh or .hlp file in  <"<lushdir>/lsh"> or 
;; <"<lushdir>/packages"> is a good way to learn how to organize 
;; the comments of a Lush file in order to provide help
;; entries.  
;;.P
;; Each help entry is created by a title line starting
;; with compound macro-character <#?>. Title lines can
;; create new sections, describe variables, functions,
;; classes, and methods. 
;;.P
;; Here are a few examples of typical title lines:
;;.LI Add a Section: #? *** All about Choucroute Garnie
;;.LI Include lsh file: #? ** << choucroute-garnie.lsh
;;.LI Include hlp file: #? << choucroute-garnie.hlp
;;.LI Describe Variable: #? choucroute-garnie
;;.LI Describe Function: #? (garni-la-choucroute <saucisse> <patates>)
;;.LI Describe Class: #? choucroute
;;.LI Describe Method: #? (==> <choucroute> garni <saucisse> <patates>)
;;.LI Describe Constructor: #? (new choucroute)
;;.P
;; The #? of each entry can optionally be followed by one or
;; more asterisks. The number of asterisks specifies the hierarchical
;; level of the entry in the manual. Entries with fewer asterisks than
;; a previous entry in the same file will become subtopics of that
;; previous entry:
;;.PRE
;;       #? *** My Section Title.
;;       my section text goes here
;;       #? ** My Subsection Title 1
;;       my subsection 1 text goes here
;;       #? ** My Subsection Title 2
;;       my subsection 2 text goes here
;;.P
;; Entries that document functions, classes, methods, and variables, 
;; should be written according to the following convention:
;;.LI Function:
;; Function description entries indicate how to call
;; the function. Arguments are indicated by angle brackets.
;; Here are a few examples:
;;.VP
;;       #? (car <list>)
;;       #? (+ <n_1> ... <n_n>)
;;       #? (new-window [<w> <h>] <name>)
;;
;;.LI Variable:
;; Description of variables should simply include the 
;; variable name on the title line. It is recommended 
;; that the text include a ``.TYPE VAR'' directive.
;;.LI Class:
;; Class description are usually associated to an entry
;; indicating how to create an instance. Method documentation
;; entries show how to call the method.
;;.VP
;;       #? (new helpinfo <record>)
;;       #? (==> <helpinfo> tty-print)
;;.P
;; You can also require the help parser to read help from
;; another file. The following example inserts all toplevel entries
;; from file <"toto.hlp"> as a section marked with two stars
;; (the stars of the entries in the file <"toto.hlp">
;; are only used to place the those entries relative to each other).
;;.PRE
;;      #? ** << toto.hlp
;;.P
;; The help text is then composed using the following comment lines
;; until a non comment line is reached. Blank lines as well as dotted
;; directives delimitate paragraphs.  Arguments and literal should
;; be surrounded with angle brackets.
;;.P
;; Directives can be inserted in the text that follows the entry title
;; Some directive provide additional information for indexing the entry:
;;.PRE
;;  the topic filename                 .FILE help.lsh
;;  the topic type                     .TYPE DE
;;  the short description              .DESC this function does blah and blah
;;  hyperlink to other entries or URL  .HLINK blah
;;  related entries                    .SEE blah
;;  author                             .AUTHOR blah
;;  date                               .DATE blah
;;.PP
;; Some directives provide formatting instructions
;; pertaining to the next paragraph
;;.VP
;;  ordinary paragraph      .P
;;  list entry              .LI
;;  pre-formatted paragraph .PRE
;;  code snippet            .CODE
;;  online doc only         .IFHLP
;;  paper manual only       .IFTEX
;;  ascii console manual    .IFTXT
;;.PP
;; Directive .EX lets you run a lisp expression and display
;; it as an example during when the user looks the corresponding
;; entry. You should make sure that this operation carries no side
;; effect.
;;.PRE
;;  running an example      .EX (lush expression)
;;.P
;; Directive IMG lets you include a picture (in any format).
;; The name of the file should be given by the <figure=<name>>
;; parameter. Further optional parameters are <height=<height>>
;; and  <width=<width>>. Both express a number of pixels.
;;.VP
;;       .IMG toto.png
;;.PP
;; Certain conventions have been established:
;; Angle brackets delimitate the arguments of a function as well
;; as Lush objects embedded in the text. Strings are delimited
;; by two backquotes <``> and two quotes <''>.
;;.VP
;;  <identifier> <"string"> <( list )>
;;  ``A non Lush string''
;;.PP
;; Help files <".hlp"> just contain a text formatted as explained
;; above.  Semicolons introducing comments however are unnecessary.


(de help-tmp () 
    (if (stringp *help-tmp*) *help-tmp* (setq *help-tmp* (tmpname))))

(help-tmp)

;;; ========================================
;;; Globals
;;; ========================================

#? ** Help internals
;; Here are the functions used by the help system.


;;; ========================================
;;; Parsing help files
;;; ========================================

;; (setq help-dir-list '("manual" "packages" "local"))

;; ----------------------------------------

#? (help-search-file <file> [<hd>])
;; Tries to locate a given help file <file>.
;; Help files are searched along the help path. SN files are searched
;; along the SN path. If everything fails, the specified directory <hd>
;; is assumed.
(de help-search-file (file &optional (hd "."))
  ;; Search along help path
  (let ((dirs (or help-dir-list  (cons "." (path))))
	(fullname ()) )
    (when (regex-match ".*\\.(lsh|sn|tl)" file)
      ;; Search SN files along SN path
      (setq dirs (cons "." (path))) )
    (while (and dirs 
		(setq fullname (concat-fname (car dirs) file))
		(not (filep fullname)) )
      (setq dirs (cdr dirs)) )
    (if (not dirs)
	(setq fullname (concat-fname hd file)) )
    fullname ) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; parse a brace-enclosed series of lisp expressions
(de parse-help-brace() (read))

;; parse a single help entry line
(de parse-help-entry ()
    (let* ((line (read-string "~{\n\r\f\e"))
	   (pattern "^[ \t]*((\\**)[ \t]*((<<)?)[ \t]*(.*))$")
	   (lvl (len (regex-subst pattern "%1" line)))
	   (txt (regex_subst "[ \t]+$" "" 
			     (regex-subst pattern "%4" line)))
	   (includep (= (regex-subst pattern "%2" line) "<<")))
      (if includep 
	  (progn 
	    (skip-char "\n\r\f")
	    (read-help-headers txt lvl))
	(let ((ans ())
	      (ok t)
	      (next ()))
	  (if (= "" txt)
	      (progn
		(setq ans (list 'helpt-noentry 'state lvl))
		(while (not (index (setq next (skip-char " \t")) "\n\r\f\e"))
		  (when (= "{" next) 
		    (setq ans (append ans (parse-help-brace))))))
	    (setq ans (list 'helpt-entry 'state lvl txt))
	    (while (not (index (setq next (skip-char " \t")) "\n\r\f\e"))
	      (when (= "{" next) 
		(nconc1 ans (cons 'helpt-noentry 
				  (cons 'state (cons lvl (parse-help-brace))))))))
	    (skip-char "\n\r\f")
	  ans))))

;; parse help entries in a help file 
;; returns a lisp expression that will build the
;; ldoc tree when evaluated in the right context.
;; The returned expression is a nested list of entries.
;; Sub-entries are nested into their parent entry.
;; (file <level> <filename>
;;   (entry <level> <name> 
;;     (noentry <level> <expr1> .... <exprn>)
;;     (entry <level> <name>)
;;     (file <level> <filename>
;;       (entry <level> <name>)
;;       .....
;;       (entry <level> <name>))
;;     (entry <level> <name>))
;;   (entry <level> <name>))
(de read-help-headers(file lvl)
  ;; (printf " [%s] (parsing help)\n" file)
  (let* ((fname (help-search-file file))
	 (ans (list 'helpt-file 'state lvl fname))
	 (zz ())
	 (level -1)
	 (last-level -1)
	 (tailend (lastcdr ans)))
    (if (not (filep fname))
        ;; (error 'help-parse "Help file not found" file) 
	(progn (printf "[Help file %s not found]\n" file) ())
      (reading (concat "| grep '#?' " fname)
	(while (<> (skip-char "") "\e")
	  ;; does the line begin with #?
	  (if (and (= (read-string 1) "#")
		   (= (read-string 1) "?"))
	      ;; yes, parse the rest of the line
	      (let ((r (parse-help-entry)))
		(when r 
		  (let* ((rlevel (caddr r))
			 (z (if (<= rlevel last-level) tailend ans)))
		    (while (and (consp (last z)) 
				(< rlevel (caddr (last z))))
		      (setq z (last z)))
		    (nconc1 z r)
		    (setq last-level rlevel)
		    (setq tailend (lastcdr z)))))
	    ;; no, just gobble up the line
	    (read-string) (skip-char "\n\r\f"))))
      ans)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; a help-node is a tree-node whose data is
;; a dynamically loaded ldoc.

(defclass help-node ltree-node file)

(defmethod help-node help-node (lname lfile lkey ldata &optional lchildren)
  (setq data ldata)
  (setq keywords lkey)
  (setq file lfile)
  (setq name lname)
  (each ((c lchildren))
    (==> this insert c)))

(defmethod help-node -destructor () 
  (each ((c (==> this getchildren))) (delete c)))

(defmethod help-node getdata () 
  (when (not data) (setq data (new ldoc)))
  (let ((z (==> data read-when)))
    (if (or (not z) (> (alist-get 'mtime (fileinfo file)) z))
	(read-help-entry file data name)))
  data)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CAUTION: the next three function rely on dynamic binding

(df helpt-file (state lvl f . c)
    (let ((current-file (eval f)))
      (each ((c c)) (eval c))))
      
(df helpt-entry (state lvl name . c) 
    (let* ((n (new help-node (eval name) current-file () ())))
      ;; add node to the help-node tree
      (when current-node (==> current-node insert n))
      ;; add node to the file alist
      (==> current-book put-entry current-file n)
      ;; evaluate content
      (let ((current-node n))
	(each ((c c)) (eval c)))))

(df helpt-noentry (state lvl . c) 
      (each ((c c)) (eval c)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; the help-book contains the tree of help-nodes as
;; well as an alist of filenames and associated help-nodes.
;; It manages the dynamic updating of help topics when
;; program files are re-loaded.
(defclass help-book object
  root
  files)

(defmethod help-book  help-book (f title)
  (setq root (new help-node title "" () ()))
  (setq files (list (list f root)))
  (let* ((help-code  (read-help-headers f 0))
	 (current-file f)
	 (current-node root)
	 (current-book this))
    (eval help-code)))

;; supposed to build the hash table mapping files to nodes
(defmethod help-book  put-entry (f n) 
  (let ((pair (assoc f files)))
    (if pair 
	(nconc1 pair n)
      (setq files (cons (list f n) files)))))

(defmethod help-book make-ltree () (make-ltree-from-tree root))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; turn a full filename into a short one
;; removing the prefix if it is the Lush directory
(de shorten-filename (f) (regex-subst (concat "^" lushdir "/") "" f))

;; parse a single help entry line and return the entry name
(de read-help-entry-name ()
    (let* ((line (read-string "~{\n\r\f\e"))
	   (pattern "^[ \t]*((\\**)[ \t]*((<<)?)[ \t]*(.*))$")
	   (txt (regex_subst "[ \t]+$" "" 
			     (regex-subst pattern "%4" line)))
	   (includep (= (regex-subst pattern "%2" line) "<<")))
      (if includep "" txt)))


;; look for help entry <lname> in file <lfile> 
;; and read it into the ldoc object.
(de read-help-entry (fname theldoc lname)
    (if (not (filep fname))
	(==> theldoc set-file-not-found fname lname)
      (let ((found ())
	    ;; figure out the type of file (.lsh program or .hlp file)
	    (file-type 
	     (selectq (regex-subst ".*(\\.[a-z]+)$" "%0" fname)
	       ((".lsh" ".tl" ".sn")  ".lsh")
	       (t ".hlp"))))
	(reading fname
	  (while (and (not found) (<> (skip-char "~#\e") "\e"))
	    ;; does the line begin with #?
	    (if (and (= (read-string 1) "#")
		     (= (read-string 1) "?"))
		;; yes, parse the rest of the line
		(let ((r (read-help-entry-name)))
		  (when (= r lname)
		    (setq found t)
		    (skip-char "\n")
		    (==> theldoc read-help-body 
			 (shorten-filename fname) lname file-type))))))
	(when (not found)
	  (==> theldoc set-entry-not-found fname lname)))))


;;; ========================================
;;; Help macro
;;; ========================================

;;; ----------------------------------------
;; #? #? <entry>
;;.TYPE DMC
;; This macro marks the node root as outdated.
;; 
;; (dmc |#?|
;;   (when (and file-being-loaded (<> file-being-loaded "$stdin"))
;;     (let ((e (parse-help-entry)))
;;       (==> (find-help-section file-being-loaded (caddr e)) insert e))))
;; 
;; (dmc |#?|
;;   (when (and file-being-loaded (<> file-being-loaded "$stdin"))
;;     (let ((e (parse-help-entry))) ())))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defvar *help-book* ())

;; return the current help book, reading it from the documentation
;; files if necessary. Passing a non-nil <force>, forces
;; re-reading of the help book.
(de read-help-book (force)
  (when (or force (not *help-book*))
    (setq *help-book* (new help-book "lush-manual.hlp" "Lush Manual")))
  *help-book*)

