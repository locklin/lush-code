;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; LUSH Lisp Universal Shell
;;;   Copyright (C) 2002 Leon Bottou, Yann Le Cun, AT&T Corp, NECI.
;;; Includes parts of TL3:
;;;   Copyright (C) 1987-1999 Leon Bottou and Neuristique.
;;; Includes selected parts of SN3.2:
;;;   Copyright (C) 1991-2001 AT&T Corp.
;;;
;;; This program is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 2 of the License, or
;;; (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program; if not, write to the Free Software
;;; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; $Id: compat.lsh,v 1.2 2002-07-19 03:29:19 leonb Exp $
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;;; ----------------------------------------
;;; Casts

;; Yann
(defvar to-float  to-flt)
(defvar to-double to-real)

;; SN3
(defvar flt       to-flt)
(defvar float     to-float)
(defvar real      to-real)
(defvar double    to-double)
(defvar bool      to-bool)
(defvar gptr      to-gptr)
(defvar number    to-number)
(defvar obj       to-obj)
(defvar obj-super to-obj)

(lock-symbol to-float to-double 
             float double flt real 
             bool gptr obj obj-super)


;;; ----------------------------------------
;;; TL3 names for matrix creation functions

(defvar pmatrix packed-matrix)
(defvar bmatrix byte-matrix)
(defvar smatrix short-matrix)
(defvar imatrix int-matrix)
(defvar dmatrix double-matrix)
(defvar fmatrix float-matrix)
(when (not (functionp array))
  (defvar array atom-matrix) )
(when (not (functionp matrix))
  (defvar matrix float-matrix) )
(when (not (functionp submatrix))
  (defvar submatrix sub-index) )


;;; ----------------------------------------
;;; SN3 names for storages

(defvar new-f-storage    float-storage)
(defvar new-d-storage    double-storage)
(defvar new-i32-storage  int-storage)
(defvar new-i16-storage  short-storage)
(defvar new-i8-storage   byte-storage)
(defvar new-u8-storage   ubyte-storage)
(defvar new-gptr-storage gptr-storage)
(defvar new-p-storage    packed-storage)
(defvar new-at-storage   atom-storage)

;;; ----------------------------------------
;;; SN3 names for matrices

(defvar f-matrix float-matrix)
(defvar d-matrix double-matrix)
(defvar i32-matrix int-matrix)
(defvar i16-matrix short-matrix)
(defvar i8-matrix byte-matrix)
(defvar u8-matrix ubyte-matrix)
(defvar p-matrix packed-matrix)
(defvar at-matrix atom-matrix)
(defvar f-matrix-nc float-matrix-nc)
(defvar d-matrix-nc double-matrix-nc)
(defvar i32-matrix-nc int-matrix-nc)
(defvar i16-matrix-nc short-matrix-nc)
(defvar i8-matrix-nc byte-matrix-nc)
(defvar u8-matrix-nc ubyte-matrix-nc)
(defvar p-matrix-nc packed-matrix-nc)
(defvar matrix-nc float-matrix-nc)

;;; ----------------------------------------
;;; Miscellaneous

;; From SN3
(defvar mload libload)
(defvar map-pmatrix map-matrix)
(defvar save-flt-matrix save-matrix)
(defvar save-packed-matrix save-matrix)

;; From SN1 and SN2
(dm dim(f v . l) `(defvar v (matrix ,@l)))

;; From SN1ATT
(defvar defun de)
(defvar += incr)
(defvar << setq)
(defvar diff-lists diff-listes)
(defvar add-lists add-listes)


;;; ----------------------------------------
;;; TL3 statistics on lists
;;; (complete source file 'classify.c')

(de y_estimate((a b r) x)
  (+ (* x a) b) )
(de x_estimate((a b r) y)
  (/ (- y b) a) )
(dm mean_sup_dist (f r1 . r2)
  `(let ((r ,r1)) (/ (sup_dist r ,@r2) (length r))) )
(dm mean_abs_dist (f r1 . r2)
  `(let ((r ,r1)) (/ (abs_dist r ,@r2) (length r))) )
(dm mean_sqr_dist (f r1 . r2)
  `(let ((r ,r1)) (/ (sqr_dist r ,@r2) (length r))) )
(dm mean_hamming_dist (f r1 . r2)
  `(let ((r ,r1)) (/ (hamming_dist r ,@r2) (length r))) )
(dm mean_quadrant_dist (f r1 . r2)
  `(let ((r ,r1)) (/ (quadrant_dist r ,@r2) (length r))) )


;;; ----------------------------------------
;;; SN3 idx-m[012a]{xxx} functions

(mapc (lambda(name)
        (let* ((pn (pname name))
               (new-name (named (concat "idx-" pn)))
               (code `(list 'progn (cons ,(list 'quote new-name) l) ())))
          (eval `(dmd ,(named (concat "idx-m0" pn)) l ,code))
          (eval `(dmd ,(named (concat "idx-m1" pn)) l ,code))
          (eval `(dmd ,(named (concat "idx-m2" pn)) l ,code))
          (eval `(dmd ,(named (concat "idx-ma" pn)) l ,code)) ) )
      '(clear
        copy sum sumacc sumsqrt sumsqrtacc sqrdist sqrdistacc
        dotm0 dotm0acc addm0 addmoacc
        add sub mul div
        minus abs sqrt qtanh qdtanh 
        stdsigmoid dstdsigmoid expmx dexpmx 
        sin cos atan log exp ) )

(mapc (lambda(name)
        (let* ((pn (pname name))
               (new-name (named (concat "idx-" pn)))
               (code `(list 'progn (cons ,(list 'quote new-name) l) ())))
          (eval `(dmd ,(named (concat "idx-m0" pn "m0")) l ,code))
          (eval `(dmd ,(named (concat "idx-m1" pn "m1")) l ,code))
          (eval `(dmd ,(named (concat "idx-m2" pn "m2")) l ,code))
          (eval `(dmd ,(named (concat "idx-ma" pn "ma")) l ,code)) ) )
      '(dot) )

(mapc (lambda(name)
        (let* ((pn (pname name))
               (new-name (named (concat "idx-" pn)))
               (code `(list 'progn (cons `(list 'quote new-name) l) ())))
          (eval `(dmd ,(named (concat "idx-m0" pn "m0acc")) l ,code))
          (eval `(dmd ,(named (concat "idx-m1" pn "m1acc")) l ,code))
          (eval `(dmd ,(named (concat "idx-m2" pn "m2acc")) l ,code))
          (eval `(dmd ,(named (concat "idx-ma" pn "maacc")) l ,code)) ) )
      '(dot) )


;;; ----------------------------------------
;;; SN1 SN2 and TL3 matrix functions

(defvar copy-any-matrix copy-matrix)

(dmd dot-product (a b)
  '(let ((r (matrix)))
     (idx-m1dotm1 `a `b r)
     (r)))

(de m*m (a b &optional c)
  (if (= (idx-ndim a) 1)
      (if (= (idx-ndim b) 1)
          (if (= 1 (idx-dim b 0))
              (if c (let ((-dh-b (matrix))
                          (-dh-a a)
                          (-dh-c c))
                      (-dh-b (b 0))
                      (idx-m1dotm0 -dh-a -dh-b -dh-c)
                      -dh-c)
                (let* ((-dh-b (matrix))
                       (-dh-a a)
                       (-dh-c (clone-matrix -dh-a)))
                  (-dh-b (b 0))
                  (idx-m1dotm0 -dh-a -dh-b -dh-c)
                  -dh-c))
            (error "m*m: idx 2 must have 1 element"))
        (if (= 1 (idx-dim b 0))
            (if c
                (let* ((-dh-b (select b 0 0))
                       (-dh-a a)
                       (-dh-c c))
                  (idx-m1extm1 -dh-a -dh-b -dh-c)
                  -dh-c)
              (let* ((-dh-b (select b 0 0))
                     (-dh-a a)
                     (-dh-c (matrix (idx-dim -dh-a 0) (idx-dim -dh-b 0))))
                (idx-m1extm1 -dh-a -dh-b -dh-c)
                -dh-c))
          (error "m*m: idx 2 have bad dimensions")))
    (if (= 1 (idx-ndim b))
        (if c
            (let ((-dh-c c)) (idx-m2dotm1 a b -dh-c) -dh-c)
          (let* ((-dh-a a)
                 (-dh-b b)
                 (-dh-c (matrix (idx-dim -dh-a 0))))
            (idx-m2dotm1 a -dh-b -dh-c) -dh-c))
      (if c
          (let ((-dh-c c))
            (idx-eloop ((-dh-x b) (-dh-y -dh-c)) 
              (idx-m2dotm1 a -dh-x -dh-y))
            -dh-c)
        (let* ((-dh-a a)
               (-dh-b b)
               (-dh-c (matrix (idx-dim -dh-a 0) (idx-dim -dh-b 1))))
          (idx-eloop ((-dh-x -dh-b) (-dh-y -dh-c)) 
            (idx-m2dotm1 -dh-a -dh-x -dh-y))
          -dh-c)))))

(de m+m (a b &optional c)
  (if ~c (setq c (clone-matrix b)))
  (idx-maadd a b c)
  c)

(de mxm (a b &optional c)
  (if ~c (setq c (clone-matrix b)))
  (idx-mamul a b c)
  c)

(de m-m (a b &optional c)
  (let ((b b))
    (if ~c (setq c (clone-matrix b)))
    (idx-masub a b c)
    c))

(de m*c (a b &optional c)
  (if ~c (setq c (clone-matrix a)))
  (let ((d (matrix)))
    (d b)
    (idx-madotm0 a d c)
    c))

(de m+c (a b &optional c)
  (if ~c (setq c (clone-matrix a)))
  (let ((d (matrix)))
    (d b)
    (idx-maaddm0 a d c)
    c))

(de transpose (m)
  (selectq (idx-ndim m)
    (1 (let ((m2 (idx-clone m)))
         (idx-unfold m2 0 (idx-dim m 0) 1)
         m2))
    (2 (let ((m2 (idx-clone m)))
         (idx-transpose m2 '(1 0))
         m2))
    (t (error 'transpose "Two dimensioned matrix expected" m))))




