$Id: lush-intro.hlp,v 1.2 2002-08-22 07:04:46 profshadoko Exp $

#? **** Introduction to Lush

#? *** What is Lush 

How many times have you 
.IP
wished you had simple interpreted language with which you could quickly
try out idea, implement efficient numerical algorithms, or prototype 
GUI-based applications?  
.IP
written a piece of software in C and wished you could control it from a
simple, interpreted script language? 
.IP
written such a script language interpreter yourself and wished it 
were a full-blown programming language?  
.IP
used an interpreted script-like language, such as Perl, MatLab, 
Mathematica, Tcl, Python, or Visual Basic, and wished the compiler
generated efficient code, and wished it were
easier to call C routines from it?
.IP
written a program with one of the above languages and wished you could
generate a portable standalone application from it? 
.IP
wished you could combine two languages for your programming projects: an
efficient, compiled, no-frills language such as C or C++ for the low-level,
and an interpreted, weakly typed language with smart memory management such as
Lisp for the high level and the user interface?
.PP
If your answer to any of the above questions is ``more than once'', take a
look at Lush.
.PP
Many software projects, particularly research projects, require two languages:
an efficient compiled language such as C or C++ for implementing the low-level
or computationally expensive function, and a flexible, possibly interpreted
language for high-level control, scripting, experimentation, and tinkering.  A
popular instance of this is the Matlab system. Unfortunately, the Matlab
interpreted language is very inefficient, lacks support for complex
data structures, and lacks the power of a full-fledged object-oriented 
programming language.
.PP
Lush is a language that attempts to solve that problem.  Lush is an
object-oriented, Lisp-like language with a seamless interface to C.  
If the name "Lisp" sends shivers down your spine, be advised that 
the dialect of Lisp that Lush implements is probably on of the
simplest to learn and cleanest programming languages you will encounter.
Most scientists and developers that we trained to use Lush
had never touched Lisp before, and became proficient in a few
days. It's very simple really.
.PP
Lush has a large library of matrix algebra routines, numerical routines,
graphic routines, image processing routines, statistics, neural nets,
etc... compiled code and libraries written in C and other languages (.o, .a,
or .so files) can be dynamically loaded into Lush and called from the
interpreter. Lush programs can be compiled into C source code, which can be
dynamically loaded back into the interpreter, or compiled separately as 
standalone programs. In addition, C source code can be freely intermixed with
Lush source code, allowing to use each language for what it does best.
.PP
The Lush compiler has several interesting properties, and a few limitations.  
It compiles Lisp source to C, then uses the machines' C compiler to generate
object code. It then loads the compiled code dynamically into the
interpreter. There are many Lispy things that the compiler can't compile, but
whatever it can compile is turns into efficient code.
.PP
Lush Currently runs on various Unix platforms including
Linux/x86, Solaris, and SGI/Irix.

#? *** What is Lush good for?

Lush is a good tool for a variety of applications. It was originally developed
as an environment for experimentation and development of machine learning
and pattern recognition applications, but over the years, it has grown
into a full-fledged language and rapid development environment.
.PP
Here are examples of situations in which Lush, or its predecessor, SN
have been used:
.IP
 as a simulation environment for neural network and machine 
 learning experiments.
.IP
 as a Matlab-like prototyping tool for numerical computation, 
 signal processing, image processing, statistical estimation,...
.IP
 as a "control language" for many software projects.
.IP
 as a super debugger and diagnostic tool for large applications
.IP
 as a prototyping tool for GUI-based applications (e.g. the
 JSS indexing engine).
.IP
 as a script language for quick hacks.

.PP
Here is a small subset of the research projects that have been done with Lush:
.IP
numerous projects in handrwiting recognition
.IP
many projects in neural network, machine learning, and statistical
estimations 
.IP
data mining, fault detection, and database marketing projects.
.IP
image processing research

.PP
A few full-fledged comercial applications have been built with Lush, including:
.IP
a complete check amount reader now integrated in NCR's automatic
teller machines and large back-office check reading machines (Lush-generated
code runs on DSP boards). This is a huge piece of complicated code (60,000
lines of Lush Lisp code automatically converted to C).
.IP
Early version of the foreground/background segmentation module for 
the DjVu image compression system.
.IP
a neural network simulator and neural network training tool.
.IP
a pen-based data entry systems with handwriting recognition


#? *** A tour of the features

Lush is built around a compact, portable, and intentionally simple Lisp
interpreter written in C. It features all the usual functionalities
and constructs found in every decent object-oriented programming
language such as conditional statements, loops, local variables, functions,
macros, objects, classes, and methods, but it also provides a large number 
of functions for manipulating lists, strings, vectors, matrices, and 
tensors. String functions include such things as regular expression 
matching and substitutions.
.PP
The Lush interpreter is quite similar to other lisps like "Le_Lisp"
and "UCI-Lisp". It is significantly simpler than "Common Lisp"
(the main difference with Common Lisp from the casual user's point of 
view is that new functions are defined with <de> rather than <defun>).
.PP
An unusual feature of Lush is its compiler to C, its dynamic loader,
and the ease with which one can interface existing C functions and
libraries. En even more unusual feature is the ability to intermix
Lisp and C source code within a single function.
.PP
The vector and matrix manipulation engine is quite powerful and efficient,
making Lush ideal for heavy numerical applications and applications such as
signal and image processing. It includes functions to create, resize, and
convert vectors, matrices, and tensors with up to eight dimensions.  It
includes basic matrix operations such as scalar operations on all elements of
a matrix, dot products, outer products, transposition, highly optimized 1D and
2D convolutions. A set of iterators is also provided to access all matrix 
elements without requiring costly bound checking.
.PP
Lush is an object-oriented language. Classes with slots and methods 
can be defined and compiled. Derived classes inherit the slots and 
methods of their parent class (similar to the C++ semantics).
.PP
Lush includes all the functions familiar to Lisp aficionados, such as list
functions, list iterators, physical list manipulation, macros, splicing
macros, symbol manipulation, etc, but most casual users will probably
prefer to stay away from those.
.PP
Lush provides a set of simple-to-use graphic functions to draw 
lines, polygons, rectangles, pictures, and text in color, with automatic 
refresh and double-buffering capability (for simple animations). Graphics 
can be drawn in an X-windows window (on Unix), or sent to a PostScript file.
Those low-level portable graphic functions are used to build high-level 
functionalities, such as function plotting.
.PP
Lush also contains a very compact and easy-to-use object-oriented 
graphical user interface generator called ``Ogre''. Ogre is entirely 
written in Lisp on top of the low-level graphic functions mentioned
above. It contains predefined classes for buttons, sliders, radio buttons,
menus, string editors, etc... Ogre includes an automatic mechanism for placing
objects in the window, thereby greatly simplifying the design and
implementation of GUIs. Simple GUIs can be written in extremely short 
times and are very compact.
.PP
Lush provides two models for Input/Output. One is a set of ``Lispy'' I/O
functions that allow easy input and output of ASCII data, lisp expressions,
lisp objects, and matrices. It includes such goodies as pipes and
sockets. The other model essentially provides access to the standard C I/O
library, including fopen, popen, fprintf, fscanf, fgetc, fputc fgets, and
various functions for reading and writing matrices.
Large matrices can be mapped in the virtual addressing space, instead of
explicitely loaded in memory. This allows to access very large datasets
efficiently. 

#? *** A tour of the Lush Libraries

Lush has a huge collection of libraries and utilities available to the
user.  Some are written in Lisp, some are written in C and interfaced
to Lush, others are pre-existing libraries that have been interfaced to
Lush.
.PP
For our numerically enclined friends, Lush has a full interface to the 
GNU Scientific Library, and to the LAPACK and BLAS Linear Algebra
libraries. This gives access to an extensive set of numerical and
statistical functions (several thousand in fact).
.PP
Lush includes a full interface to the industry-standard OpenGL library that
allows the creation of 3D graphics and animations. This interface
include an interface to GLUT, OpenGLU, and OpenRM (scene graph
rendering engine). This makes Lush an excellent platform to write
interactive VR applications and computer games.
.PP
Another popular library interfaced to Lush is the video game API 
Simple Directmedia Layer (SDL). It is enhanced by a high-level
library that allows the easy manipulation of sprites and movable
screen objects with pixel-accurate collision detection. This,
combined with Lush's simple syntax, makes it ideal for developing 
simple video games and for teaching programming to children.
.PP
Lush contains a library of image processing functions to load, save,
resize and resample, warp, filter, and analyze images. Mathematical 
morphology operations such as connected component analysis, distance 
transform, erosion, and dilation, are also available for bitonal images.
.PP
Lush includes a graph library that allows grammar and finite state machine 
construction, graph transduction and composition, and viterbi search
algorithm.
.PP
Lush includes an extensive library for gradient-based machine learning,
including neural networks, radial basis functions, support vector machines,
and many others. This library is based on an innovative object-oriented design
that allows to build large learning machines out of multiple learning modules
and to train them cooperatively. Commercially used optical recognition systems
have been built with this library.
.PP
As mentioned earlier, Lush has the capability of mapping large matrices stored
on disk directly into its virtual address space. It is also interfaced with
the GNU database library gdbm.
.PP
In addition, Lush provides various interfaces to multimedia libraries,
including Video4Linux (video grabbing) and ALSA (audio recording/playing).

#? *** Why Lisp?

In some segments of the software industry, Lisp is sometimes perceived as 
an oddity of essentially academic interest. Its theoretical computer science
heritage also causes common misconceptions about Lisp, such as being
inefficient and difficult to learn.  So why choose Lisp?  We chose
Lisp because contrary to the common prejudice, it is extremely easy
to learn, in addition to being flexible, efficient, and compact.
Lisp has such a simple, clean and flexible syntax that it is probably 
the easiest language to learn (at the other extreme, you will find
Perl). Our experience with teaching C developers to use Lush is that 
they become proficient at it in a few days. Script language designers 
often make the mistake of not only designing their own language 
functionalities, but also designing their own syntax. Examples 
of this include MatLab, Mathematica, S+, Perl, and many others. 
Why invent a new syntax when a good one such as Lisp
already exists? Lush is an object-oriented dialect of Lisp that puts the
emphasis on ease of use, efficiency for numerical operations (unlike
most traditional Lisp implementations), and easy interfacing with
existing code written in C. 

Another unique advantage of Lisp is that it is a "programable
programing language". In Lisp, a program is just a data structure
that can be created and manipulated just like any other data 
structure. In other words, Lisp programs can create other Lisp programs.
This allows users (and not just language designers) to extend the
language themselves ad infinitum. This feature also makes it easy to 
write such things as syntax transformers, programs that optimize 
themselves, compilers, automatic differentiators, etc. Most users 
will probably stay away from writing such things, but they will
profit from the work of others in these areas (the CLush compiler 
is an example).


