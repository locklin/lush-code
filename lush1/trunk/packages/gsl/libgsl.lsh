;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; LUSH Lisp Universal Shell
;;;   Copyright (C) 2002 Leon Bottou, Yann Le Cun, AT&T Corp, NECI.
;;; Includes parts of TL3:
;;;   Copyright (C) 1987-1999 Leon Bottou and Neuristique.
;;; Includes selected parts of SN3.2:
;;;   Copyright (C) 1991-2001 AT&T Corp.
;;;
;;; Includes information derived from the GSL (Gnu Scientific Library)
;;;   header files which are copyrighted and distributed under the GPL
;;;   by their respective authors.
;;;
;;; This program is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 2 of the License, or
;;; (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program; if not, write to the Free Software
;;; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(libload "gsl/gsl-config")
(libload "gsl/gsl-idx")
(libload "gsl/eigen")
(libload "gsl/linalg")
(libload "gsl/complex")
(libload "gsl/permutation")
(libload "libidx/idx-sort")

;; dummy function that adds GSL C header files in C file
(eval `(de dummy_libgsl () ,gsl-cpheader-cmd ()))


#? **** libgsl: high-level numerical functions
;; This library, built on top of GSL, provides easy
;; calls to the most commonly used numerical and linear
;; algebra functions.

#? *** Linear Algebra
;; This contains such things as linear system solving, matrix 
;; inverse, eigenvalues of symmetric matrices, and singular
;; value decomposition.

#? (eigen-symm <m>)
;; Compute eigenvalues of symmetric real matrix <m>.
;; Vector of sorted eigenvalues is returned. Input matrix is destroyed.
;; to call non-destructively, do {<c> (eigen-symm (idx-copy m))}.
(de eigen-symm (m)
  ((-idx2- (-double-)) m)
  (let ((v (double-matrix (idx-dim m 0)))
	(p (gsl_eigen_symm_alloc (idx-dim m 0))))
    (idx2gsl (gsl-eigen-symm m v p))
    (gsl_eigen_symm_free p)
    (idx-d1sortdown v)
    v))

#? (eigen-symmv <m>)
;; Compute eigenvectors and eigenvalues of symmetric matrix <m>.
;; Eigenvectors are written into <m> (each column is an eigenvector).
;; Eigenvalues are returned in an idx1.
;; Eigenvalues and eigenvectors are sorted in descending order.
(de eigen-symmv (m)
  ((-idx2- (-double-)) m)
  (let ((v (double-matrix (idx-dim m 0)))
	(ev (double-matrix (idx-dim m 0) (idx-dim m 1)))
	(p (gsl_eigen_symmv_alloc (idx-dim m 0))))
    (idx2gsl (gsl-eigen-symmv m v ev p))
    (idx2gsl (gsl_eigen_symmv_sort v ev 1))
    (gsl_eigen_symmv_free p)
    (idx-copy ev m)
    v))

#? (eigen-herm <m>)
;; Compute eigenvalues of Hermitian complex matrix <m>
;; (NxMx2 matrix). Vector of sorted eigenvalues is returned. 
;; Input matrix is destroyed.
;; to call non-destructively, do {<c> (eigen-herm (idx-copy m))}.
(de eigen-herm (m)
  ((-idx3- (-double-)) m)
  (let ((v (double-matrix (idx-dim m 0)))
	(p (gsl_eigen_herm_alloc (idx-dim m 0))))
    (idx2gsl (gsl-eigen-herm m v p))
    (gsl_eigen_herm_free p)
    (idx-d1sortdown v)
    v))

#? (eigen-hermv <m>)
;; Compute eigenvalues and eigenvectors of Hermitian complex matrix <m>.
;; Vector of eigenvalues is returned. Input matrix is filled
;; with eigenvectors on exit (each column is an eigenvector).
(de eigen-hermv (m)
  ((-idx3- (-double-)) m)
  (let ((v (double-matrix (idx-dim m 0)))
	(ev (double-matrix (idx-dim m 0) (idx-dim m 1) (idx-dim m 2)))
	(p (gsl_eigen_hermv_alloc (idx-dim m 0))))
    (idx2gsl (gsl-eigen-hermv m v ev p))
    (idx2gsl (gsl_eigen_hermv_sort v ev 1))
    (gsl_eigen_hermv_free p)
    (idx-copy ev m)
    v))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#? (svd <A> <V> <S>)
;; [from the GSL manual]: This function factorizes the M-by-N matrix A
;; into the singular value decomposition A = U S V^T. On output the
;; matrix A is replaced by U. The diagonal elements of the singular value
;; matrix S are stored in the vector S. The singular values are
;; non-negative and form a non-increasing sequence from S_1 to S_N. The
;; matrix V contains the elements of V in untransposed form. To form the
;; product U S V^T it is necessary to take the transpose of V. 
;; This routine uses the Golub-Reinsch SVD algorithm. Example:
;; {<code>
;;   (setq a [[1 2][3 4][5 6]])
;;   (setq v (double-matrix 2 2))
;;   (setq s (double-matrix 2))
;;   (svd a v s)
;; </code>}
(de svd (a v s)
  ((-idx2- (-double-)) a v)
  ((-idx1- (-double-)) s)
  (let ((n (idx-dim a 1)))
    (when (< (idx-dim a 0) n)
      (error "must have M>=N for SVD of MxN matrix"))
    (when (or (<> n (idx-dim v 0))
	      (<> n (idx-dim v 1))
	      (<> n (idx-dim s 0)))
      (error "incompatible matrix sizes for SVD")))
  (let ((w (double-matrix (idx-dim a 1))))
    (idx2gsl (gsl_linalg_SV_decomp a v s w)))))

#? (solve-hh <a> <b>)
;; This function solves the system A x = b in-place using Householder
;; transformations. On input <b> should contain the right-hand side,
;; which is replaced by the solution on output. The matrix <a> is destroyed
;; by the Householder transformations. Example:
;; {<code>
;; (setq a [[1 2][3 4]])
;; = [[ 1.00  2.00 ]
;;    [ 3.00  4.00 ]]
;; ? (setq b [4 4])
;; = [ 4.00  4.00 ]
;; ? (lin-solve a b)
;; = 0
;; ? b
;; = [-4.00  4.00 ]
;; </code>}
(de solve-hh (a b)
  ((-idx2- (-double-)) a)
  ((-idx1- (-double-)) b)
  (idx2gsl (gsl_linalg_HH_svx a b)))


#? (solve-lu <a> <b>)
;; This function solves the system A*x=b using LU decomposition.
;; the result is put in <b> on output. Matrix <a> is also 
;; destroyed in the process.
(de solve-lu (a b)
  ((-idx2- (-double-)) a)
  ((-idx1- (-double-)) b)
  (let ((permut (gsl_permutation_alloc (idx-dim a 0)))
	(signum (int-matrix))
	(a-gsl (gsl-matrix-double-idx-ptr a))
	(b-gsl (gsl-vector-double-idx-ptr b)))
  (gsl_linalg_LU_decomp a-gsl permut (idx-ptr signum))
  (gsl_linalg_LU_svx a-gsl permut b-gsl)
  (gsl_permutation_free permut)
  (free a-gsl) (free b-gsl)) 0)

#? (solve-lu-complex <a> <b>)
;; This function solves the complex system A*x=b using LU decomposition.
;; the result is put in <b> on output. Matrix <a> is also 
;; destroyed in the process.
(de solve-lu-complex (a b)
  ((-idx3- (-double-)) a)
  ((-idx2- (-double-)) b)
  (let ((permut (gsl_permutation_alloc (idx-dim a 0)))
	(signum (int-matrix))
	(a-gsl (gsl-matrix-complex-double-idx-ptr a))
	(b-gsl (gsl-vector-complex-double-idx-ptr b)))
  (gsl_linalg_complex_LU_decomp a-gsl permut (idx-ptr signum))
  (gsl_linalg_complex_LU_svx a-gsl permut b-gsl)
  (gsl_permutation_free permut)
  (free a-gsl) (free b-gsl)) 0)


#? (solve-sv <a> <b>)
;; [adapted from the GSL manual]: This function solves the linear system 
;; A*x=b using singular value decomposition. 
;; the result is put in <b> on output. Matrix <a> is also 
;; destroyed in the process. Only non-zero singular
;; values are used in computing the solution. The parts of the
;; solution corresponding to singular values of zero are ignored. In
;; the over-determined case where A has more rows than columns the
;; system is solved in the least squares sense, returning the solution x
;; which minimizes the square norm of (A*x-b).
(de solve-sv (a b)
  ((-idx2- (-double-)) a)
  ((-idx1- (-double-)) b)
  (let ((n (idx-dim a 1)))
    (when (< (idx-dim a 0) n)
      (error "must have M>=N for SVD of MxN matrix"))
    (when (<> n (idx-dim b 0))
      (error "incompatible vector/matrix sizes for SVD solver"))
    (let* ((v (double-matrix-nc n n))
	   (s (double-matrix-nc n))
	   (w (double-matrix-nc n))
	   (x (double-matrix-nc n))
	   (a-gsl (gsl-matrix-double-idx-ptr a))
	   (b-gsl (gsl-vector-double-idx-ptr b))
	   (x-gsl (gsl-vector-double-idx-ptr x))
	   (s-gsl (gsl-vector-double-idx-ptr s))
	   (v-gsl (gsl-matrix-double-idx-ptr v))
	   (w-gsl (gsl-vector-double-idx-ptr w)))
      (gsl_linalg_SV_decomp a-gsl v-gsl s-gsl w-gsl)
      (gsl_linalg_SV_solve a-gsl v-gsl s-gsl b-gsl x-gsl)
      (idx-copy x b)
      (free a-gsl) (free b-gsl) (free x-gsl) (free v-gsl) (free w-gsl)) 0))
    

#? (inverse-lu <a> <i>)
;; This function computes the inverse of a matrix <a> using LU
;; decomposition, storing the result in the matrix <i>. The
;; inverse is computed by solving the system A*x=b for each column
;; of the identity matrix. It is preferable to avoid direct
;; computation of the inverse whenever possible.
(de inverse-lu (a i)
  ((-idx2- (-double-)) a i)
  (when (<> (idx-dim a 0) (idx-dim a 1))
    (error "matrix is not square"))
  (when (or (<> (idx-dim a 0) (idx-dim i 0))
	    (<> (idx-dim a 1) (idx-dim i 1)))
    (error "matrix and its inverse have different sizes"))
  (let ((permut (gsl_permutation_alloc (idx-dim a 0)))
	(signum (int-matrix))
	(a-gsl (gsl-matrix-double-idx-ptr a))
	(i-gsl (gsl-matrix-double-idx-ptr i)))
    (gsl_linalg_LU_decomp a-gsl permut (idx-ptr signum))
    (gsl_linalg_LU_invert a-gsl permut i-gsl)
    (gsl_permutation_free permut)
    (free a-gsl) (free i-gsl)) 0)


#? (determinant <a>)
;; compute the determinant of a matrix <a> using LU decomposition.
;; Matrix <a> is destroyed in the process.
(de determinant (a)
  ((-idx2- (-double-)) a)
  (when (<> (idx-dim a 0) (idx-dim a 1))
    (error "matrix is not square"))
  (let ((permut (gsl_permutation_alloc (idx-dim a 0)))
	(signum (int-matrix))
	(a-gsl (gsl-matrix-double-idx-ptr a)))
    (gsl_linalg_LU_decomp a-gsl permut (idx-ptr signum))
    (prog1 
	(gsl_linalg_LU_det a-gsl (signum))
      (gsl_permutation_free permut)
      (free a-gsl))))

#? (determinant-log <a>)
;; compute the log of the absolute value of the determinant of
;; real matrix <a> using LU decomposition. This function should be
;; used when the regular determinant function would cause an overflow
;; or underflow. Matrix <a> is destroyed in the process.
(de determinant-log (a)
  ((-idx2- (-double-)) a)
  (when (<> (idx-dim a 0) (idx-dim a 1))
    (error "matrix is not square"))
  (let ((permut (gsl_permutation_alloc (idx-dim a 0)))
	(signum (int-matrix))
	(a-gsl (gsl-matrix-double-idx-ptr a)))
    (gsl_linalg_LU_decomp a-gsl permut (idx-ptr signum))
    (prog1 
	(gsl_linalg_LU_lndet a-gsl)
      (gsl_permutation_free permut)
      (free a-gsl))))

#? (determinant-sign <a>)
;; compute the sign the determinant of
;; real matrix <a> using LU decomposition. 
;; Matrix <a> is destroyed in the process.
(de determinant-sign (a)
  ((-idx2- (-double-)) a)
  (when (<> (idx-dim a 0) (idx-dim a 1))
    (error "matrix is not square"))
  (let ((permut (gsl_permutation_alloc (idx-dim a 0)))
	(signum (int-matrix))
	(a-gsl (gsl-matrix-double-idx-ptr a)))
    (gsl_linalg_LU_decomp a-gsl permut (idx-ptr signum))
    (prog1 
	(gsl_linalg_LU_sgndet a-gsl (signum))
      (gsl_permutation_free permut)
      (free a-gsl))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; complex ops


#? *** Operations on Complex Numbers
;; complex numbers as manipulated by these functions
;; are simply represented as an idx1 of double with 2 elements.
;; Creating a complex literal can be done with {<c> (setq z [3 4])},
;; just like with vectors literal.
;; Allocating an empty complex is done with {<c> (setq z (new-complex))},
;; which is equivalent to {<c> (setq z (double-matrix 2))}.

#? (new-complex)
;; returns a new complex (i.e. an idx1 of double of size 2).
(dmd new-complex () `(double-matrix 2))

#? ** Complex functions that return a real

#? (carg <z>)
;; argument of <z> (returns angle between -pi and pi).
#? (cabs <z>)
;; magnitude/modulus of <z>
#? (cabs2 <z>)
;; sqaure magnitude/square modulus of <z>
#? (clogabs<z>)
;; logarithm of magnitude of <z>.

#? ** Dyadic Complex Operators
;; these functions allocate and return a complex result.
;; example:
;; {<code>
;; ? (c* [1 2] [3 5])
;; = [-7.00 11.00 ]
;; </code>}

#? (c+ <a> <b>)
;; addition
#? (c- <a> <b>)
;; subtraction
#? (c* <a> <b>)
;; product
#? (c/ <a> <b>)
;; division
#? (c** <a> <b>)
;; power
#? (clogb <a> <b>)
;; compute log(<a>)/log(<b>), logarithms of <a> in complex base <b>.

#? ** Unary Complex Operators
;; complex functions that return a complex.
;; example:
;; {<code>
;;  ? (csqrt [0 2])
;;  = [ 1.00  1.00 ]
;; </code>}

#? (cconjugate <z>)
;; complex conjugate
#? (cinverse <z>)
;; complex inverse
#? (cnegative <z>)
;; negative
#? (csqrt <z>)
;; square root
#? (cexp <z>)
;; exponential
#? (clog <z>)
;; log
#? (clog10 <z>)
;; log base 10
#? (csin <z>)
;; sine
#? (ccos <z>)
;; cosine
#? (ctan <z>)
;; tangent
#? (csec <z>)
;; secant
#? (ccsc <z>)
;; cosecant
#? (ccot <z>)
;; cotangent
#? (carcsin <z>)
;; arcsine
#? (carccos <z>)
;; arccosine
#? (carctan <z>)
;; arctangent
#? (csinh <z>)
;; hyperbolic sine
#? (ccosh <z>)
;; hyperbolic scosine
#? (ctanh <z>)
;; hyperbolic tangent
#? (csech <z>)
;; hyperbolic secant
#? (ccsch <z>)
;; hyperbolic cosecant
#? (ccoth <z>)
;; hyperbolic cotangent
#? (carcsinh <z>)
;; hyperbolic arcsine
#? (carccosh <z>)
;; hyperbolic arccos
#? (carctanh <z>)
;; hyperbolic arctangent
#? (carcsech <z>)
;; hyperbolic arcsecant


(dm def-complex-op2 (s op func)
  `(de ,(eval op) (a b)
     ((-idx1- (-double-)) a b)
     (let ((r (double-matrix 2)))
       (,(eval func) (idx-ptr a) (idx-ptr b) (idx-ptr r)) r)))

(dm def-complex-op1 (s op func)
  `(de ,(eval op) (a)
     ((-idx1- (-double-)) a)
     (let ((r (double-matrix 2)))
       (,(eval func) (idx-ptr a) (idx-ptr r)) r)))

(each ((z '((c+ gsl_complex_add)
	    (c- gsl_complex_sub)
	    (c* gsl_complex_mul)
	    (c/ gsl_complex_div)
	    (c** gsl_complex_pow)
	    (clogb gsl_complex_log_b))))
  (def-complex-op2 (car z) (cadr z)))

(de carg (z)
  ((-idx1- (-double-)) z)
  (double #{ gsl_complex_arg (*IDX_PTR($z,gsl_complex)) #} ))
(de cabs (z)
  ((-idx1- (-double-)) z)
  (double #{ gsl_complex_abs (*IDX_PTR($z,gsl_complex)) #} ))
(de cabs2 (z)
  ((-idx1- (-double-)) z)
  (double #{ gsl_complex_abs2 (*IDX_PTR($z,gsl_complex)) #} ))
(de clogabs (z)
  ((-idx1- (-double-)) z)
  (double #{ gsl_complex_logabs (*IDX_PTR($z,gsl_complex)) #} ))

(each ((z '((cconjugate gsl_complex_conjugate)
	    (cinverse gsl_complex_inverse)
	    (cnegative gsl_complex_negative)
	    (csqrt gsl_complex_sqrt)
	    (cexp gsl_complex_exp)
	    (clog gsl_complex_log)
	    (clog10 gsl_complex_log10)
	    (csin gsl_complex_sin)
	    (ccos gsl_complex_cos)
	    (ctan gsl_complex_tan)
	    (csec gsl_complex_sec)
	    (ccsc gsl_complex_csc)
	    (ccot gsl_complex_cot)
	    (carcsin gsl_complex_arcsin)
	    (carccos gsl_complex_arccos)
	    (carctan gsl_complex_arctan)
	    (csinh gsl_complex_sinh)
	    (ccosh gsl_complex_cosh)
	    (ctanh gsl_complex_tanh)
	    (csech gsl_complex_sech)
	    (ccsch gsl_complex_csch)
	    (ccoth gsl_complex_coth)
	    (carcsinh gsl_complex_arcsinh)
	    (carccosh gsl_complex_arccosh)
	    (carctanh gsl_complex_arctanh)
	    (carcsech gsl_complex_arcsech)
	    (carccsch gsl_complex_arccsch)
	    (carccoth gsl_complex_arccoth)
	    )))
  (def-complex-op1 (car z) (cadr z)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#? (polynomial <p> <x>)
;; evaluate polynomial p0 + p1*x + p2*x^2 + ....
;; using Horner's method. <p> is an idx1 of double.
(de polynomial (p x)
  ((-idx1- (-double-)) p)
  ((-double-) x)
  (double #{ gsl_poly_eval( IDX_PTR($p,double) ,$(idx-dim p 0) ,$x) #} ))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(dhc-make 
 ()
 dummy_libgsl

 eigen-symm
 eigen-symmv
 eigen-herm
 eigen-hermv
 svd
 solve-hh
 solve-lu
 solve-lu-complex
 solve-sv
 inverse-lu
 determinant
 determinant-log
 determinant-sign

 c+ c- c* c/ c** clogb
 carg cabs cabs2 clogabs

 cconjugate cinverse cnegative csqrt cexp clog clog10 csin ccos ctan
 csec ccsc ccot carcsin carccos carctan csinh ccosh ctanh csech ccsch
 ccoth carcsinh carccosh carctanh carcsech

 polynomial
 )
