;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; PSU Lush
;;;   Copyright (C) 2005 Ralf Juengling
;;; LUSH Lisp Universal Shell
;;;   Copyright (C) 2002 Leon Bottou, Yann Le Cun, AT&T Corp, NECI.
;;; Includes parts of TL3:
;;;   Copyright (C) 1987-1999 Leon Bottou and Neuristique.
;;; Includes selected parts of SN3.2:
;;;   Copyright (C) 1991-2001 AT&T Corp.
;;;
;;; This program is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 2 of the License, or
;;; (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program; if not, write to the Free Software
;;; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#? *** Organizing multiple windows with tilings
;; A tiling is a partition of the screen area into rectangular
;; regions, called 'slots'. The <tilewin> command places windows
;; on the screen in slots, according to the current tiling.Slots
;; are numbered; for a 3x4 tiling, for example, the slots are 
;; arranged like this:
;; {<pre>
;;    ---------------------
;;    |  1 |  2 |  3 |  4 |   
;;    ---------------------
;;    |  5 |  6 |  7 |  8 |   
;;    ---------------------
;;    |  9 | 10 | 11 | 12 |   
;;    ---------------------
;; </pre>}
;; Command <new-tiling> creates a new tiling, <tilewin> places a
;; window in a tiling, and <make-current> changes the current
;; tiling.
;;
;; If you find yourself using window tilings frequently, you 
;; might want to add these lines to you <lushrc.lsh> file:
;; {<code>
;; (libload "tiling")
;; (import all from tiling-)
;; (make-current (new-tiling 3 4))
;; </code>}

(defvar *current-tiling* ())

(defvar *screen-size*
  (let ((s (reading "| xdpyinfo | grep dimensions" (read-string))))
    (mapcar val (regex-extract ".+ ([0-9]+)x([0-9]+) .+" s))))

(defvar *tiling-decoration-width* 8)   ; window decoration width 
(defvar *tiling-decoration-height* 25) ; and height per window
(defvar *tiling-panel-width* 0)        ; width and height of
(defvar *tiling-panel-height* 23)      ; desktop panel

;; some utilities

(defun -find-free-slot (tl)
  (let ((tl (idx-flatten tl)) (n 0))
    (while (and (< n (length tl)) (tl n))
      (incr n) )
    (if (= n (length tl)) 
	-1 
      (tl n ())
      n) ))

(defun -calc-tiling-rects (n m)
  (let* ((rects (atom-array (* n m)))
	 (ew *tiling-decoration-width*) 
	 (eh *tiling-decoration-height*)
         (dw *tiling-panel-width*)
         (dh *tiling-panel-height*)
	 (pw (- (car *screen-size*) (* m ew) dw))
	 (ph (- (cadr *screen-size*) (* n eh) dh))
	 (width (/ m))
	 (height (/ n)) )
    (for* (k 0 (length rects))
      (let* ((b (div k m)) (bottom (* height b))
	     (l (mod k m)) (left (* width l)) )
	(rects k (list
		  (round (+ (* left pw) (* l ew) dw))
		  (round (+ (* bottom ph) (* b eh) dh))
		  (round (* width pw))
		  (round (* height ph)) ))))
    rects))

#? (new-tiling <n> [<m>])
;; {<see> tilewin}
;; Create a new empty tiling and return it.
;;
;; With one argument create a smallest possible tiling with at least
;; <n> slots. With two arguments create an <n>x<m> tiling.
(defun new-tiling args
  (let ((n -1) (m -1))
    (selectq (length args)
      (1 (setq n (floor (sqrt (car args)))  m (ceil (sqrt (car args))))
	 (when (< (* m n) (car args))
	   (setq n (ceil (sqrt (car args)))  m (ceil (sqrt (car args)))) ))
      (2 (setq n (car args)  m (cadr args)))
      (t (error "wrong number of arguments")) )
    (let ((tl (atom-array n m)))
      (putp tl 'rects (-calc-tiling-rects n m))
      tl)))

#? ** Namespace tiling-
;; The following commands are defined in namespace <tiling->.

(in-namespace tiling-

#? (tiling-tilewin [<n> [<tiling> [<win>]]])
;; {<see> tilewin*, tilewin!}
;; Place window <win> in <tiling> at slot <n> and return the window.
;; Hide <win> when <tiling> is not the current tiling and raise it otherwise.
;; 
;; When no window is given (or when <win> is <()>), create a new one. When no
;; tiling is given (or when <tiling> is <()>), use the current tiling. When no
;; slot number is given (or when <n> is <()>), use the first free slot in 
;; tiling. 
;;
;; The use of <tilewin> does not change the value of global <window>.
(defun tilewin (&optional n tl win clear-slot)
  (let ((tl* (if tl tl :*current-tiling*)) (rects ()))
    (when (null tl*) (error "there is no current tiling"))
    (setq rects (getp tl* 'rects)  tl (idx-flatten tl*))

    (setq n (if n n (-find-free-slot tl)))
    (when (< n 0) (error "all slots occupied" tl))
    (when (or (tl n)) 
      (if clear-slot
          (delete (tl n))
        (error "slot already occupied" n)))
    
    (let ((window ())) ; protect global <window>
      (setq win (if win win (apply new-window (rects n))))
      (if (is-of-class win |WINDOW|)
	  (tl n win)
	(error "not a window" win))
      (setq window win)
      (if (== tl* :*current-tiling*)
	  (apply (gdriver-feature configure loose) t (rects n))
	((gdriver-feature hide loose)) ))
    win))

#? (tiling-tilewin* [<n> [<tiling> [<win>]]])
;; {<see> tilewin, tilewin!}
;; Same as <tilewin>, but in addition set <window> to the result.
(defmacro tilewin* args
  `(setq window (tilewin ,@args))
  )

#? (tiling-tilewin! [<n> [<tiling> [<win>]]])
;; {<see> tilewin, tilewin*}
;; Same as <tilewin>, but in addition delete old window when slot <n> is occupied.
(defmacro tilewin! (&optional n tl win)
  `(tilewin ,n ,tl ,win t)
  )

#? (tiling-hide [<tiling>])
;; Iconify all windows in <tiling> and return <()>.
;; When no tiling is given use default tiling.
(defun hide (&optional tl)
  (let ((tl (or tl :*current-tiling*)))
    (when (null tl)
      (error "there is no current tiling"))
    (do ((win (idx-flatten tl)))
      (when (or (win))
	(let ((window (win))) 
	  ((gdriver-feature #:hide loose)) ))))
  ())

#? (tiling-raise [<tiling>])
;; Place all windows in <tiling> on top and return <()>.
;; When no tiling is given use default tiling.
(defun raise (&optional tl)
  (let* ((tl (or tl :*current-tiling*))
	 (rects (getp tl 'rects)) )
    (when (null tl)
      (error "there is no current tiling"))
    (do ((win (idx-flatten tl)) (rect rects))
      (when (or (win))
	(let ((window (win)))
	  (apply (gdriver-feature configure loose) t (rect)) ))))
  ())
    
#? (tiling-close <n> [<tiling>])
;; Close window in slot <n> of <tiling> and return <()>
;; When no tiling is given use default tiling.

#? (tiling-close all [<tiling>])
;; Close all windows in <tiling> and return <()>.
;; When no tiling is given use default tiling.
(df close (|_n_| &optional |_tl_|)
  (let ((n (if (symbolp |_n_|) (if (= |_n_| 'all) -1 (eval |_n_|)) |_n_|))
	(tl (or (eval |_tl_|) :*current-tiling*)) )
    (when (not (numberp n))
      (error "not a slot number" n))
    (when (> n (length (idx-flatten tl)))
      (error "not a valid slot number" n))
    (when (null tl)
      (error "there is no current tiling"))
    (if (> n -1)
	(delete ((idx-flatten tl) n))
      (do ((win (idx-flatten tl)))
	(when (or (win)) (delete (win))) )))
  ())

#? (tiling-make-current <tiling>)
;; Hide the current tiling, make <tiling> current and raise it, return the
;; old current tiling.
(defun make-current (tl)
  (if (== tl :*current-tiling*)
      tl
    (when :*current-tiling*
      (hide :*current-tiling*))
    (raise tl)
    (prog1 :*current-tiling* 
      (setq :*current-tiling* tl) )))

#? (tiling-retile [<n> <m> [<tiling>]])
;; Reshape <tiling> to <n>x<m> and replace all windows to compactly fill
;; the tiling. Return the reshaped <tiling>.
;; Note: If the number <n>*<m> of slots is reduced, there must remain enough
;; slots for the already placed windows.
;; When no tiling is given, use the current tiling.
(defun retile (&optional n m tl*)
  (let ((tl* (or tl* :*current-tiling*)))
    (when (null tl*)
      (error "there is no current tiling"))
    (when (null m)
      (setq n (idx-shape tl* 0)  m (idx-shape tl* 1)) )
    (let* ((count 0) (tl (idx-flatten tl*)) (remap (int-array (length tl))))
      (array-clear remap -1)
      (for* (i 0 (length tl)) 
	(when (or (tl i)) (incr count)))
      (when (> count (* n m))
	(error "not enough slots in tiling of this shape" (list n m)) )
      ;; replace windows
      (for (i (- (length tl) 1) 0 -1)
	(when (or (tl i))
	  (decr count)
	  (remap count i) ))
      (for* (i 0 (length tl))
	(if (> (remap i) -1)
	    (tl i (tl (remap i)))
	  (tl i ()) ))
      ;; reshape
      (when (> (* n m) (length tl))
	(array-extend! tl 0 (* n m) ()) )
      (when (< (* n m) (length tl))
	(idx-trim! tl 0 0 (* n m)) )
      (setq tl (idx-reshape tl (list n m)))
      (putp tl 'rects (-calc-tiling-rects n m))
      (if (== tl* :*current-tiling*)
	  (raise (setq :*current-tiling* tl))
	(do ((win (idx-flatten tl)) (rect (getp tl 'rects)))
	  (when (or (win))
	    (let ((window (win)))
	      (apply (gdriver-feature configure loose) () (rect)) ))))
      tl)))

) ; namespace tiling-

(defun -test-tiling ()
  (in-namespace tiling-
  (make-current (new-tiling 3 4))
  (tilewin)
  (tilewin)
  (tilewin)
  (tilewin)
  (tilewin)
  (delete (*current-tiling* 0 1))
  (retile)
  (retile 2 2)
  (retile 2 8)
  (retile 4 4)
  (retile 3 4) ))