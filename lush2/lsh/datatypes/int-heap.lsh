;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; LUSH Lisp Universal Shell
;;;   Copyright (C) 2009 Leon Bottou, Yann Le Cun, Ralf Juengling.
;;;   Copyright (C) 2002 Leon Bottou, Yann Le Cun, AT&T Corp, NECI.
;;; Includes parts of TL3:
;;;   Copyright (C) 1987-1999 Leon Bottou and Neuristique.
;;; Includes selected parts of SN3.2:
;;;   Copyright (C) 1991-2001 AT&T Corp.
;;;
;;; This program is free software; you can redistribute it and/or modify
;;; it under the terms of the Lesser GNU General Public License as 
;;; published by the Free Software Foundation; either version 2 of the
;;; License, or (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program; if not, write to the Free Software
;;; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(libload "datatypes/small-int-set")

#? ** IntHeap
;; A heap for integer items
;;
;; Inserting new items and finding the item with smallest key are
;; fast operations.

(defclass IntHeap -iterator
  ((-srg- (-double-)) keys)
  ((-srg- (-int-))    dir)
  ((-int-)            nkeys)
  ((-int-)            capacity) )

(in-namespace (class IntHeap)

(defmacro parent (i)
  `(trunc (/ (to-double (- ,i 1)) 2)) )

(defmacro left-child (i)
  `(+ ,i ,i 1) )

(defmacro right-child (i)
  `(+ ,i ,i 2) )

)

#? (new IntHeap <n>)
;; Create a new min-heap with initial capacity for <n> integer
;; items.
;;
;; This is an implicit implementation of a binary heap storing
;; integer items. Class <IntHeap> supports the iterator protocol.
(defmethod IntHeap IntHeap (size)
  (declare (-int-) size)
  (setq dir (idx-storage (int-array (max 32 size))))
  (setq keys (idx-storage (double-array (max 32 size))))
  (setq nkeys 0)
  (setq capacity (storage-nelems dir))
  ())

(defmethod IntHeap -restore-heap-up (i)
  (declare (-int-) i)
  (assert (< i nkeys))
  (when (> i 0)
    (let ((j (parent i)))
      (declare (-int-) j)
      (when (< (keys i) (keys j)) ; this is a min heap
	(let ((keyi (keys i)) (diri (dir i)))
	  (declare (-int-) diri)
	  (keys i (keys j)) (keys j keyi)
	  (dir i (dir j))   (dir j diri)
	  (declare (-method- (IntHeap) ((-int-)) (-bool-)) -restore-heap-up)
	  (==> this -restore-heap-up j) ))))
  ())

(defmethod IntHeap -restore-heap-down (i)
  (declare (-int-) i)
  (assert (> i -1))
  (when (< i nkeys)
    (let ((j (left-child i)))
      (declare (-int-) j)
      (when (< j nkeys)
	(when (< (keys j) (keys i))
	  (let ((keyi (keys i)) (diri (dir i)))
	    (declare (-int-) diri)
	    (keys i (keys j)) (keys j keyi)
	    (dir i (dir j))   (dir j diri)
	    (declare (-method- (IntHeap) ((-int-)) (-bool-)) -restore-heap-down)
	    (==> this -restore-heap-down j) ))
	(setq j (right-child i))
	(when (< j nkeys)
	  (when (< (keys j) (keys i))
	    (let ((keyi (keys i)) (diri (dir i)))
	      (declare (-int-) diri)
	      (keys i (keys j)) (keys j keyi)
	      (dir i (dir j))   (dir j diri)
	      (==> this -restore-heap-down j) ))))))
  ())

#? (==> <IntHeap> insert <k> <i>)
;; Insert new item <i> with key/priority <k> into the heap.
(defmethod IntHeap insert (key i)
  (declare (-double-) key)
  (declare (-int-) i)
  (when (= nkeys capacity)
    (setq capacity (* 2 capacity))
    (storage-realloc keys capacity)
    (storage-realloc dir  capacity)
    )
  (let ((n nkeys))
    (declare (-int-) n)
    (incr nkeys)
    (dir n i)
    (keys n key)
    (==> this -restore-heap-up n) )
  ())


#? (==> <IntHeap> insert-all <ks> <is>)
;; Insert all items in <is> with corresponding key in <ks>.
(defmethod IntHeap insert-all (ks is)
  (declare (-idx1- (-double-)) ks)
  (declare (-idx1- (-int-)) is)
  (when (<> (length ks) (length is))
    (error "lengths of keys and items do not match") )
  (idx-bloop ((k ks) (i is))
    (==> this insert (k) (i)) )
  ())
      
#? (==> <IntHeap> number-of-items)
;; Number of items in the heap.
(defmethod IntHeap number-of-items ()
  nkeys)

#? (==> <IntHeap> key)
;; Return current minimum key.
(defmethod IntHeap key ()
  (when (= nkeys 0) (error "No more items"))
  (keys 0) )

#? (==> <IntHeap> peeknext)
;; Return the minimum-key item without removing it from the heap.
(defmethod IntHeap peeknext ()
  (when (= nkeys 0) (error "No more items"))
  (dir 0) )

#? (==> <IntHeap> next)
;; Remove the minimum-key item from the heap and return it.
(defmethod IntHeap next ()
  (prog1 (==> this peeknext)
    (decr nkeys)
    (dir 0 (dir nkeys))
    (keys 0 (keys nkeys))
    (==> this -restore-heap-down 0)
    ))

#? (==> <IntHeap> drop-lt <min-key>)
;; Remove all items with key strictly less than <min-key> and
;; return key of new minimum item in heap or <NaN> when heap is
;; empty.
(defmethod IntHeap drop-lt (mk)
  (declare (-double-) mk)
  (while (and (> nkeys 0) (< (keys 0) mk))
    (==> this next) )
  (if (emptyp dir)
      NAN
    (keys 0) ))

#? (==> <IntHeap> clear)
;; Clear heap. After calling this method the heap object is empty.
(defmethod IntHeap clear ()
  (setq nkeys 0)
  ())

(defmethod IntHeap -emptyp ()
  (= nkeys 0) )

(defmethod IntHeap -iterate ()
  this)


(defclass SmallIntHeap -iterator
  ((-obj- (IntHeap))     hp)      ; the actual heap
  ((-srg- (-int-))       dir)     ; heap's dir
  ((-srg- (-double-))    keys)    ; heap's keys
  ((-obj- (SmallIntSet)) ints)    ; set of live items 
  ((-idx1- (-double-))   ckeys) ) ; current keys

#? (new SmallIntHeap <n>)
;; Create a new heap for integer items in range [0..<n-1>].
;; 
;; A <SmallIntHeap> offers deletion of items and updating of item
;; keys. Unlike an <IntHeap>, a <SmallIntHeap> keeps only one instance
;; of an item in the heap (items are unique). Use method <insert> to
;; insert an new item or to change an item's key.
;;
;; This heap implementation requires that the possible item values
;; are in a fixed range [0..<n-1>], where <n> must be specified at
;; heap creation time. A <SmallIntHeap> uses memory linear in <n>.
;; Class <SmallIntHeap> supports the iterator protocol
(defmethod SmallIntHeap SmallIntHeap (n)
  (declare (-int-) n)
  (setq hp (new IntHeap n))
  (setq dir :hp:dir)
  (setq keys :hp:keys)
  (setq ints (new SmallIntSet n))
  (setq ckeys (double-array n))
  ())

#? (==> <SmallIntHeap> insert <k> <i>)
;; Insert item <i> with key <k> or update item <i>'s key to <k>.
(defmethod SmallIntHeap insert (key i)
  (declare (-double-) key)
  (declare (-int-) i)
  (if (==> ints member i)
      (when (<> (ckeys i) key)
        (ckeys i key)
        (==> hp insert key i) )
    (==> ints insert i)
    (==> hp insert key i)
    (ckeys i key)
    ()))

#? (==> <SmallIntHeap> number-of-items)
(defmethod SmallIntHeap number-of-items ()
  (==> ints number-of-items) )

;; remove obsolete entries from the heap
(defmethod SmallIntHeap -update-heap ()
  (let ((n :hp:nkeys))
    (declare (-int-) n)
    (while (and (> n 0)
                (or (not (==> ints member (dir 0)))
                    (<> (keys 0) (ckeys (dir 0))) ))
      ;; top entry is obsolete, update
      (decr n)
      (dir 0 (dir n))
      (keys 0 (keys n))
      (decr :hp:nkeys)
      (==> hp -restore-heap-down 0) ))
  ())

#? (==> <SmallIntHeap> key)
;; Return current minimum key.
(defmethod SmallIntHeap key ()
  (==> this -update-heap)
  (==> hp key) )

#? (==> <SmallIntHeap> peeknext)
;; Return the minimum-key item without removing it from the heap.
(defmethod SmallIntHeap peeknext ()
  (==> this -update-heap)
  (==> hp peeknext) )

#? (==> <SmallIntHeap> next)
;; Remove the minimum-key item from the heap and return it.
(defmethod SmallIntHeap next ()
  (==> this -update-heap)
  (let ((i (==> hp next)))
    (==> ints remove i)
    i))

#? (==> <SmallIntHeap> remove <i>)
;; Remove item <i> from heap, return <t> on success and <()>
;; when <i> was not in the heap.
(defmethod SmallIntHeap remove (i)
  (declare (-int-) i)
  (==> ints remove i) )

#? (==> <SmallIntHeap> drop-lt <min-key>)
;; Remove all items with key strictly less than <min-key> and
;; return key of new minimum item in heap or <NaN> when heap is
;; empty.
(defmethod SmallIntHeap drop-lt (mk)
  (declare (-double-) mk)
  (==> this -update-heap)
  (while (and (not (emptyp ints)) (< (keys 0) mk))
    (==> this next) )
  (==> this -update-heap)
  (if (= :hp:nkeys 0)
      NAN
    (keys 0) ))

#? (==> <SmallIntHeap> clear)
;; Clear heap. After calling this method the heap object is empty.
(defmethod SmallIntHeap clear ()
  (==> hp clear)
  (==> ints clear)
  ())

(defmethod SmallIntHeap -emptyp ()
  (==> ints -emptyp) )

(defmethod SmallIntHeap -iterate ()
  this)


(in-namespace (class IntHeap)

;; XXX this hack can go when the compiler is able to compile
;; listeval of storages

(defmacro keys args
  (selectq (length args)
    (2 `(to-double (cinline "(((double *)(%s)->data)[%s] = (%s))" #:keys ,(car args) ,(cadr args))))
    (1 `(to-double (cinline "((double *)(%s)->data)[%s]" #:keys ,(car args))))
    (t  (error "wrong number of arguments" args))
    ))


(defmacro dir args
  (selectq (length args)
    (2 `(to-int (cinline "(((int *)(%s)->data)[%s] = (%s))" #:dir ,(car args) ,(cadr args))))
    (1 `(to-int (cinline "((int *)(%s)->data)[%s]" #:dir ,(car args))))
    (t  (error "wrong number of arguments" args))
    ))
)

(in-namespace (class SmallIntHeap)
(import (keys dir) from (class IntHeap))
)

(dhc-make-class () IntHeap SmallIntHeap)


(defun test-heap (&optional (n 10))
  (let ((h (new IntHeap n))
	(l (domapcar ((i (range n)))
	     (cons (rand) i)) ))
    (dolist (p l)
      (==> h insert (car p) (cdr p))
      ;(pretty :h:keys) (pretty :h:dir) 
      )

    (setq l (sort-list l (lambda (a b) (> (car a) (car b)))))
    ;(print (mapcar car l))
    (print (mapcar cdr l))
    (let ((l2 (take n h)))
      (when (<> l2 (mapcar cdr l))
	(error "heap sort gave different result:\n" l2)))))



  
  