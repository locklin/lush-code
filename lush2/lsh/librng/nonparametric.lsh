
(libload "libidx/idx-int")  ;; random-permute!
(libload "libidx/finding")  ;; array-support


;; #? (sample-array-support <a> <n> [<kwds>])
;; Generate <n> independent samples of the support of array <a>.
;; The support of <a> is the set of indices of all non-zero 
;; elements of <a>.
;; By default, <n> is the number of points  (indices) to be generated.
;; If the <'percentage> is true, <n> is percentage value (i.e., a 
;; non-integral number in the range [0 1]).
;; The result is a list of indices (more precisely, an n-by-d array of
;; indices, where d is the rank of <a>).
;;
;; Optional keyword arguments:
;; percentage : if true, <n> is a percentage value (default is ())
;; (defun sample-array-support (a n . kwdargs)
;;  (error "not implemented") )


#? (sample-array-support <a> <n> [<kwds>])
;; Generate <n> different samples of the support of array <a>.
;; The support of <a> is the set of indices of all non-zero 
;; elements of <a>.
;; By default, <n> is the number of points  (indices) to be generated.
;; If the <'percentage> is true, <n> is percentage value (i.e., a 
;; non-integral number in the range [0 1]).
;; By default, the result is a list of indices (more precisely, an 
;; n-by-d array of indices, where d is the rank of <a>). Alternatively, 
;; the result can be given as a point map, that is, as a binary ubyte
;; array with the shape of <a>, where all sample points are set to 1.
;;
;; Optional keyword arguments:
;; percentage : if true, <n> is a percentage value (default is ())
;; point-map  : if true, the result is a point map (default is ())
(defun sample-array-support (a n . kwdargs)
  (let* ((opt (parse-kwdargs kwdargs
                             'percentage ()
                             'point-map  () ))
	 (nzs (array-where-nonzero a)))
    (n   (or (and (opt 'percentage) (* n (length nzs))) n)) )
    
    (when (or (< n 0) (> n (length nzs)))
      (error "number of samples exceeds number of points in support" n) )
    (random-permute! nzs)
    (idx-trim! nzs 0 0 n)
    (if (not (opt 'point-map))
	nzs
      (let ((map (make-array 'ubyte (shape a) 0))
	    (one [u@ 1]) )
	(array-put map nzs one) 
	map))))
   
   

  
