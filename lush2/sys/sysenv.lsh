;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; PSU Lush
;;;   Copyright (C) 2005 Ralf Juengling
;;; Derived from LUSH Lisp Universal Shell
;;;   Copyright (C) 2002 Leon Bottou, Yann Le Cun, AT&T Corp, NECI.
;;; Includes parts of TL3:
;;;   Copyright (C) 1987-1999 Leon Bottou and Neuristique.
;;; Includes selected parts of SN3.2:
;;;   Copyright (C) 1991-2001 AT&T Corp.
;;;
;;; This program is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 2 of the License, or
;;; (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program; if not, write to the Free Software
;;; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;  $Id: sysenv.lsh,v 1.126 2008/01/25 22:59:47 profshadoko Exp $
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;; --------- Miscellaneous macro-chars ---------

(dmc |'| (list (quote quote) (read)))

(dmc |~| (list 'null (read)))

(dmc |:| 
     (when (= (skip-char) ":")
       (error 'load "Names beginning by :: are reserved" ()) )
     (let ((ans (list 'scope (read))))
       (while (= (skip-char "") ":")
	 (read-string 1)
	 (setq ans (nconc1 ans (read))) )
       ans ) )

(dmc |^!| (list 'sys (read_string)))

(dmc |#!|
     (if (= (read-string "~ !\t\n\e") "/usr/bin/lush2")
         ;; compatibility for #!/usr/bin/lush.
         (read-string)
       ;; multiline comment.
       (let ((again t))
         (while again
           (let ((c1 (read-string 1))
                 (c2 (skip-char "\e")) )
             (when (or (= c1 "\e") (= c2 "\e"))
               (error 'load "Unterminated multiline comment") )
             (when (and (= c1 "!") (= c2 "#"))
               (setq again ()) ) ) )
         (read-string 1) ) )
     () ) 

(lock-symbol |'| |~| |:| |#!| |^!|)


;;; --------- Defining variables ---------

;;(dm dmd(f n a . p)
;;   `(dm ,n |DMD| (displace |DMD| (let ((,a (cdr |DMD|))) ,@p))) )

(dm dmd (f n a . p)
    (list 'dm n '|DMD| 
          (list 'displace '|DMD| 
                (list 'let (list (list a '(cdr |DMD|))) . p) )) )

(dm defvar def
  (when define-hook (setq def (apply define-hook def)))
   (let (((_ name &optional value) def))
    (when (null (symbol-globally-bound-p name))
      (list 'progn (list 'setq (list 'scope name) value) (list 'quote name)) ) ))

(dm defparameter def
  (when define-hook (setq def (apply define-hook def)))
  (let (((_ name value) def))
    (list 'progn (list 'setq (list 'scope name) value) (list 'quote name)) ))

(dm defconstant def
  (let (((_ name value) def))
    (if (and (symbol-globally-bound-p name) (= value (eval name)))
        ;; looks like the same defconstant statement as before
        (list 'progn 
              (list 'lock-symbol name)
              (list 'quote name) )
      (when define-hook (setq def (apply define-hook def)))
      (list 'progn (list 'setq (list 'scope name) value) 
            (list 'lock-symbol name)
            (list 'quote name)) )))

(dm defalias def
  (when define-hook (setq def (apply define-hook def)))
  (let (((_ name value) def))
    (if (not (symbol-globally-bound-p value))
	(error 'defalias "symbol not globally bound" value)
      (list 'progn (list 'setq (list 'scope name) (list 'scope value))
            (list 'putp (list 'quote name) (list 'quote 'alias) (list 'quote value))
            (list 'quote name)) )))

(dm defun def 
  (when define-hook (setq def (apply define-hook def)))
  (let (((_ name args . body) def))
    (let ((f (cons 'lambda (cons args body))))
      (list 'progn (list 'setq (list 'scope name) f) (list 'quote name)) ) ))

(dm defmacro def
  (when define-hook (setq def (apply define-hook def)))
  (let (((_ name args . body) def))
    (let ((f (cons 'mlambda (cons (cons '|__F__| args) body))))
      (list 'progn (list 'setq (list 'scope name) f) (list 'quote name)) ) ))

(defvar not null)
(defvar nil ())

(dm setqs (_ syms vals)
  (let ((vals (eval vals))
	(exp (cons 'setq nil)) )
    (prog1 exp
      (domapc ((sym syms) (val vals)) 
	(nconc exp (list sym (list 'quote val))) ))))

(lock-symbol dmd defvar defalias defparameter defun defmacro not nil setqs)


;;; --------- Basic Control structures ----------

(dmd dolist ((s l) . body)
  (list 'progn 
	(list 'mapc (list 'flambda (list s) . body) l)
	() ))

(dmd domapc (args . body)
  (cons 'mapc 
        (cons 
         (cons 'flambda (cons (mapcar car args) body))
         (mapcar cadr args))) ))

(dmd domapcar (args . body)
  (cons 'mapcar 
        (cons 
         (cons 'flambda (cons (mapcar car args) body))
         (mapcar cadr args))) ))

(dmd domapcan (args . body)
  (cons 'mapcan 
        (cons 
         (cons 'flambda (cons (mapcar car args) body))
         (mapcar cadr args))) ))

(lock-symbol dolist domapc domapcar domapcan)


;;; --------- Toplevel, Break, and Debug  ---------

(de toplevel()
  (let ((break-hook :nice-break-hook)
        (debug-hook :nice-debug-hook) )
    (if (isatty "$stdin")
        (load "$stdin" "$stdout" "? |  |> ") 
      (load "$stdin") ) ) )

(defvar debug-action ())
(defvar break-action ())

(dm on-error (_ p . l)
  (cons 'let
	(cons (list (list 'debug-action
                          (list 'cons (list 'quote p) 'debug-action) ))
              l)))

(dm on-error-macro (_ m . r)
  (list 'eval
	(list 'cons ''on-error (list 'cons m (list 'quote r))) ))

(dm on-break(_ p . l)
  (cons 'let
	(cons (list (list 'break-action
                          (list 'cons (list 'quote p) 'break-action) ))
              l)))

(dm on-break-macro (_ m . r)
  (list 'eval
	(list 'cons ''on-break (list 'cons m (list 'quote r))) ))

(dm on-interrupt (_ p . l)
  (cons 'let
	(cons (list (list 'debug-action
                          (list 'cons (list 'quote p) 'debug-action) )
                    (list 'break-action
                          (list 'cons (list 'quote p) 'break-action) ))
              l)))

(dm on-interrupt-macro (_ m . r)
  (list 'eval
	(list 'cons ''on-interrupt (list 'cons m (list 'quote r))) ))


(de simple-break-hook()
    (dolist (action break-action) (eval action))
    (writing "$stderr" (printf "\n\x07*** %s\n" (errname))) 
    t )

(de simple-debug-hook()
    (dolist (action debug-action) (eval action))
    (writing "$stderr" (printf "\n\x07*** %s\n" (errname)))
    t )

(de nice-break-hook()
    (dolist (action break-action) (eval action))
    (writing "$stderr" (printf "\n\x07*** %s" (errname)))
    (if (and (isatty "$stdin") 
             (not (lush-is-quiet))
             (ask "Break toplevel"))
	(progn
	  (writing "$stderr" (btrace 7))
	  (load "$stdin" "$stdout" "[Break]\n? |  |> ")
	  (when (not (ask "Resume execution"))
	    (writing "$stdout" (printf "[Ready]\n"))
	    t ) )
      t ) )

(de nice-debug-hook()
    (dolist (action debug-action) (eval action))
    (writing "$stderr" (printf "\n\x07*** %s" (errname)))
    (if (and (isatty "$stdin")
             (not (lush-is-quiet))
             (ask "Debug toplevel"))
	(progn
	  (writing "$stderr" (btrace 7))
	  (load "$stdin" "$stdout" "[Debug]\n? |  |> ") 
	  (writing "$stdout" (printf "[Ready]\n")) )
      t ) )

(de pause l
  (writing "$stderr"
    (printf "\n\x07*** ")
    (apply printf (or l '("Paused")))
    (printf "\n") )
  (load "$stdin" "$stdout" "[Pause] ? ") )

(setq :break-hook simple-break-hook)
(setq :debug-hook simple-debug-hook)

(lock-symbol toplevel 
	     break-hook debug-hook pause
	     nice-break-hook nice-debug-hook 
	     break-action debug-action
	     on-error on-break
	     on-error-macro on-break-macro )






;;; --------- Trace-Hook  ---------

(de trace-hook(level line expr info)
    (writing "$stderr"
      (for (i 1 (abs level)) (printf "-"))
      (printf "%s %s\n" (if (>= level 0) ">" "<") line)
      t ) ) 

(lock-symbol trace-hook)




;;; --------- Tokenise  ---------

(de tokenize(fin &optional fout)
    (when (not fout)
      (setq fout (filepath fin ".lsh|.tl|.sn|"))
      (when (or (not fout) (not (regex-match ".*\\.(lsh|tl|sn)" fout)))
	(error 'tokenize "Cannot find Lush library file named" fin) )
      (setq fin fout)
      (setq fout (concat fout "c")) )
    (let ((tokens (list 'progn)))
      (reading (open-read fin ".lsh|.tl|")
	       (while (<> (skip-char) "\e")
		 (if (= (skip-char) ";")
		     (read-string)
		   (nconc1 tokens (read)) ) ) )
      (writing (open-write fout)
	       (bwrite tokens) ) )  
    fout)




;;; --------- Backquote macro ---------

(de backquote-macro()
    (let ((|,| (lambda() 
		 (error "Nested comma in a backquoted expression"))))
      (if (<> (skip-char) "@")
	  (cons '|,| (read))
	(read-string 1)
	(cons '|,@| (read)) ) ) )

(de backquote-subst(l) 
    (let ((na ())
	  (nl ())
	  (nq ()) )
      
      (while l
	(when (consp l)
	      (when (= (car l) '|,@|)
		    (error 'read "Misplaced ,@ inside a backquote") )
	      (when (= (car l) '|,|)
		    (setq l (list (cons '|,@| (cdr l)))) ) )
	(cond
	 ((atomp l)
	  (setq nq (nconc nq l)) 
	  (setq l ()) )
	 ((null (consp (car l)))
	   (setq nq (nconc1 nq (car l))))
	 ((= (caar l) '|,|)
	  (setq nl (append nl 
			   (domapcar ((i nq)) 
				     (list 'quote i))
			   (list (cdar l)) ))
	  (setq nq ()) )
	 ((= (caar l) '|,@|)
	  (setq na (append na
			   (when nl (list (cons 'list nl)))
			   (when nq (list (list 'quote nq)))
			   (list (cdar l)) ))
	  (setq nl ())
	  (setq nq ()) )
	 (t
	  (let ((m (backquote-subst (car l))))
	    (if (and (consp m) (= (car m) 'quote))
		(setq nq (nconc1 nq (cadr m)))
	      (setq nl (nconc nl 
			      (domapcar ((i nq)) 
					(list 'quote i))
			      (list m) ))
	      (setq nq ()) ) ) ) )
	
	(setq l (cdr l)) )

      (if (null na)
	  (backquote-list nl nq)
	(append 
	 (list 'append)
	 na
	 (let ((m (backquote-list nl nq)))
	   (when m (list m)) ) ) ) ) )

(de backquote-list(nl nq)
    (cond
     ((null (or nl nq) )
      ())
     ((null nl)
      (list 'quote nq))
     ((null nq)
      (cons 'list nl))
     ((= (length nl) 1)
      (list 'cons (car nl) (list 'quote nq)) )
     ((= (length nl) 2)
      (list 'cons (car nl) (list 'cons (cadr nl) (list 'quote nq))) )
     (t
      (list 'nconc (cons 'list nl) (list 'quote nq)) ) ) )
     

(dmc |,| 
     (error 'read "Comma outside backquote") )

(dmc |`|
     (backquote-subst
      (let* ((|,| backquote-macro)
             (|'| (lambda() (list (quote quote) (read)))) )
	(read) ) ) )

(lock-symbol |`| |,| backquote-subst backquote-list backquote-macro)

;;; --------- Usual list manipulation functions ---------

(de caddr(l) (car (cddr l)))
(de cdddr(l) (cdr (cddr l)))
(de cdadr(l) (cdr (cadr l)))
(de caadr(l) (car (cadr l)))
(de cadar(l) (car (cdar l)))
(de cddar(l) (cdr (cdar l)))
(de cdaar(l) (cdr (caar l)))
(de caaar(l) (car (caar l)))

(de nconc (f . l)
  (cond
    (f
       (prog1 f
	 (dolist (i l)
	   (setq f (lastcdr f))
	   (rplacd f i) ) ) )
    (l
       (nconc . l) ) ) )

(de nconc1(l s)
  (if l
      (rplacd (lastcdr l) (list s))
    (setq l (list s)) )
  l )

(de alist l
  (cond ((consp l) 
         (cons (cons (car l) (cadr l)) (apply alist (cddr l))))
        (t 
         ()) ) )

(de flatten* (arg)
  (if (consp arg)
      (let (((a . b) arg))
	(nconc (flatten* a) (flatten* b)) )
    (list arg) ))

(defmacro copy-list (lst)
  `(append ,lst ()) )

(de copy-alist (al)
  (let ((copy-cons (lambda ((x . y)) (cons x y))))
    (mapcar copy-cons al) ))

(de alist-add (key value alist)
  (let ((pair (assoc key alist)))
    (if pair
        (rplacd pair value)
      (setq alist (cons (cons key value) alist)) )
    alist ) )

(de alist-get (key alist)
  (let ((pair (assoc key alist)))
    (when pair
      (cdr pair) ) ) )

(de alist-rm (key alist)
  (if (null alist)
      ()
    (if (= key (caar alist))
	(cdr alist)
      (cons (car alist) (alist-rm key (cdr alist))) )))

(de alist-update (al al2)
  (dolist ((key . val) al2)
    (setq al (alist-add key val al)) )
  al)

(de circular-list (&rest items)
  (let ((l items))
    (rplacd (lastcdr l) l) 
    l))

(dm proper-list-p (_ l)
  `(let ((l ,l)) (and (listp l) (null (cdr (lastcdr l)))))
  )

(defvar |*PROPERTIES| (htable))

(de getp(obj key)
  (let ((data (|*PROPERTIES| key)))
    (when data (data obj)) ) )

(de putp (obj key val)
  (when (symbolp obj)
    ;; prevent symbols from being reclaimed
    (when (null (symbol-globally-bound-p obj))
      (apply setq (list 'scope obj) () ()) ))
  (let ((data (|*PROPERTIES| key)))
    (when (not data)
      (if (symbolp key)
          (|*PROPERTIES| key (setq data (htable 17 t)))
        (error 'putp "not a symbol" key) ) )
    (data obj val)
    key ) )


;;; --------- More control structures ---------

(defmacro for* ((i start stop . rest) . body)
  (if (null rest)
      `(for (,i ,start (- ,stop 1)) ,@body)
    (let ((step (gensym)))
      `(let ((,step ,@rest))
         (for (,i ,start (- ,stop (sgn ,step)) ,step) ,@body) )
      )))

(defmacro assert (p &optional error-form)
  (if error-form
      `(when (not ,p) (error ,error-form))
    `(when (not ,p) (error ,(sprintf "assertion failed: %s" (pname p))))
    ))

(defmacro errorf (msg . args)
  `(error (sprintf ,msg ,@args))
  )

(defmacro each stuff `(domapc ,@stuff))
(defmacro all stuff `(domapcar ,@stuff))
(defmacro identity (x) x)

(defun tree-mapcar (fn . lists)
  (let ((caal (caar lists)))
    (if (null caal)
	nil
      (cons (if (consp caal)
		(apply tree-mapcar fn (mapcar car lists))
	      (apply fn (mapcar car lists)))
	    (apply tree-mapcar fn (mapcar cdr lists)) ))))

(de reduce> (func init . seqs)
  (if (null (car seqs))
      init
    (apply reduce> func (apply func init (mapcar car seqs)) (mapcar cdr seqs)) ) )

(de reduce< (func init . seqs)
  (if (null (car seqs))
      init
    (apply func (apply reduce< func init (mapcar cdr seqs)) (mapcar car seqs)) ) )

;; preliminary definition
(dm sum (_ args)
  `(apply + ,args) )

(dm prod (_ args)
  `(apply * ,args) )


(dmd mapfor ((var lo hi . step) . body)
     `(let ((|MAP| ()))
        (for (,var ,lo ,hi ,@step) (setq |MAP| (cons (progn ,@body) |MAP|)))
        (reverse |MAP|) ) )

(dmd mapwhile (expr . body)
     `(let ((|MAP| ()))
        (while ,expr (setq |MAP| (cons (progn ,@body) |MAP|)))
        (reverse |MAP|) ) )

(dm let-filter(fn ((fexp dexp)) . body)
  (let ((f (mlambda(fn f d b)
             (let ((okay t)
                   (bindings ())
                   (match (lambda(f d)
                            (while (and okay (consp f) (consp d))
                              (match (car f) (car d))
                              (setq f (cdr f))
                              (setq d (cdr d)) )
                            (cond
                             ((and okay (symbolp f))
                              (setq bindings (cons (list f (list 'quote d)) 
                                                   bindings)) )
                             ((<> f d)
                              (setq okay ()) ) ) )) )
               (match f d)
               (when okay
                 `(let ,(reverse bindings) ,@b) ) ) )))
    `(eval (list ,f ',fexp ,dexp ',body)) ) )

(de sort-list (l comp)
    (if (cdr l)
	(let* ((piv ())
	       (pl ())
	       (ll ())
	       (rl ()) )
	  ;; Choose pivot
	  (let* ((n (length l))
		 (p1 (car l))
		 (lc (nthcdr (div n 2) l))
		 (p3 (lasta lc)) )
	    (setq piv (car lc))
	    (if (comp p1 piv)
		(setq piv p1 p1 piv) )
	    (if (comp piv p3)
		(setq piv p3 p3 piv) )
	    (if (comp p1 piv)
		(setq piv p1 p1 piv) ) )
	  ;; Go pivoting for quicksort
	  (each ((i l))
		(cond 
		 ((= i piv)
		  (setq pl (cons i pl)) )
		 ((comp i piv)
		  (setq rl (cons i rl)) )
		 (t 
		  (setq ll (cons i ll)) ) ) )
	  (nconc (sort-list ll comp) (nconc pl (sort-list rl comp))) )
      l ) )

(de bsearch.list (l v n)
  (if (> n 1)
    (let* ((m   (div n 2))
           (piv (nth m l)) )
      (if (>= v piv)
          (+ m (bsearch.list (nthcdr m l) v (- n m)))
        (bsearch.list (nfirst m l) v m) ) ) 
    0) )

(de bsearch (l v)
  (cond
   ((consp l)                        ;; l is a list
    (bsearch.list l v (length l)))
   ((and (vectorp l) (numericp l))   ;; l is a vector
    (selectq (idx-element-type l)
      ('float  (idx-f1bsearch l v))
      ('double (idx-d1bsearch l v))
      ('int    (idx-i1bsearch l v))
      (t       (error 'bsearch 
                      "bsearch not implemented for element type" 
                      (idx-element-type l) )) ) )
   (t                                ;; l is neither
    (error 'bsearch "first argument must be sorted list or vector" l) ) ) )
 
;;(autoload "libidx/idx-sort" idx-f1bsearch idx-d1bsearch idx-i1bsearch)
;; deferred to the end
 
(de filter (f l)
  (let ((r ()))
    (each ((x l)) (when (f x) (setq r (cons x r))))
    (reverse r)))

(de hset(l &optional flag)
  (let ((r (htable)))
    (each ((x l))
      (r x (or (not flag) (1+ (or (r x) 0)))) )
    r ) )

(de hset-and(ht1 ht2)
  (let ((r (htable)))
    (when (< (htable-size ht2) (htable-size ht1))
      (setq ht1 ht2 ht2 ht1) )
    (each ((key (htable-keys ht1)))
      (when (ht2 key)
	(r key t) ) )
    r ) )

(de hset-or(ht1 ht2)
  (let ((r (htable)))
    (each ((key (htable-keys ht1)))
      (r key t) )
    (each ((key (htable-keys ht2)))
      (r key t) ) 
    r ) )

(de list-insert (l pos x)
  (if (= 0 pos)
      (cons x l)
    (let* ((w (nthcdr (1- pos) l)))
      (if (not w)
          (error "list too short")
        (rplacd w (cons x (cdr w))) ) ) l ) )

(de list-delete (l pos)
  (if (= 0 pos)
      (cdr l)
    (let* ((w (nthcdr (1- pos) l)))
      (if (not w)
          (error "list too short")
        (rplacd w (cddr w)) ) ) l ) )

(de list-merge (l l2)
  (cond 
   ((null l) l2)
   ((null l2) l)
   (t
    (dolist (item l2) 
      (when (not (member item l)) 
        (setq l (nconc1 l item)) ))
    l)))

(de list-split! (l n)
  (cond 
   ((< n 0) (error "invalid value for number of elements"))
   ((= n 0) (cons () l))
   (t 
    (let* ((chain (nthcdr (1- n) l))
           (left l) (right (cdr chain)))
      (when chain (rplacd chain ()))
      (cons left right) ))))

(lock_symbol for* assert identity
             caddr cdddr cdadr caadr cadar cddar cdaar caaar
             nconc nconc1
             alist alist-get alist-add alist-update
             |*PROPERTIES| putp getp
             mapfor mapwhile let-filter sort-list 
             hset hset-and hset-or
	     list-insert list-delete list-merge)


;;;; --------- Storage utilities ----------

(defvar storage-classes 
  (list |ATSTORAGE| |FSTORAGE| |DSTORAGE| |I32STORAGE|
        |I16STORAGE| |I8STORAGE| |U8STORAGE| |GPTRSTORAGE| ))

;; we make these symbols reserved symbols
(let* ((storage-class-symbols 
       (list 'atom 'float 'double 'int 'short 'byte 'ubyte 'gptr) )
       (htlen (* 2 (length storage-classes))) )
      (defvar storage-class (htable htlen))          ;; map class symbol to class
      (defvar storage-class-symbol (htable htlen))   ;; map class to class symbol
      (each ((scs storage-class-symbols) (sc storage-classes) )
        (storage-class-symbol sc scs)
        (storage-class scs sc)
        (storage-class (named (left (pname scs) 1)) sc)
      ;;(putp sc 'symbol scs)
      ;;(storage-class 'flt (storage-class 'float))
      ;;(storage-class 'real (storage-class 'double)) 
         ) )

;; redefine new-storage to allow for element type symbols
(unlock-symbol new-storage)
(defvar new-storage-dx new-storage)
(lock-symbol new-storage-dx)

(de new-storage (arg)
  (if (classp arg)
      (new-storage-dx arg)
    (new-storage-dx (storage-class arg)) ))

(dmd make-storage (sc n init)
  `(let ((m (new-storage ,sc))) (storage-malloc m ,n ,init) m) )

(lock-symbol storage-classes storage-class new-storage make-storage)


;;;; --------- Arrays utilities ---------
(de matrix (&optional args) 
   (error 'matrix "matrix is an obsolete function; replace by 'double-array'" nil))

(de array (&optional args) 
  (error 'array "array is an obsolete function, replace by 'atom-array'" nil))

;; create XXX-array constructors
(each ((sc storage-classes))
  (let* ((scs         (storage-class-symbol sc))
         (func-symbol (named (concat (pname scs) "-array")))
	 (func*-symbol (named (concat (pname scs) "-array*")))
         (init        (if (member scs '(atom gptr)) nil 0.0)) )
    (eval 
     `(progn 
	(de ,func-symbol (&rest shape)
	  (make-array ,sc shape ,init))
	(de ,func*-symbol (&rest shape)
	  (make-array ,sc shape ()))
        (lock-symbol ,func-symbol ,func*-symbol) )
     )))

;;
;; argument checking functions
;;

(dm chk-idx (_ arg)
  `(if (not (indexp ,arg))
      (error "not an index" ,arg)
     ,arg) )

(dm chk-idx-numeric (_ arg)
  `(if (not (numericp ,arg))
       (error "not a numeric index" ,arg)
     ,arg) )

(dm chk-idx-contiguous (_ arg)
  `(if (not (contiguousp ,arg))
       (error "not a contiguous index" ,arg)
    ,arg) )

(dm chk-idx-nonempty (_ arg)
  `(if (= (idx-nelems ,arg) 0)
       (error "index is empty" ,arg)
     ,arg) )

(lock-symbol chk-idx chk-idx-numeric chk-idx-contiguous chk-idx-nonempty)

(defmacro validate-dimension (arg d)
  `(let* ((nd (idx-rank ,arg))
          (d* (if (< ,d 0) (+ ,d nd) ,d)) )
     (when (or (< d* 0) (>= d* nd))
       (error "invalid dimension argument") )
     d*) )

(defun validate-shape (arg template)
  (let ((shp  (idx-shape arg))
	(test (lambda (a b) (or (null b) (= b a) (error "invalid extent" a)))) )
    (when (<> (length template) (length shp))
      (error "index does not have expected shape" arg) )
    (mapc test shp template)
    shp))

(defun same-shape-p (a1 a2)
  (= (idx-shape a1) (idx-shape a2)) )

(dm vector (_ . args)
  (let* ((l (length args)) (v (gensym)) (vs (.cl v)))
    (prog1 
        `(let* ((,v (double-array ,l)))
           ,@(mapcar list vs (range* l) args)
           ,v)
      (delete vs) )))

(dm vectorp(_ idx)
  `(let ((idx ,idx)) (and (indexp idx) (= (idx-rank idx) 1)))
  )

(dm idx-emptyp (_ m)
  `(= (idx-nelems ,m) 0) )

(dm idx-readonlyp (_ idx)
  `(storage-readonlyp (idx-storage ,idx)))

(dm idx-element-type (_ idx)
  `(storage-class-symbol (classof (idx-storage ,idx))) )

(de make-array (arg shp init)
  (new-index (make-storage arg (apply * shp) init) shp) )

(dm clone-array (_ proto &optional init)
  `(make-array (idx-element-type ,proto) (shape ,proto) ,init) )

;; aliases for often used functions
(defalias contiguousp idx-contiguousp)
(defalias numericp    idx-numericp)
(defalias select      idx-select)

(lock_symbol numericp contiguousp select)
;;
;; printing and reading array literals
;;

(de print-array (m)
  (let* ((elt     (idx-element-type m))
	 (pf-at   (lambda (i) (printf " ") (prin (m i)) ))
	 (pf-real (lambda (i) (printf "%10.4f\t" (m i))))
	 (pf-rest (lambda (i) (printf "%10d\t" (m i))))
	 (pf      (cond 
		   ((member elt '(atom gptr)) pf-at)
		   ((member elt '(float double)) pf-real)
		   (t pf-rest) )))
    (cond
     ((= 0 (idx-rank m))   ;; scalar 
      (prin (m))
      (print) )

     ((= 1 (idx-rank m))   ;; one dimensional
      (for (i 0 (1- (idx-shape m 0))) (pf i))
      (print) )

     (t                    ;; all other
      (for (i 0 (1- (idx-shape m 0)))
	   (print-array (select m 0 i)) )
      (print) ))))


(de print-array-literal (this)
  (let* ((elt     (idx-element-type this))
	 (begin   (concat "[" (left (pname elt) 1)))
	 (end     "]")
	 (pf-at   (lambda (i) (printf " ") (prin (this i)) ))
	 (pf-real (lambda (i) (printf " %8.4f" (this i))))
	 (pf-rest (lambda (i) (printf " %5d" (this i))))
	 (pf      (cond 
		   ((member elt '(atom gptr)) pf-at)
		   ((member elt '(float double)) pf-real)
		   (t pf-rest) )))
    (cond
     ((not (idx-rank this))  ;; unsized storage
      (printf "%s" (pname this)) )
 
     ((0= (idx-rank this))   ;; scalar 
      (printf "%s@ " begin)
      (prin (this))
      (printf end) )

     ((= 1 (idx-rank this))  ;; one dimensional
      (printf begin)
      (for (i 0 (- (idx-shape this 0) 1)) (pf i))
      (printf end) )

     (t                      ;; all other
      (printf begin)
      (let ((tabnow (tab))
            (len    (- (idx-shape this 0) 1)) )
	(for (i 0 len)
	     (print-array-literal (select this 0 i) )
	     (when (< i len) (print) (tab tabnow)) ))
      (printf end) ))))


;; (demethod |INDEX| print ()
;;   (if (and (indexp this) (< (idx-nelems this) 200))
;;       (print-array-literal this)
;;     (printf "%s" (pname this)) ) )


(de read-array-literal (idxfun)
  (let ((l ())
        (m ())
        (|]|
         (cond
          ((= (skip-char) "@")          ; zero dimensions
           (read-string 1)
           (lambda()
             (when (cdr l) (error 'read "Bad index0 syntax" ()))
             (setq m ((idxfun) (car l))) ) )

          ((<> (skip-char) "[")         ; one dimension
           (lambda()
             (setq m (idxfun (length l)))
             (m () l) ))

          (t                            ; more dimensions
           (lambda()
             (let ((n (length l)))
               (setq m (apply idxfun (cons n (shape (car l)))))
               (for (i 0 (1- n))
		    (array-copy (car l) (select m 0 i))
                    (setq l (cdr l)) ))))))) 

    (while (not m)
      (setq l (nconc1 l (read))) )
    m ))

(dmc |[| 
     (let* ((sc  (storage-class (named (skip-char))))
            (sc2 (or sc (storage-class 'double))) )
       (when sc (read-string 1))
       (read-array-literal (lambda (&rest shp) (make-array sc2 shp nil)))) ))

(dmc |]|
     (error 'read "extra ']' found"))

(lock-symbol print-array print-array-literal read-array-literal |[| |]|)


	     
;;; --------- Path functions ---------

(defparameter  libload.data       (htable))
(defparameter  libload.loading    (htable))
(defparameter *libload-last-file* ())
(defparameter  libload.num-tabs    0)

(lock-symbol libload.data libload.loading)

(de libload.search (s)
  (let ((fname ()))
    (when (and (stringp file-being-loaded) (<> file-being-loaded "$stdin"))
      (when (not s) (setq s file-being-loaded))
      (setq fname (filepath (concat-fname (dirname file-being-loaded) s))) )
    (when (not fname)
      (setq fname (filepath s)) )
    (when (not fname)
      (error 'libload.search "File not found" s) )
    fname))

(de libload.add (rname)
  (when (and (stringp file-being-loaded) (<> file-being-loaded "$stdin"))
    (let* ((f (or (relative-fname lushdir file-being-loaded) file-being-loaded))
           (frec (libload.data f)))
      (when (not frec)
        (setq frec (cons t ()))
        (libload.data f frec) )
      (when (not (member rname (cdr frec)))
        (rplacd frec (cons rname (cdr frec)))
        rname))))

(de libload.mtime (rname seen)
  (seen rname t)
  (let* ((fname (concat-fname lushdir rname))
         (frec  (libload.data rname))
         (mtime (or (libload.loading rname)
                    (alist-get 'mtime (fileinfo fname))) ))
    (when (and (null (libload.loading rname)) frec)
      (domapc ((dep (cdr frec)))
        (when (not (seen dep))
          (let ((deptime (libload.mtime dep seen)))
            (when (and deptime (> deptime mtime))
              (setq mtime deptime) )))))
    mtime))

(de libload (s &optional opt)
  (let* ((fname (libload.search s))
         (rname (or (relative-fname lushdir fname) fname)) )

    ;; clear registry of files being loaded (just in case)
    (when (= file-being-loaded "$stdin")
      (htable-clear libload.loading) )

    ;; record dependency
    (libload.add rname)

    (when (not (libload.loading rname))

      ;; check if loading is necessary
      (let ((frec (libload.data rname))
            (mtime (libload.mtime rname (htable)))
            (libload.num-tabs (+ libload.num-tabs 1)) )
        (when (or opt
                  (null frec)
                  (and (car frec) (> mtime (car frec))) )

          ;; okay, load it
          (when (not (lush-is-quiet))
            (repeat libload.num-tabs
              (printf "   ") )
            (cond
             ((null opt)    (printf " [%s]\n" (basename fname)))
             ((stringp opt) (printf " [%s] %s\n" (basename fname) opt))
             (t             (printf " [%s] %l\n" (basename fname) opt)) ))
          
          (on-interrupt-macro `(progn
                                 (:libload.data ,rname ())
                                 (:libload.loading ,rname ()) )
              (libload.data rname (list ()))
              (libload.loading rname mtime)
              (prog1 (load fname) 
                (setq *libload-last-file* fname)
                (libload.loading rname ()) 
                (rplaca (libload.data rname) (libload.mtime rname (htable))) 
                )))))))


(de libload-dependencies (&optional fname)
  (setq fname (if fname (or (filepath fname) fname) file-being-loaded))
  (let* ((rname (or (relative-fname lushdir fname) fname))
         (frec (libload.data rname)) )
    (when frec
      (all ((d (cdr frec)))
        (concat-fname lushdir d) ) ) ) )

(de libload-add-dependency (s)
  (let* ((fname (filepath s))
         (rname (or (relative-fname lushdir fname) fname)) )
    ;; record dependency
    (libload.add rname)
    ;; mark as already loaded
    (let ((frec (libload.data rname))
          (mtime (alist-get 'mtime (fileinfo fname))) )
      (when (not frec)
        (libload.data rname (list (or mtime (now))))
        fname ))))

(de reload ()
  (when *libload-last-file*
    (libload *libload-last-file*) ))

(dm autoload(autoload l . s)
  (let  ((f  (eval `(mlambda f
                      (set (car f) ())
                      (libload ,l "(autoload)")
                      f) )))
    `(progn ,@(all ((i s)) `(setq :,i ,f))) ) )


(defvar last-loaded-file ())

(dmc |^L| 
     (let ((f (read_string)))
       (setq f (regex-subst "^ +" "" f))
       (setq f (regex-subst " +$" "" f))
       (if (= f "") 
           (setq f (or last-loaded-file edit-buffer))
         (setq last-loaded-file f) )
       `(libload ,f t) ))

(de path dirs
  (if (not dirs)
      (scope |*PATH|)
    (let ((newpath (list ".")))
      (each ((dir dirs))
        (when (not (stringp dir))
          (error 'path "Not a string" dir) )
        (when (<> dir ".")
          (setq newpath (cons dir newpath)) ) )
      (setq (scope |*PATH|) (reverse newpath)) ) ) )

(de addpath(dir)
  (setq dir (concat-fname dir))
  (let ((oldpath (path))
        (newpath (list dir)) )
    (while oldpath
      (when (<> dir (car oldpath))
        (setq newpath (nconc1 newpath (car oldpath))) )
      (setq oldpath (cdr oldpath)) )
    (apply path newpath) ) )

(lock-symbol libload.add libload.search libload.mtime libload 
             reload autoload |^L| path addpath )


;;; --------- pprin, pprint ----------

(each ((sym '( progn graphics-batch debug nodebug )))
  (putp sym 'pprint-type 0) )
(each ((sym '( when while do-while for mapfor mapwhile repeat )))
  (putp sym 'pprint-type 1) )
(each ((sym '( lambda flambda mlambda zlambda writing reading )))
  (putp sym 'pprint-type 1) )  
(each ((sym '( de df dm dz dmd defclass dhm-t dhm-c )))
  (putp sym 'pprint-type 2) )
(each ((sym '( defmethod demethod dfmethod dmmethod )))
  (putp sym 'pprint-type 3) )
(each ((sym '( let let* let-filter each all idx-bloop idx-eloop idx-gloop )))
  (putp sym 'pprint-type '(0 let)) )

(putp 'if        'pprint-type '(1 indent))
(putp 'prog1     'pprint-type '(0 indent))
(putp 'cond      'pprint-type '(0 cond))
(putp 'selectq   'pprint-type '(1 cond))


(de pprin--v(l tb)
    (let ((nl ()))
      (while (consp l)
	(setq nl t)
	(print)
	(tab tb)
	(pprin (car l))
	(setq l (cdr l)) )
      (when l
	    (print)
	    (setq nl t)
	    (tab (+ tb 2))
	    (printf ". ")
	    (pprin l) )
      (if nl
	  (printf " )")
	(printf ")") )
      nl ) )
    
(de pprin--h(l tb)
    (let ((ok t)
	  (nl ()) )
      (while (and ok (consp l))
	(if (or (<= (tab) tb)
		(< (+ (tab) (len (pname (car l)))) 78) )
	    (printf " ")
	  (print)
	  (tab tb)
	  (setq nl t) )
	(if (not (pprin (car l)))
	    (setq l (cdr l))
	  (setq ok ())
	  (setq nl t)
	  (pprin--v (cdr l) tb) ) )
      (when ok
	    (when l
		  (if (< (+ (tab) (len (pname l))) 76)
		      (printf " . ")
		    (print)
		    (tab tb)
		    (setq nl t)
		    (printf ". ") )
		  (pprin l) )
	    (if nl
		(printf " )")
	      (printf ")") ) )
      nl ) )

(de pprin--n(l n)
  (let ((c ""))
    (while (and (consp l) (>= n 0))
      (printf "%s" c)
      (setq c " ")
      (pprin (car l))
      (setq l (cdr l))
      (setq n (1- n)) )
    l ) )

(de pprin(l)
  (let ((tb (tab))
        (type (and (consp l) (getp (car l) 'pprint-type))) )
    (when (numberp type)
      (setq type (cons type ())) )
    (cond
     ;; nil
     ((not l) (prin l) ())
     ;; method 'pprint' is defined
     ((and (classof l) (getmethod (classof l) 'pprint))
      (==> l pprint) )
     ;; not a list
     ((not (consp l)) (prin l) ())
     ;; type is a pair
     ((consp type)
      (printf "(")
      (setq l (pprin--n l (car type)))  ; first arguments in line
      (when (consp l)
        (cond                          ; next argument special
         ((= (cadr type) 'indent)
            (print)
            (tab (+ tb 4))
            (pprin (car l)) 
            (setq l (cdr l)) )
         ((= (cadr type) 'cond)
           (while (consp l)
             (print)
             (tab (+ tb 2))
             (if (not (consp (car l)))
                 (pprin l)
               (printf "(")
               (pprin (caar l))
               (pprin--v (cdar l) (+ tb 4)) )
             (setq l (cdr l)) ) )
         ((= (cadr type) 'let)
           (printf " ");
           (if (not (consp (car l)))
               (pprin (car l))
             (printf "(")
             (let ((tb (tab)))
               (pprin (caar l))
               (pprin--v (cdar l) tb) ) )
           (setq l (cdr l)) ) ) )
      (pprin--v l (+ tb 2)) )
     ;; macro quote
     ((and (= (car l) 'quote) (consp (cdr l)) (not (cddr l)))
      (printf "'")
      (pprin (cadr l)) )
     ;; macro scope
     ((and (= (car l) 'scope) (consp (cdr l)) (not (cdr (lastcdr l))))
      (while (setq l (cdr l))
        (printf ":")
        (pprin (car l)) ) )
     ;; start with symbol
     ((symbolp (car l))
      (printf "(")
      (setq l (pprin--n l 0))
      (pprin--h l (+ tb 2)) )
     ;; default
     (t
      (printf "(")
      (setq l (pprin--n l 0))
      (pprin--h l (+ tb 2)) ) ) ) )

(de pprint(l)
    (pprin l)
    (print)
    t )

(lock-symbol pprin--h pprin--v pprin--n pprin pprint)





;;; --------- Pretty printer ---------

(de pretty-print (f &optional name)
  (when (and (consp f) (consp (cdr f)) (consp (cddr f)))
    (when (and name (= (car f) 'lambda))
      (setq f `(de ,name ,@(cdr f))) )
    (when (and name (= (car f) 'flambda))
      (setq f `(df ,name ,@(cdr f))) )
    (when (and name (= (car f) 'mlambda))
      (setq f `(dm ,name ,@(cdr f))) )
    (when (and name (= (car f) 'zlambda))
      (setq f `(dz ,name ,@(cdr f))) )
    (when (and (= (car f) 'dm) (= (caddr f) '|DMD|))
      (let ((body (cdr (cdar (cddr (cadr (cddr f))))))
            (args (caaar (cdadr (cdadr (cddr f))))) )
        (setq f `(dmd ,(cadr f) ,args ,@body)) ) )
    (when (and (= (car f) 'de) (macrochp (cadr f)) (null (caddr f)))
      (let ((body (cdddr f)))
        (setq f `(dmc ,(cadr f) ,@body)) ) ) )
  (pprint f) )

(dm pretty(pretty f)
    (nodebug
     (if (symbolp f) 
	 `(nodebug (==> ,f pretty))
       `(let* ((x ,f) (c (classof x)))
          (if (and c (getmethod c 'pretty))
              (==> x pretty)
            (pretty-print x) ) ) ) ) )

(dmc |^P| `(pretty ,(read)))  

(dm save(save f . l)
  (when l
    `(nodebug (writing (open-write ,f "lsh")
		,@(all ((i l)) (list 'pretty i)) ) ) ) )

(lock-symbol pretty-print pretty save |^P|)


;;; --------- Edition Functions ---------

(defvar edit-call ())
(defvar edit-buffer (tmpname () "lsh"))

(cond
 ((not wintl3p)
  ;; unix
  (setq edit-call (getenv "EDITOR"))
  (when (= edit-call "")
    (setq edit_call "vi") ) 
  (when (= edit-call "dm")
    (setq edit-call ()) ) )
 ((wintl3p)
  ;; windows GUI
  (setq edit-call ()) )
 (t
  ;; windows Console
  (setq edit-call "edit") ) )

(de edit (fn &optional createp)
  ;; libload.search raises an error if file not found
  (when createp
    (sys (concat "touch " fn)) ) ;; this is unix only
  (let ((fn (or (and (filep fn) fn)
                (and (filep (libload.search fn)) (libload.search fn))) ))
    (cond
     (edit-call  (sys (concat edit-call " " fn)) )
     (xdmc       (xdmc (concat "ce " fn)) )
     (winedit    (winedit fn) )) ))

(de fedit(_s_)
  (if _s_ 
      (eval (list 'save edit_buffer _s_)))
    (edit edit_buffer)
    (when edit-call
      (load edit_buffer) ) )

(dmc |^E| `(edit ,(read-string)))

(dmc |^F| `(fedit ',(namedclean (read-string))))

(lock_symbol edit fedit |^E| |^F|)

;;; --------- Strings/Regex ---------

(defun make-string (n c)
  (let ((s "") (p (ceil (log2 n))))
    (while (>= p 0)
      (setq s (concat s s (if (testbit n p) c "")))
      (decr p) )
    s))

(dm str-startswith (_ s prefix)
  `(let ((s ,s) (p ,prefix))
     (= (left s (len p)) p)) )

(de str-join (j ss)
  (if (null ss)
      ""
    (let ((args (list (car ss))))
      (apply concat 
             (prog1 args
               (dolist (s (cdr ss))
                 (setq args (lastcdr args))
                 (rplacd args (list j s)) ))))))

(defmacro str-split (sep s)
  `(regex-split ,sep ,s () () t) )

(de strip (s) 
  (stripl (stripr s)) )

(de stripl(s) 
  (regex-subst "^( )+" "" s) )

(de stripr(s)
  (regex-subst "( )+$" "" s) )

(de regex-rseek (r s &optional n gr)
  (setq n (if (numberp n) (max (int n) 0) -1))
  (let* ((x ()) (i 1) (l (list ())))
    (while (and (<> 0 n) (setq x (regex-seek r s i)) )
      (setq i (apply + x))
      (setq l (cons x l))
      (incr n -1) )
    (setq l (when (<= n 0) (cdr (reverse l))))
    (when (and l gr)
      (let* ((ll l) (x 1))
	(while ll
	  (when (not (regex-match gr (mid s x (- (caar ll) x))))
            (setq l () ll ()) )
	  (setq x (caar ll))
	  (setq ll (cdr ll)) )
	(when (< n 0)
	  (when ~(regex-match gr (mid s (apply + (lasta l))))
		(setq l () ll ()) ) ) ) )
    l ))

(de regex-skip (r s &optional n gr neg)
  (when ~n (setq n 1))
  (if (<= n 0)
      s
    (let* ((l (regex-rseek r s n gr)))
      (when l (mid s (if neg (car (lasta l)) (apply + (lasta l))))))))

(de regex-split (r s &optional n gr neg)
  (let* ((l (regex-rseek r s n gr)))
    (if neg
	(let* ((y 1))
	  (nconc
	   (all (((x i) l)) (prog1 (mid s y (- x y)) (setq y (+ x i))))
	   (if n () (list (mid s y)))))
      (all (((x i) l)) (mid s x i)))))

(de regex-count (r s) 
  (length (regex-rseek r s)) )

(de regex-tail (r s &optional n gr neg)
  (when ~n (setq n 1))
  (let* ((i (regex-count r s)))
    (when (>= i n)
      (regex-skip r s (if neg (- i n) (1+ (- i n))) gr ~neg))))

(de regex-member (rl s)
  (while (and rl s)
    (if (regex-match rl)
	(setq s ())
      (setq rl (cdr rl))))
  (car rl))

(lock-symbol stripl stripr strip)

(lock-symbol regex-rseek regex-skip 
             regex-split regex-count
             regex-tail regex-member)



;;; --------- List of symbols ---------

(de symbols p 
   (if p 
      (setq p (car p)) 
      (setq p "") ) 
   (let ((pos 0)) 
        (each ((i (symblist))) 
           (when (index p i) 
              (printf "%s" (left i 17)) 
              (setq pos (if (< pos 50) 
                              (+ pos 19) 
                              (printf "\n") 
                              0 )) 
              (tab pos) ) ) ) 
   (print) )
	
(dmc |^S| (list 'symbols (read_string)))

(lock_symbol |^S| symbols )


;;; --------- Shortcuts ----------

(defalias .cl circular-list)
(defalias .v  vector)

(defparameter 0s (.cl 0))
(defparameter 1s (.cl 1))
(defparameter nils (.cl ()))

(lock-symbol .cl .v 0s 1s nils)

;;; --------- Numbers ----------

(defalias int to-int)

(defmacro incr (a &optional (b 1))
  (cond
   ((symbolp a) ; simple variable increment
    `(setq ,a (+ ,a ,b)) )
   ((consp a)   ; scoped scalar or array element increment
    (cond
     ((= (car a) 'scope)
      `(setq ,a (+ ,a ,b)) )
     ((and (consp (car a)) (= (caar a) 'scope))
      `(,@a (+ ,a ,b)) )
     ((not (consp (car a)))
      `(,@a (+ ,a ,b)) )
     (t 
      (error "argument is neither a variable nor an array element") )))))

(defmacro decr (a &optional (b 1))
  `(incr ,a (- ,b)) )

(defmacro mod (x y)
  `(let ((x ,x) (y ,y))
     (- x (* (floor (/ x y)) y)) )
  )

(defmacro rem (x y)
  `(let ((x ,x) (y ,y))
     (- x (* (trunc (/ x y)) y)) )
  )

(defconstant +pi+  (acos -1))
(defconstant +2pi+ (+ +pi+ +pi+))
(defconstant +e+   (exp 1))

;;; --------- Modules ---------

(de module.hook(what m)
  (cond
   ;; ON INIT
   ((= what 'init)
    (each ((pair (module-defs m)))
      (cond
       ;; global definition
       ((symbolp (cdr pair))
        (let ((old (eval `:,(cdr pair))))
          ;; - save old definition when precious is set
          (when (and old (getp old 'precious))
            (putp (car pair) 'saved old)
            ;; - functions: save source
            (when (functionp old)
              (putp (car pair) 'source (funcdef old)) )
            ;; - classes: copy methods
            (when (and (classp old) (classp (car pair)))
              (each ((m (methods old)))
                (putmethod (car pair) m (getmethod old m)) ) ) ) )
        ;; - perform definition
        (eval `(setq :,(cdr pair) ',(car pair))) ) 
       ;; method definiton
       ((consp (cdr pair))
        ;; - perform definition
        (when (and (classp (cadr pair)) (symbolp (cddr pair)))
          (putmethod (cadr pair) (cddr pair) (car pair)) ) ) ) ) )
   ;; ON UNLINK
   ((= what 'unlink)
    (each ((pair (module-defs m)))
      (cond
       ;; global definition
       ((symbolp (cdr pair))
        (let ((old (getp (car pair) 'saved)))
          (when (and old (== (car pair) (eval `:,(cdr pair))))
	    (if (not (and (classp old) (classp (car pair))))
		;; non class: undo global definition
		(eval `(setq :,(cdr pair) ',old))
	      ;; class: copy saved methods
	      (putp (car pair) 'saved ())
	      (putp (car pair) 'precious (getp old 'precious))
	      (each ((m (methods old)))
		(putmethod (car pair) m (getmethod old m)) ) ) ) ) ) ) ) ) ) )

(de mod-search(name)
  (let ((found ())
        (n (concat-fname name))
        (l (module-list)))
    (each ((m l))
      (when (= name (module-filename m))
        (setq found m) ) )
    (when (not found)
      (setq name (basename name))
      (each ((m l))
        (when (= name (basename (module-filename m)))
          (setq found (cons m found)) ) )
      (if (and found (not (cdr found)))
          (setq found (car found))
        (setq found ()) ) )
    found ) )

(de mod-list()
  (mapcar module-filename (module-list)) )

(de mod-status()
  (each ((m (module-list)))
    (==> m pretty) ) )

(de mod-inquire(name)
  (let ((m (mod-search name)))
    (when m
      (let ((d (module-defs m))
            (i (module-initname m))
            (x (module-executable-p m)) )
        (cons (cond
               ((not i) "State: not initializable")
               ((not d) "State: initializable")
               (x "State: initialized, executable")
               (t "State: initialized, partially linked") )
              (mapcar cdr (module-defs m)) ) ) ) ) )

(de mod-load(name)
  (let ((hook (lambda args (and module.hook (apply module.hook args)))))
    (module-filename (module-load name hook)) ) )

(de mod-unload(name)
  (let ((m (mod-search name)))
    (when (not m)
      (error 'mod-unload "Unknown module name" name) )
    (module-unload m) ) )

(defvar mod-dlopen mod-load)

(lock-symbol module.hook 
             mod-search mod-list mod-status 
             mod-inquire mod-load mod-unload )



;;; --------- Declaring types -----------

;; Types have no existence in the interpreter.
;; This is all compiler support...

;; verify type syntax
(defvar verify-type-decl-format.table (htable))

(de verify-type-decl-format (source &optional (where declare))
  (let ((result (verify-type-decl-format.table source)))
    (when (not result)
      (when (or (not (consp source))
                (not (symbolp (car source))) )
        (error where "invalid type specifier" source) )
      (let ((chk-type-syntax (getp (car source) 'type-syntax)))
        (when (not (functionp chk-type-syntax))
          (error where "invalid type specifier" source) )
        (setq result (chk-type-syntax where source)) 
        (when (and (<> type -obj-) (<> type -list-))
          (verify-type-decl-format.table source result) ) ) )
    result ) )

;; idx base types
(putp '-int-    'srg-type |I32STORAGE|)
(putp '-short-  'srg-type |I16STORAGE|)
(putp '-byte-   'srg-type |I8STORAGE|)
(putp '-ubyte-  'srg-type |U8STORAGE|)
(putp '-flt-    'srg-type |FSTORAGE|)
(putp '-float-  'srg-type |FSTORAGE|)
(putp '-real-   'srg-type |DSTORAGE|)
(putp '-double- 'srg-type |DSTORAGE|)
(putp '-gptr-   'srg-type |GPTRSTORAGE|)
(putp '-any-    'srg-type |STORAGE|)

;; no type check
(putp '-any- 'type-syntax
      (lambda(where source)
        (or (let-filter (((fn) source)) =)
            (error where "Illegal syntax" source) ) ) )
;; boolean type check
(putp '-bool- 'type-syntax
      (lambda(where source)
        (or (let-filter (((fn) source)) (lambda(x) t))
            (error where "Illegal syntax in boolean type" source) ) ) )
;; string type check
(putp '-str-  'type-syntax
      (lambda(where source)
        (or (let-filter (((fn) source)) stringp)
            (error where "Illegal syntax in string type" source) ) ) )
;; numeric type check
(domapc ((fn '(-ubyte- -byte- -short- -int- -flt- -float- -real- -double-)))
  (putp fn 'type-syntax
        (lambda(where source)
          (or (let-filter (((fn) source)) numberp)
              (error where "Illegal syntax in number type" source) ) ) ) )
;; object type check
(putp '-obj- 'type-syntax
      (lambda(where source)
        (or (let-filter (((fn (classname)) source))
              (and (symbolp classname) 
                   (eval `(lambda(x) (is-of-class x ,classname)))) )
            (error where "Illegal syntax in object type" source) ) ) )
;; gptr type check
(putp '-gptr- 'type-syntax
      (lambda(where source)
        (let ((gptrp (lambda(x) (or (not x) (is-of-class x |GPTR|)))))
          (or (let-filter (((fn) source)) gptrp)
              (let-filter (((fn arg) source)) (and (stringp arg) gptrp))
              (let-filter (((fn (arg)) source)) (and (symbolp arg) gptrp))
              (error where "Illegal syntax in gptr type" source) ) ) ) )
;; list type check
(putp '-list- 'type-syntax
      (lambda(where source)
        (let ((chk ())
              (listchk (lambda(x chk)
                         (let ((okay t))
                           (while (and okay (consp x) (consp chk))
                             (setq okay ((car chk) (car x)))
                             (setq chk (cdr chk))
                             (setq x (cdr x)) )
                           (and okay (not x) (not chk)) ) )))
          (each ((arg (cdr source)))
            (setq chk (nconc1 chk (verify-type-decl-format arg where))) )
          (eval `(lambda(x) (,listchk x ',chk))) ) ) )
;; function type check
(putp '-func- 'type-syntax
      (lambda (where source)
	(or (let-filter (((fn fargs result) source))
	      (and (verify-type-decl-format `(-list- ,@fargs) where)
		   (verify-type-decl-format result where)
		   (eval `(lambda (f) (= (length (cadr (funcdef f))) 
					 ,(length fargs))))))
	    (error where "Illegal syntax in function type" source) )))
;; method type check
(putp '-method- 'type-syntax
      (lambda (where source)
	(or (let-filter (((fn (classname) fargs result) source))
              (and (symbolp classname) 
		   (verify-type-decl-format `(-list- ,@fargs) where)
		   (verify-type-decl-format result where)
		   (eval `(flambda (f)
			    (and
			     (member f (methods ,classname))
			     (= (length (cadr (funcdef (getmethod ,classname f))))
				,(length fargs)))) )))
	    (error where "Illegal syntax in function type" source) )))
;; idx type check
(let* ((idxsyntax 
        (lambda(ndim where source)
          (let ((idxcheck 
                 (lambda(x ndim srgtype)
                   (and (indexp x) (= (idx-rank x) ndim)
                        (is-of-class (idx-storage x) srgtype) ) ) ))
            (or (let-filter (((fn (base)) source))
                  (let ((srgtype (getp base 'srg-type)))
                    (when (or (not (symbolp base)) (not srgtype))
                      (error where "Illegal base for index type" source) )
                    (eval `(lambda(x) (,idxcheck x ,ndim ,srgtype))) ) )
                (error where "Illegal syntax in index type" source) )))))
  (for (ndim 0 +MAXDIMS+)
    (putp (named (sprintf "-idx%d-" ndim)) 'type-syntax
          (eval `(lambda(where source) 
                   (,idxsyntax ,ndim where source) ) ))))
;; srg type check
(putp '-srg- 'type-syntax
      (lambda(where source)
	(or (let-filter (((fn (base)) source))
	      (let ((srgtype (getp base 'srg-type)))
		(when (or (not (symbolp base)) (not srgtype))
		  (error where "Illegal base for storage type" source) )
		(eval `(lambda(x) (,is-of-class x ,srgtype))) ))
	    (error where "Illegal syntax in storage type" source) )))

;; variable declaration
(df declare (|Type| . |Syms|)
  (setq |Type| (verify-type-decl-format |Type|))
  (each ((|Sym| |Syms|))
    (when (not (symbolp |Sym|))
      (error 'declare "not a symbol" |Sym|) )
    (when (not (eval (list |Type| |Sym|)))
      (error 'declare "type mismatch" |Sym|) ) ) )

(lock-symbol verify-type-decl-format 
             verify-type-decl-format.table declare)




;;; --------- Misc compiler support ---------

(df breakp () 
  () )
(dm protect (fn . args)
  (cons 'progn args) )
(dm unprotect (fn . args)
  (cons 'progn args) )
(de ccall args
  (error 'ccall "only works in compiled functions" ()) )
(df cinline args
  (error 'cinline "only works in compiled functions" ()) )
(df cheader args
  (error 'cheader "only works in compiled functions" ()) )
(df cpheader args
  (error 'cpheader "only works in compiled functions" ()) )
(df cinit args
  (error 'cpheader "only works in compiled functions" ()) )
(df cidx-bloop args
  (error 'cidx-bloop "only works in compiled functions" ()) )

(dm ifdef (ifdef |TEST| . |ARGS|)
  (if (eval |TEST|)
      `(progn ,(car |ARGS|))
    `(progn ,@(cdr |ARGS|)) ) )

(dm ifcompiled (fn then . else)
  (cons 'progn else) )

(de cmacro.read-c()
  (let ((nextchar (skip-char "")))
    (cond
     ((= nextchar "$")
      (cmacro.read-dollar) )
     ((= nextchar "#")
      (read-string 1)
      (if (<> (skip-char "") "}") "#" (read-string 1) "#}") )
     ((index nextchar " \t\n\r")
      (read-string " \t\n\r") )
     ((index nextchar "\"'")
      (cmacro.read-string (read-string 1)) )
     ((= nextchar "/")
      (cmacro.read-comment))
     (t
      (read-string "~$#\"'/\e") ) ) ) )

(de cmacro.read-comment()
  (let ((c (read-string 1))
	(cc (skip-char "")) )
    (selectq cc
      ("/" ;; c++ style comment
       (setq c (concat c (read-string "~\n\r") "\n")) )
      ("*" ;; c style comment
       (while (and (<> cc "/") (<> cc "\e"))
	 (setq c (concat c (read-string "~*\e") (read-string "*")))
	 (setq cc (skip-char "")) )
       (setq c (concat c (read-string 1))) ) )
    c) )

(de cmacro.read-string(delim)
  (let ((dat (list delim))
        (str ())
        (ok t))
    (while ok
      (setq str (read-string (concat "~\e\\" delim)))
      (setq dat (nconc1 dat str))
      (if (= (skip-char "") "\\")
          (setq dat (nconc1 dat (read-string 2)))
        (setq ok ()) ) )
    (if (= (skip-char "") delim)
        (setq dat (nconc1 dat (read-string 1))) )
    (apply concat dat) ) )

(de cmacro.read-dollar()
  (read-string 1)
  (let ((nextchar (skip-char "")))
    (cond 
     ((= nextchar "(")
      (read) )
     ((= nextchar "{")
      (read-string 1)
      (let ((data (read-string "~{}() ;'\"")))
        (if (<> (read-string 1) "}") 
            (error "Illegal $-expression in #{ ... #}")
          (named data) ) ) )
     ((and (>= (upcase nextchar) "A") (<= (upcase nextchar) "Z"))
      (namedclean (read-string "A-Za-z0-9_")) )
     (t
      (error "Illegal $-expression in #{ .... #}") ) ) ) )

(de cmacro.parse-c (s)
  (let ((continue t)
	(exprs ()) 
	(stmts (list "")) )
    (reading-string s
      (while continue
	(let ((item (cmacro.read-c)))
	  (when (stringp item)
	    (setq item (regex-subst "%" "%%%%" item)))
	  (cond
	   ((= item "")
	    (setq continue ()) )
	   ((stringp item)
	    (setq stmts (nconc1 stmts item)) )
	   (t
	    (setq stmts (nconc1 stmts "(%s)"))
	    (setq exprs (nconc1 exprs item)) )))))
    (let ((l (lastcdr stmts)))
      (rplaca l (regex-subst "[ \t\n\r]*$" "" (car l)))
      `(cinline ,(apply concat stmts) ,@exprs) )))

(defmacro defcmacro def
  (when define-hook (setq def (apply define-hook def)))
  (let (((name args . ccode) def)
	(fargs ())
 	(substitutor '(lambda (s)))
 	(argchk-code ())
	(bindings ()) ) 
    ;; process formal arguments
    (domapcar ((arg args))
      (setq fargs (cons (gensym) fargs))
      (cond
       ((stringp arg)
	(setq argchk-code (append argchk-code `((when (not (stringp ,(car fargs)))
						(error "not a string" ,(car fargs)))) ))
	(setq substitutor (append substitutor `((setq s (regex-subst ,arg ,(car fargs) s))) )))
       ((symbolp arg)
	(setq argchk-code (append argchk-code `((when (not (symbolp ,(car fargs)))
						(error "not a symbol" ,(car fargs)))) ))
	(setq bindings (cons (list 'list (list 'quote arg) (car fargs)) bindings)) )
       (t
	(error "invalid formal argument" arg) )))
    (setq substitutor (append substitutor '(s)))
    ;; check macro body
    (domapcar ((cline ccode))
      (when (not (stringp cline)) (error "not a string" cline)) )
    ;; create the macro 
    `(defmacro ,name (,@(reverse fargs))
       ,@argchk-code
       (let ((ccode (mapcar ,substitutor ',ccode)))
	 (nconc (list 'let (list ,@(reverse bindings)))
		(domapcar ((cline ccode)) (cmacro.parse-c cline)) )))
    ))

(dmc |#{|
  (let ((again t)
        (expr ()) 
        (stmt (list "")) )
    (while again
      (let ((item (cmacro.read-c)))
        (when (stringp item)
          (setq item (regex-subst "%" "%%%%" item)) )
        (cond
         ((= item "#}")
          (setq again ()) )
         ((= item "\e")
          (error "unbalanced cmacro #{ #}") )
	 ((stringp item)
	  (setq stmt (nconc1 stmt item)) )
	 (t
	  (setq stmt (nconc1 stmt "(%s)"))
	  (setq expr (nconc1 expr item)) ) ) ) )
    (let ((l (lastcdr stmt)))
      (rplaca l (regex-subst "[ \t\n\r]*$" "" (car l))) )
    (list  `(cinline ,(apply concat stmt) ,@expr)) ) )

(lock-symbol breakp protect unprotect 
             cinline ifdef ifcompiled
             cmacro.read-c cmacro.parse-c cmacro.read-string 
	     cmacro.read-comment cmacro.read-dollar |#{|
	     defcmacro)

;;; --------- Online Help Support ---------

(defvar |*HELPFILES| ())

(dmc |^A| (list 'apropos (read-string)))

(dmc |#?|
     (read-string "~\n\r\e")
     (when (and (<> file-being-loaded "$stdin")
                (<> file-being-loaded (car |*HELPFILES|)) )
       (let ((m (member file-being-loaded |*HELPFILES|)))
         (when m 
           (rplaca m (car |*HELPFILES|))
           (setq |*HELPFILES| (cdr |*HELPFILES|)) ) )
       (setq |*HELPFILES| (cons file-being-loaded |*HELPFILES|)) )
     () )

(dmc |^H| (helptool))

(de help () 
  (printf "Enter ^H or (helptool) to open the Lush documentation browser window.\n")
  (printf "Enter ^A<topic> for console-based topic help.\n"))



;;; --------- File searching -----------

(de find-file (dirlist file &optional extlist)
  (setq extlist (or extlist (list "")))
  (let ((keepgoing t) (e ()) (d ()) (f ()) (r ()))
    (while (and keepgoing dirlist)
      (setq d (car dirlist))
      (setq e extlist)
      (while (and keepgoing e)
        (setq f (concat-fname d (concat file (car e))))
        (when (filep f)
          (setq r f) (setq keepgoing ()))
        (setq e (cdr e)))
      (setq dirlist (cdr dirlist)))
    r))

(defvar c-include-path      '("/usr/include"))
(defvar static-library-path '("/usr/lib"))
(defvar shared-library-path '("/usr/lib"))

(de find-c-include(name) 
  (find-file c-include-path name '("")) )

(de find-static-library(name &optional extlist)
  (when (not extlist)
    (setq extlist '(""))
    (when (not (index "." (basename name)))
      (setq extlist (list (concat "." (or (getconf "AEXT") "a")))) ) )
  (find-file static-library-path name extlist) )

(de find-shared-library(name &optional extlist)
  (let ((p shared-library-path))
    (when (not extlist)
      (setq extlist '(""))
      (when (not (index "." (basename name)))
        (setq extlist (list (concat "." (or (getconf "SOEXT") "so")))) ) )
    (when (filep "/etc/ld.so.conf")
      (reading "/etc/ld.so.conf"
	(while (<> (skip-char) "\e")
	  (let ((d (read-string "~\n\r\t\b ")))
	    (when (and (dirp d) (not (member d p)))
	      (setq p (cons d p)) ) ) ) ) )
    (find-file (reverse p) name extlist) ) )

(de find-shared-or-static-library(name &optional extlist)
  (or (find-shared-library name extlist)
      (find-static-library name) ) )

(lock-symbol find-c-include
             find-shared-library  
             find-static-library  
             find-shared-or-static-library )

;;; --------- autoload instructions ----------

(autoload "libc/libc" testbit)
(autoload "libidx/idx-sort" idx-f1bsearch idx-d1bsearch idx-i1bsearch)
(autoload "libidx/finding"  array-where-nonzero array-take*)
(autoload "libcl/numbers" oddp evenp)

;;; --------- Boostrap startup -----------


(dm startup(f . argv)
  (when argv
    ;; This is only used to create nice dump files
    (when (or (<> (length argv) 3) (<> (nth 1 argv) "--"))
      (writing "$stderr"
        (printf "Usage: lush2 @sysenv <lushfile> -- <dumpfile>\n") 
        (exit 10) ) )
    (let ((file (car argv)))
      (apply path (path))
      (setq file (or (filepath file) file))
      (when (not (filep file))
        (writing "$stderr"
          (printf "lush2 @sysenv: cannot locate file '%s'\n" file)
          (exit 10) ) )
      `(progn
         (lush-is-quiet ())
         (printf "... loading file \"%s\".\n" ,file)
         (libload ,file)
         (when (== startup ,startup)
           (writing "$stderr"
             (printf "lush2 @sysenv: lush file must define 'startup'.\n")
             (exit 10) ) )
         (printf "... dumping to \"%s\" (%d KB).\n"
                 ,(lasta argv) (/ (dump ,(lasta argv)) 1024) )
         (exit 0) ) ) ) )
